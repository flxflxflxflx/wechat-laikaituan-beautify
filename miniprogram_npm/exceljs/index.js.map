{"version":3,"sources":["excel.js","lib/exceljs.nodejs.js","lib/doc/workbook.js","lib/doc/worksheet.js","lib/utils/under-dash.js","lib/utils/col-cache.js","lib/doc/range.js","lib/doc/row.js","lib/doc/enums.js","lib/doc/cell.js","lib/utils/shared-formula.js","lib/doc/note.js","lib/doc/column.js","lib/doc/image.js","lib/doc/anchor.js","lib/doc/table.js","lib/doc/data-validations.js","lib/utils/encryptor.js","lib/doc/defined-names.js","lib/utils/cell-matrix.js","lib/xlsx/xlsx.js","lib/utils/zip-stream.js","lib/utils/stream-buf.js","lib/utils/utils.js","lib/utils/string-buf.js","lib/utils/browser-buffer-encode.js","lib/utils/xml-stream.js","lib/utils/browser-buffer-decode.js","lib/xlsx/xform/style/styles-xform.js","lib/xlsx/xform/base-xform.js","lib/utils/parse-sax.js","lib/xlsx/xform/static-xform.js","lib/xlsx/xform/list-xform.js","lib/xlsx/xform/style/font-xform.js","lib/xlsx/xform/style/color-xform.js","lib/xlsx/xform/simple/boolean-xform.js","lib/xlsx/xform/simple/integer-xform.js","lib/xlsx/xform/simple/string-xform.js","lib/xlsx/xform/style/underline-xform.js","lib/xlsx/xform/style/fill-xform.js","lib/xlsx/xform/style/border-xform.js","lib/xlsx/xform/style/numfmt-xform.js","lib/xlsx/defaultnumformats.js","lib/xlsx/xform/style/style-xform.js","lib/xlsx/xform/style/alignment-xform.js","lib/xlsx/xform/style/protection-xform.js","lib/xlsx/xform/style/dxf-xform.js","lib/xlsx/xform/core/core-xform.js","lib/xlsx/xform/simple/date-xform.js","lib/xlsx/xform/strings/shared-strings-xform.js","lib/xlsx/xform/strings/shared-string-xform.js","lib/xlsx/xform/strings/text-xform.js","lib/xlsx/xform/strings/rich-text-xform.js","lib/xlsx/xform/strings/phonetic-text-xform.js","lib/xlsx/xform/core/relationships-xform.js","lib/xlsx/xform/core/relationship-xform.js","lib/xlsx/xform/core/content-types-xform.js","lib/xlsx/xform/core/app-xform.js","lib/xlsx/xform/core/app-heading-pairs-xform.js","lib/xlsx/xform/core/app-titles-of-parts-xform.js","lib/xlsx/xform/book/workbook-xform.js","lib/xlsx/xform/book/defined-name-xform.js","lib/xlsx/xform/book/sheet-xform.js","lib/xlsx/xform/book/workbook-view-xform.js","lib/xlsx/xform/book/workbook-properties-xform.js","lib/xlsx/xform/book/workbook-calc-properties-xform.js","lib/xlsx/xform/sheet/worksheet-xform.js","lib/xlsx/rel-type.js","lib/xlsx/xform/sheet/merges.js","lib/xlsx/xform/sheet/row-xform.js","lib/xlsx/xform/sheet/cell-xform.js","lib/xlsx/xform/sheet/col-xform.js","lib/xlsx/xform/sheet/dimension-xform.js","lib/xlsx/xform/sheet/hyperlink-xform.js","lib/xlsx/xform/sheet/merge-cell-xform.js","lib/xlsx/xform/sheet/data-validations-xform.js","lib/xlsx/xform/sheet/sheet-properties-xform.js","lib/xlsx/xform/sheet/page-setup-properties-xform.js","lib/xlsx/xform/sheet/outline-properties-xform.js","lib/xlsx/xform/sheet/sheet-format-properties-xform.js","lib/xlsx/xform/sheet/sheet-view-xform.js","lib/xlsx/xform/sheet/sheet-protection-xform.js","lib/xlsx/xform/sheet/page-margins-xform.js","lib/xlsx/xform/sheet/page-setup-xform.js","lib/xlsx/xform/sheet/print-options-xform.js","lib/xlsx/xform/sheet/auto-filter-xform.js","lib/xlsx/xform/sheet/picture-xform.js","lib/xlsx/xform/sheet/drawing-xform.js","lib/xlsx/xform/sheet/table-part-xform.js","lib/xlsx/xform/sheet/row-breaks-xform.js","lib/xlsx/xform/sheet/page-breaks-xform.js","lib/xlsx/xform/sheet/header-footer-xform.js","lib/xlsx/xform/sheet/cf/conditional-formattings-xform.js","lib/xlsx/xform/sheet/cf/conditional-formatting-xform.js","lib/xlsx/xform/composite-xform.js","lib/xlsx/xform/sheet/cf/cf-rule-xform.js","lib/xlsx/xform/sheet/cf/databar-xform.js","lib/xlsx/xform/sheet/cf/cfvo-xform.js","lib/xlsx/xform/sheet/cf/ext-lst-ref-xform.js","lib/xlsx/xform/sheet/cf/formula-xform.js","lib/xlsx/xform/sheet/cf/color-scale-xform.js","lib/xlsx/xform/sheet/cf/icon-set-xform.js","lib/xlsx/xform/sheet/ext-lst-xform.js","lib/xlsx/xform/sheet/cf-ext/conditional-formattings-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cf-rule-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/databar-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cfvo-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/f-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/icon-set-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cf-icon-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/conditional-formatting-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/sqref-ext-xform.js","lib/xlsx/xform/drawing/drawing-xform.js","lib/xlsx/xform/drawing/two-cell-anchor-xform.js","lib/xlsx/xform/drawing/base-cell-anchor-xform.js","lib/xlsx/xform/drawing/cell-position-xform.js","lib/xlsx/xform/drawing/pic-xform.js","lib/xlsx/xform/drawing/blip-fill-xform.js","lib/xlsx/xform/drawing/blip-xform.js","lib/xlsx/xform/drawing/nv-pic-pr-xform.js","lib/xlsx/xform/drawing/c-nv-pr-xform.js","lib/xlsx/xform/drawing/hlink-click-xform.js","lib/xlsx/xform/drawing/ext-lst-xform.js","lib/xlsx/xform/drawing/c-nv-pic-pr-xform.js","lib/xlsx/xform/drawing/sp-pr.js","lib/xlsx/xform/drawing/one-cell-anchor-xform.js","lib/xlsx/xform/drawing/ext-xform.js","lib/xlsx/xform/table/table-xform.js","lib/xlsx/xform/table/auto-filter-xform.js","lib/xlsx/xform/table/filter-column-xform.js","lib/xlsx/xform/table/table-column-xform.js","lib/xlsx/xform/table/table-style-info-xform.js","lib/xlsx/xform/comment/comments-xform.js","lib/xlsx/xform/comment/comment-xform.js","lib/xlsx/xform/comment/vml-notes-xform.js","lib/xlsx/xform/comment/vml-shape-xform.js","lib/xlsx/xform/comment/vml-textbox-xform.js","lib/xlsx/xform/comment/vml-client-data-xform.js","lib/xlsx/xform/comment/vml-anchor-xform.js","lib/xlsx/xform/comment/style/vml-protection-xform.js","lib/xlsx/xform/comment/style/vml-position-xform.js","lib/xlsx/xml/theme1.js","lib/csv/csv.js","lib/doc/modelcontainer.js","lib/stream/xlsx/workbook-writer.js","lib/utils/shared-strings.js","lib/stream/xlsx/worksheet-writer.js","lib/stream/xlsx/sheet-rels-writer.js","lib/stream/xlsx/sheet-comments-writer.js","lib/stream/xlsx/workbook-reader.js","lib/utils/iterate-stream.js","lib/stream/xlsx/worksheet-reader.js","lib/stream/xlsx/hyperlink-reader.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA,AGTA;AJaA,AENA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AgBhDA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AgBhDA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AgBhDA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,ANkBA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AIZA,AENA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AMlBA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AiBnDA,ADGA;ANmBA,ALeA,AGTA,AMlBA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AlBsDA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,AV8BA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,APqBA,AYpCA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AFMA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AsBlEA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,ADGA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AOrBA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AOrBA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AOrBA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AKfA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,AFMA,ANkBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,ARwBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,ARwBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,ADGA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,ARwBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,ARwBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AwBxEA,ARwBA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,ALeA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AYpCA,AavCA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AyB3EA,ARwBA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;ANmBA,ALeA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AENA,ApB4DA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AqB/DA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AqB/DA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,Ae7CA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,AlBsDA,AmBzDA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ADGA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,AIZA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AgBhDA,Ad0CA,AiBnDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,AMlBA,AZoCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AbuCA,ACHA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,APqBA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AT2BA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AkBtDA,AJYA,A6BvFA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AoB5DA,AkBtDA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AgBhDA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AgBhDA,ADGA,APqBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ADGA,APqBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AiBnDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A9B0FA,AIZA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AGTA,ALeA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AtBkEA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,AHSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,AHSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,AHSA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AwExNA,Af6CA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AwExNA,Af6CA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AwExNA,Af6CA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,Af6CA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,Af6CA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,Af6CA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,AlBsDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,AlBsDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,AlBsDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AENA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AKfA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AKfA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AKfA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA;AXkCA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA,AyH3WA;ApI6YA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA,AyH3WA;ApI6YA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,ACHA,ACHA,AJYA,A3GiUA,AyH3WA;ACFA,ArI+YA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA,AyH3WA;ACFA,ArI+YA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AFMA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AhBgDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,AmBzDA,AsClHA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,AyD3KA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,A6IvaA,ApF4PA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,A6IvaA,ApF4PA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,A6IvaA,ApF4PA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ACHA,AJYA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,A6IvaA,ACHA,ArF+PA,AyE3NA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AxIwZA,AQxBA,AZoCA,A6IvaA,ACHA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,A6IvaA,ACHA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,A6IvaA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,A6IvaA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,A6IvaA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AgJhbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AgJhbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AgJhbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AiJnbA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AiJnbA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AxBwEA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AiJnbA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AsIlZA,AhIgYA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,AlEsMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,ACHA,AjEmMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AT2BA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AT2BA,AHSA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AhEgMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,AMlBA,AZoCA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AqJ/bA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ADGA,AENA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ACHA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ACHA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ACHA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ACHA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AiJnbA,ACHA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,AtCkHA,ARwBA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;A0H7WA,ArI+YA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A5EoOA,AJYA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,AhFgPA,A9C0IA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA,A9H0XA;AXkCA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,ALeA,AOrBA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AkJtbA,AENA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,AoJ5bA,ALeA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,ANkBA,A+I7aA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AzI4ZA,AyI3ZA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Copyright (c) 2014-2019 Guyon Roche\r\n * LICENCE: MIT - please refer to LICENSE file included with this module\r\n * or https://github.com/exceljs/exceljs/blob/master/LICENSE\r\n */\r\n\r\nif (parseInt(process.versions.node.split('.')[0], 10) < 10) {\r\n  throw new Error(\r\n    'For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports'\r\n  );\r\n}\r\n\r\nmodule.exports = require('./lib/exceljs.nodejs.js');\r\n","const ExcelJS = {\r\n  Workbook: require('./doc/workbook'),\r\n  ModelContainer: require('./doc/modelcontainer'),\r\n  stream: {\r\n    xlsx: {\r\n      WorkbookWriter: require('./stream/xlsx/workbook-writer'),\r\n      WorkbookReader: require('./stream/xlsx/workbook-reader'),\r\n    },\r\n  },\r\n};\r\n\r\nObject.assign(ExcelJS, require('./doc/enums'));\r\n\r\nmodule.exports = ExcelJS;\r\n","\r\n\r\nconst Worksheet = require('./worksheet');\r\nconst DefinedNames = require('./defined-names');\r\nconst XLSX = require('../xlsx/xlsx');\r\nconst CSV = require('../csv/csv');\r\n\r\n// Workbook requirements\r\n//  Load and Save from file and stream\r\n//  Access/Add/Delete individual worksheets\r\n//  Manage String table, Hyperlink table, etc.\r\n//  Manage scaffolding for contained objects to write to/read from\r\n\r\nclass Workbook {\r\n  constructor() {\r\n    this.category = '';\r\n    this.company = '';\r\n    this.created = new Date();\r\n    this.description = '';\r\n    this.keywords = '';\r\n    this.manager = '';\r\n    this.modified = this.created;\r\n    this.properties = {};\r\n    this.calcProperties = {};\r\n    this._worksheets = [];\r\n    this.subject = '';\r\n    this.title = '';\r\n    this.views = [];\r\n    this.media = [];\r\n    this._definedNames = new DefinedNames();\r\n  }\r\n\r\n  get xlsx() {\r\n    if (!this._xlsx) this._xlsx = new XLSX(this);\r\n    return this._xlsx;\r\n  }\r\n\r\n  get csv() {\r\n    if (!this._csv) this._csv = new CSV(this);\r\n    return this._csv;\r\n  }\r\n\r\n  get nextId() {\r\n    // find the next unique spot to add worksheet\r\n    for (let i = 1; i < this._worksheets.length; i++) {\r\n      if (!this._worksheets[i]) {\r\n        return i;\r\n      }\r\n    }\r\n    return this._worksheets.length || 1;\r\n  }\r\n\r\n  addWorksheet(name, options) {\r\n    const id = this.nextId;\r\n\r\n    if (name && name.length > 31) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);\r\n    }\r\n\r\n    // Illegal character in worksheet name: asterisk (*), question mark (?),\r\n    // colon (:), forward slash (/ \\), or bracket ([])\r\n    if (/[*?:/\\\\[\\]]/.test(name)) {\r\n      throw new Error(\r\n        `Worksheet name ${name} cannot include any of the following characters: * ? : \\\\ / [ ]`\r\n      );\r\n    }\r\n\r\n    if (/(^')|('$)/.test(name)) {\r\n      throw new Error(\r\n        `The first or last character of worksheet name cannot be a single quotation mark: ${name}`\r\n      );\r\n    }\r\n\r\n    name = (name || `sheet${id}`).substring(0, 31);\r\n    if (this._worksheets.find(ws => ws && ws.name.toLowerCase() === name.toLowerCase())) {\r\n      throw new Error(`Worksheet name already exists: ${name}`);\r\n    }\r\n\r\n    // if options is a color, call it tabColor (and signal deprecated message)\r\n    if (options) {\r\n      if (typeof options === 'string') {\r\n        // eslint-disable-next-line no-console\r\n        console.trace(\r\n          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: \"rbg value\" } }'\r\n        );\r\n        options = {\r\n          properties: {\r\n            tabColor: {argb: options},\r\n          },\r\n        };\r\n      } else if (options.argb || options.theme || options.indexed) {\r\n        // eslint-disable-next-line no-console\r\n        console.trace(\r\n          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }'\r\n        );\r\n        options = {\r\n          properties: {\r\n            tabColor: options,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    const lastOrderNo = this._worksheets.reduce(\r\n      (acc, ws) => ((ws && ws.orderNo) > acc ? ws.orderNo : acc),\r\n      0\r\n    );\r\n    const worksheetOptions = Object.assign({}, options, {\r\n      id,\r\n      name,\r\n      orderNo: lastOrderNo + 1,\r\n      workbook: this,\r\n    });\r\n\r\n    const worksheet = new Worksheet(worksheetOptions);\r\n\r\n    this._worksheets[id] = worksheet;\r\n    return worksheet;\r\n  }\r\n\r\n  removeWorksheetEx(worksheet) {\r\n    delete this._worksheets[worksheet.id];\r\n  }\r\n\r\n  removeWorksheet(id) {\r\n    const worksheet = this.getWorksheet(id);\r\n    if (worksheet) {\r\n      worksheet.destroy();\r\n    }\r\n  }\r\n\r\n  getWorksheet(id) {\r\n    if (id === undefined) {\r\n      return this._worksheets.find(Boolean);\r\n    }\r\n    if (typeof id === 'number') {\r\n      return this._worksheets[id];\r\n    }\r\n    if (typeof id === 'string') {\r\n      return this._worksheets.find(worksheet => worksheet && worksheet.name === id);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  get worksheets() {\r\n    // return a clone of _worksheets\r\n    return this._worksheets\r\n      .slice(1)\r\n      .sort((a, b) => a.orderNo - b.orderNo)\r\n      .filter(Boolean);\r\n  }\r\n\r\n  eachSheet(iteratee) {\r\n    this.worksheets.forEach(sheet => {\r\n      iteratee(sheet, sheet.id);\r\n    });\r\n  }\r\n\r\n  get definedNames() {\r\n    return this._definedNames;\r\n  }\r\n\r\n  clearThemes() {\r\n    // Note: themes are not an exposed feature, meddle at your peril!\r\n    this._themes = undefined;\r\n  }\r\n\r\n  addImage(image) {\r\n    // TODO:  validation?\r\n    const id = this.media.length;\r\n    this.media.push(Object.assign({}, image, {type: 'image'}));\r\n    return id;\r\n  }\r\n\r\n  getImage(id) {\r\n    return this.media[id];\r\n  }\r\n\r\n  get model() {\r\n    return {\r\n      creator: this.creator || 'Unknown',\r\n      lastModifiedBy: this.lastModifiedBy || 'Unknown',\r\n      lastPrinted: this.lastPrinted,\r\n      created: this.created,\r\n      modified: this.modified,\r\n      properties: this.properties,\r\n      worksheets: this.worksheets.map(worksheet => worksheet.model),\r\n      sheets: this.worksheets.map(ws => ws.model).filter(Boolean),\r\n      definedNames: this._definedNames.model,\r\n      views: this.views,\r\n      company: this.company,\r\n      manager: this.manager,\r\n      title: this.title,\r\n      subject: this.subject,\r\n      keywords: this.keywords,\r\n      category: this.category,\r\n      description: this.description,\r\n      language: this.language,\r\n      revision: this.revision,\r\n      contentStatus: this.contentStatus,\r\n      themes: this._themes,\r\n      media: this.media,\r\n      calcProperties: this.calcProperties,\r\n    };\r\n  }\r\n\r\n  set model(value) {\r\n    this.creator = value.creator;\r\n    this.lastModifiedBy = value.lastModifiedBy;\r\n    this.lastPrinted = value.lastPrinted;\r\n    this.created = value.created;\r\n    this.modified = value.modified;\r\n    this.company = value.company;\r\n    this.manager = value.manager;\r\n    this.title = value.title;\r\n    this.subject = value.subject;\r\n    this.keywords = value.keywords;\r\n    this.category = value.category;\r\n    this.description = value.description;\r\n    this.language = value.language;\r\n    this.revision = value.revision;\r\n    this.contentStatus = value.contentStatus;\r\n\r\n    this.properties = value.properties;\r\n    this.calcProperties = value.calcProperties;\r\n    this._worksheets = [];\r\n    value.worksheets.forEach(worksheetModel => {\r\n      const {id, name, state} = worksheetModel;\r\n      const orderNo = value.sheets && value.sheets.findIndex(ws => ws.id === id);\r\n      const worksheet = (this._worksheets[id] = new Worksheet({\r\n        id,\r\n        name,\r\n        orderNo,\r\n        state,\r\n        workbook: this,\r\n      }));\r\n\r\n      worksheet.model = worksheetModel;\r\n    });\r\n\r\n    this._definedNames.model = value.definedNames;\r\n    this.views = value.views;\r\n    this._themes = value.themes;\r\n    this.media = value.media || [];\r\n  }\r\n}\r\n\r\nmodule.exports = Workbook;\r\n","const _ = require('../utils/under-dash');\r\n\r\nconst colCache = require('../utils/col-cache');\r\nconst Range = require('./range');\r\nconst Row = require('./row');\r\nconst Column = require('./column');\r\nconst Enums = require('./enums');\r\nconst Image = require('./image');\r\nconst Table = require('./table');\r\nconst DataValidations = require('./data-validations');\r\nconst Encryptor = require('../utils/encryptor');\r\n\r\n// Worksheet requirements\r\n//  Operate as sheet inside workbook or standalone\r\n//  Load and Save from file and stream\r\n//  Access/Add/Delete individual cells\r\n//  Manage column widths and row heights\r\n\r\nclass Worksheet {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // in a workbook, each sheet will have a number\r\n    this.id = options.id;\r\n    this.orderNo = options.orderNo;\r\n\r\n    // and a name\r\n    this.name = options.name || `Sheet${this.id}`;\r\n\r\n    // add a state\r\n    this.state = options.state || 'visible';\r\n\r\n    // rows allows access organised by row. Sparse array of arrays indexed by row-1, col\r\n    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index\r\n    this._rows = [];\r\n\r\n    // column definitions\r\n    this._columns = null;\r\n\r\n    // column keys (addRow convenience): key ==> this._collumns index\r\n    this._keys = {};\r\n\r\n    // keep record of all merges\r\n    this._merges = {};\r\n\r\n    // record of all row and column pageBreaks\r\n    this.rowBreaks = [];\r\n\r\n    this._workbook = options.workbook;\r\n\r\n    // for tabColor, default row height, outline levels, etc\r\n    this.properties = Object.assign(\r\n      {},\r\n      {\r\n        defaultRowHeight: 15,\r\n        dyDescent: 55,\r\n        outlineLevelCol: 0,\r\n        outlineLevelRow: 0,\r\n      },\r\n      options.properties\r\n    );\r\n\r\n    // for all things printing\r\n    this.pageSetup = Object.assign(\r\n      {},\r\n      {\r\n        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},\r\n        orientation: 'portrait',\r\n        horizontalDpi: 4294967295,\r\n        verticalDpi: 4294967295,\r\n        fitToPage: !!(\r\n          options.pageSetup &&\r\n          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&\r\n          !options.pageSetup.scale\r\n        ),\r\n        pageOrder: 'downThenOver',\r\n        blackAndWhite: false,\r\n        draft: false,\r\n        cellComments: 'None',\r\n        errors: 'displayed',\r\n        scale: 100,\r\n        fitToWidth: 1,\r\n        fitToHeight: 1,\r\n        paperSize: undefined,\r\n        showRowColHeaders: false,\r\n        showGridLines: false,\r\n        firstPageNumber: undefined,\r\n        horizontalCentered: false,\r\n        verticalCentered: false,\r\n        rowBreaks: null,\r\n        colBreaks: null,\r\n      },\r\n      options.pageSetup\r\n    );\r\n\r\n    this.headerFooter = Object.assign(\r\n      {},\r\n      {\r\n        differentFirst: false,\r\n        differentOddEven: false,\r\n        oddHeader: null,\r\n        oddFooter: null,\r\n        evenHeader: null,\r\n        evenFooter: null,\r\n        firstHeader: null,\r\n        firstFooter: null,\r\n      },\r\n      options.headerFooter\r\n    );\r\n\r\n    this.dataValidations = new DataValidations();\r\n\r\n    // for freezepanes, split, zoom, gridlines, etc\r\n    this.views = options.views || [];\r\n\r\n    this.autoFilter = options.autoFilter || null;\r\n\r\n    // for images, etc\r\n    this._media = [];\r\n\r\n    // worksheet protection\r\n    this.sheetProtection = null;\r\n\r\n    // for tables\r\n    this.tables = {};\r\n\r\n    this.conditionalFormattings = [];\r\n  }\r\n\r\n  get workbook() {\r\n    return this._workbook;\r\n  }\r\n\r\n  // when you're done with this worksheet, call this to remove from workbook\r\n  destroy() {\r\n    this._workbook.removeWorksheetEx(this);\r\n  }\r\n\r\n  // Get the bounding range of the cells in this worksheet\r\n  get dimensions() {\r\n    const dimensions = new Range();\r\n    this._rows.forEach(row => {\r\n      if (row) {\r\n        const rowDims = row.dimensions;\r\n        if (rowDims) {\r\n          dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);\r\n        }\r\n      }\r\n    });\r\n    return dimensions;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Columns\r\n\r\n  // get the current columns array.\r\n  get columns() {\r\n    return this._columns;\r\n  }\r\n\r\n  // set the columns from an array of column definitions.\r\n  // Note: any headers defined will overwrite existing values.\r\n  set columns(value) {\r\n    // calculate max header row count\r\n    this._headerRowCount = value.reduce((pv, cv) => {\r\n      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;\r\n      return Math.max(pv, headerCount);\r\n    }, 0);\r\n\r\n    // construct Column objects\r\n    let count = 1;\r\n    const columns = (this._columns = []);\r\n    value.forEach(defn => {\r\n      const column = new Column(this, count++, false);\r\n      columns.push(column);\r\n      column.defn = defn;\r\n    });\r\n  }\r\n\r\n  getColumnKey(key) {\r\n    return this._keys[key];\r\n  }\r\n\r\n  setColumnKey(key, value) {\r\n    this._keys[key] = value;\r\n  }\r\n\r\n  deleteColumnKey(key) {\r\n    delete this._keys[key];\r\n  }\r\n\r\n  eachColumnKey(f) {\r\n    _.each(this._keys, f);\r\n  }\r\n\r\n  // get a single column by col number. If it doesn't exist, create it and any gaps before it\r\n  getColumn(c) {\r\n    if (typeof c === 'string') {\r\n      // if it matches a key'd column, return that\r\n      const col = this._keys[c];\r\n      if (col) return col;\r\n\r\n      // otherwise, assume letter\r\n      c = colCache.l2n(c);\r\n    }\r\n    if (!this._columns) {\r\n      this._columns = [];\r\n    }\r\n    if (c > this._columns.length) {\r\n      let n = this._columns.length + 1;\r\n      while (n <= c) {\r\n        this._columns.push(new Column(this, n++));\r\n      }\r\n    }\r\n    return this._columns[c - 1];\r\n  }\r\n\r\n  spliceColumns(start, count, ...inserts) {\r\n    const rows = this._rows;\r\n    const nRows = rows.length;\r\n    if (inserts.length > 0) {\r\n      // must iterate over all rows whether they exist yet or not\r\n      for (let i = 0; i < nRows; i++) {\r\n        const rowArguments = [start, count];\r\n        // eslint-disable-next-line no-loop-func\r\n        inserts.forEach(insert => {\r\n          rowArguments.push(insert[i] || null);\r\n        });\r\n        const row = this.getRow(i + 1);\r\n        // eslint-disable-next-line prefer-spread\r\n        row.splice.apply(row, rowArguments);\r\n      }\r\n    } else {\r\n      // nothing to insert, so just splice all rows\r\n      this._rows.forEach(r => {\r\n        if (r) {\r\n          r.splice(start, count);\r\n        }\r\n      });\r\n    }\r\n\r\n    // splice column definitions\r\n    const nExpand = inserts.length - count;\r\n    const nKeep = start + count;\r\n    const nEnd = this._columns.length;\r\n    if (nExpand < 0) {\r\n      for (let i = start + inserts.length; i <= nEnd; i++) {\r\n        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;\r\n      }\r\n    } else if (nExpand > 0) {\r\n      for (let i = nEnd; i >= nKeep; i--) {\r\n        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;\r\n      }\r\n    }\r\n    for (let i = start; i < start + inserts.length; i++) {\r\n      this.getColumn(i).defn = null;\r\n    }\r\n\r\n    // account for defined names\r\n    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);\r\n  }\r\n\r\n  get lastColumn() {\r\n    return this.getColumn(this.columnCount);\r\n  }\r\n\r\n  get columnCount() {\r\n    let maxCount = 0;\r\n    this.eachRow(row => {\r\n      maxCount = Math.max(maxCount, row.cellCount);\r\n    });\r\n    return maxCount;\r\n  }\r\n\r\n  get actualColumnCount() {\r\n    // performance nightmare - for each row, counts all the columns used\r\n    const counts = [];\r\n    let count = 0;\r\n    this.eachRow(row => {\r\n      row.eachCell(({col}) => {\r\n        if (!counts[col]) {\r\n          counts[col] = true;\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Rows\r\n\r\n  _commitRow() {\r\n    // nop - allows streaming reader to fill a document\r\n  }\r\n\r\n  get _lastRowNumber() {\r\n    // need to cope with results of splice\r\n    const rows = this._rows;\r\n    let n = rows.length;\r\n    while (n > 0 && rows[n - 1] === undefined) {\r\n      n--;\r\n    }\r\n    return n;\r\n  }\r\n\r\n  get _nextRow() {\r\n    return this._lastRowNumber + 1;\r\n  }\r\n\r\n  get lastRow() {\r\n    if (this._rows.length) {\r\n      return this._rows[this._rows.length - 1];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // find a row (if exists) by row number\r\n  findRow(r) {\r\n    return this._rows[r - 1];\r\n  }\r\n\r\n  // find multiple rows (if exists) by row number\r\n  findRows(start, length) {\r\n    return this._rows.slice(start - 1, start - 1 + length);\r\n  }\r\n\r\n  get rowCount() {\r\n    return this._lastRowNumber;\r\n  }\r\n\r\n  get actualRowCount() {\r\n    // counts actual rows that have actual data\r\n    let count = 0;\r\n    this.eachRow(() => {\r\n      count++;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // get a row by row number.\r\n  getRow(r) {\r\n    let row = this._rows[r - 1];\r\n    if (!row) {\r\n      row = this._rows[r - 1] = new Row(this, r);\r\n    }\r\n    return row;\r\n  }\r\n\r\n  // get multiple rows by row number.\r\n  getRows(start, length) {\r\n    if (length < 1) return undefined;\r\n    const rows = [];\r\n    for (let i = start; i < start + length; i++) {\r\n      rows.push(this.getRow(i));\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  addRow(value, style = 'n') {\r\n    const rowNo = this._nextRow;\r\n    const row = this.getRow(rowNo);\r\n    row.values = value;\r\n    this._setStyleOption(rowNo, style[0] === 'i' ? style : 'n');\r\n    return row;\r\n  }\r\n\r\n  addRows(value, style = 'n') {\r\n    const rows = [];\r\n    value.forEach(row => {\r\n      rows.push(this.addRow(row, style));\r\n    });\r\n    return rows;\r\n  }\r\n\r\n  insertRow(pos, value, style = 'n') {\r\n    this.spliceRows(pos, 0, value);\r\n    this._setStyleOption(pos, style);\r\n    return this.getRow(pos);\r\n  }\r\n\r\n  insertRows(pos, values, style = 'n') {\r\n    this.spliceRows(pos, 0, ...values);\r\n    if (style !== 'n') {\r\n      // copy over the styles\r\n      for (let i = 0; i < values.length; i++) {\r\n        if (style[0] === 'o' && this.findRow(values.length + pos + i) !== undefined) {\r\n          this._copyStyle(values.length + pos + i, pos + i, style[1] === '+');\r\n        } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\r\n          this._copyStyle(pos - 1, pos + i, style[1] === '+');\r\n        }\r\n      }\r\n    }\r\n    return this.getRows(pos, values.length);\r\n  }\r\n\r\n  // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')\r\n  _setStyleOption(pos, style = 'n') {\r\n    if (style[0] === 'o' && this.findRow(pos + 1) !== undefined) {\r\n      this._copyStyle(pos + 1, pos, style[1] === '+');\r\n    } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\r\n      this._copyStyle(pos - 1, pos, style[1] === '+');\r\n    }\r\n  }\r\n\r\n  _copyStyle(src, dest, styleEmpty = false) {\r\n    const rSrc = this.getRow(src);\r\n    const rDst = this.getRow(dest);\r\n    rDst.style = Object.freeze({...rSrc.style});\r\n    // eslint-disable-next-line no-loop-func\r\n    rSrc.eachCell({includeEmpty: styleEmpty}, (cell, colNumber) => {\r\n      rDst.getCell(colNumber).style = Object.freeze({...cell.style});\r\n    });\r\n    rDst.height = rSrc.height;\r\n  }\r\n\r\n  duplicateRow(rowNum, count, insert = false) {\r\n    // create count duplicates of rowNum\r\n    // either inserting new or overwriting existing rows\r\n\r\n    const rSrc = this._rows[rowNum - 1];\r\n    const inserts = new Array(count).fill(rSrc.values);\r\n    this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);\r\n\r\n    // now copy styles...\r\n    for (let i = 0; i < count; i++) {\r\n      const rDst = this._rows[rowNum + i];\r\n      rDst.style = rSrc.style;\r\n      rDst.height = rSrc.height;\r\n      // eslint-disable-next-line no-loop-func\r\n      rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n        rDst.getCell(colNumber).style = cell.style;\r\n      });\r\n    }\r\n  }\r\n\r\n  spliceRows(start, count, ...inserts) {\r\n    // same problem as row.splice, except worse.\r\n    const nKeep = start + count;\r\n    const nInserts = inserts.length;\r\n    const nExpand = nInserts - count;\r\n    const nEnd = this._rows.length;\r\n    let i;\r\n    let rSrc;\r\n    if (nExpand < 0) {\r\n      // remove rows\r\n      for (i = nKeep; i <= nEnd; i++) {\r\n        rSrc = this._rows[i - 1];\r\n        if (rSrc) {\r\n          const rDst = this.getRow(i + nExpand);\r\n          rDst.values = rSrc.values;\r\n          rDst.style = rSrc.style;\r\n          rDst.height = rSrc.height;\r\n          // eslint-disable-next-line no-loop-func\r\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n            rDst.getCell(colNumber).style = cell.style;\r\n          });\r\n          this._rows[i - 1] = undefined;\r\n        } else {\r\n          this._rows[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    } else if (nExpand > 0) {\r\n      // insert new cells\r\n      for (i = nEnd; i >= nKeep; i--) {\r\n        rSrc = this._rows[i - 1];\r\n        if (rSrc) {\r\n          const rDst = this.getRow(i + nExpand);\r\n          rDst.values = rSrc.values;\r\n          rDst.style = rSrc.style;\r\n          rDst.height = rSrc.height;\r\n          // eslint-disable-next-line no-loop-func\r\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n            rDst.getCell(colNumber).style = cell.style;\r\n\r\n            // remerge cells accounting for insert offset\r\n            if (cell._value.constructor.name === 'MergeValue') {\r\n              const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);\r\n              const prevMaster = cell._value._master;\r\n              const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);\r\n              cellToBeMerged.merge(newMaster);\r\n            }\r\n          });\r\n        } else {\r\n          this._rows[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    // now copy over the new values\r\n    for (i = 0; i < nInserts; i++) {\r\n      const rDst = this.getRow(start + i);\r\n      rDst.style = {};\r\n      rDst.values = inserts[i];\r\n    }\r\n\r\n    // account for defined names\r\n    this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);\r\n  }\r\n\r\n  // iterate over every row in the worksheet, including maybe empty rows\r\n  eachRow(options, iteratee) {\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = undefined;\r\n    }\r\n    if (options && options.includeEmpty) {\r\n      const n = this._rows.length;\r\n      for (let i = 1; i <= n; i++) {\r\n        iteratee(this.getRow(i), i);\r\n      }\r\n    } else {\r\n      this._rows.forEach(row => {\r\n        if (row && row.hasValues) {\r\n          iteratee(row, row.number);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // return all rows as sparse array\r\n  getSheetValues() {\r\n    const rows = [];\r\n    this._rows.forEach(row => {\r\n      if (row) {\r\n        rows[row.number] = row.values;\r\n      }\r\n    });\r\n    return rows;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Cells\r\n\r\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\r\n  findCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this._rows[address.row - 1];\r\n    return row ? row.findCell(address.col) : undefined;\r\n  }\r\n\r\n  // return the cell at [r,c] or address given by r. If not found, create a new one.\r\n  getCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this.getRow(address.row);\r\n    return row.getCellEx(address);\r\n  }\r\n\r\n  // =========================================================================\r\n  // Merge\r\n\r\n  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell\r\n  mergeCells(...cells) {\r\n    const dimensions = new Range(cells);\r\n    this._mergeCellsInternal(dimensions);\r\n  }\r\n\r\n  mergeCellsWithoutStyle(...cells) {\r\n    const dimensions = new Range(cells);\r\n    this._mergeCellsInternal(dimensions, true);\r\n  }\r\n\r\n  _mergeCellsInternal(dimensions, ignoreStyle) {\r\n    // check cells aren't already merged\r\n    _.each(this._merges, merge => {\r\n      if (merge.intersects(dimensions)) {\r\n        throw new Error('Cannot merge already merged cells');\r\n      }\r\n    });\r\n\r\n    // apply merge\r\n    const master = this.getCell(dimensions.top, dimensions.left);\r\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n        // merge all but the master cell\r\n        if (i > dimensions.top || j > dimensions.left) {\r\n          this.getCell(i, j).merge(master, ignoreStyle);\r\n        }\r\n      }\r\n    }\r\n\r\n    // index merge\r\n    this._merges[master.address] = dimensions;\r\n  }\r\n\r\n  _unMergeMaster(master) {\r\n    // master is always top left of a rectangle\r\n    const merge = this._merges[master.address];\r\n    if (merge) {\r\n      for (let i = merge.top; i <= merge.bottom; i++) {\r\n        for (let j = merge.left; j <= merge.right; j++) {\r\n          this.getCell(i, j).unmerge();\r\n        }\r\n      }\r\n      delete this._merges[master.address];\r\n    }\r\n  }\r\n\r\n  get hasMerges() {\r\n    // return true if this._merges has a merge object\r\n    return _.some(this._merges, Boolean);\r\n  }\r\n\r\n  // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,\r\n  // un-merge the group. Note this function can affect multiple merges and merge-blocks are\r\n  // atomic - either they're all merged or all un-merged.\r\n  unMergeCells(...cells) {\r\n    const dimensions = new Range(cells);\r\n\r\n    // find any cells in that range and unmerge them\r\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n        const cell = this.findCell(i, j);\r\n        if (cell) {\r\n          if (cell.type === Enums.ValueType.Merge) {\r\n            // this cell merges to another master\r\n            this._unMergeMaster(cell.master);\r\n          } else if (this._merges[cell.address]) {\r\n            // this cell is a master\r\n            this._unMergeMaster(cell);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Shared/Array Formula\r\n  fillFormula(range, formula, results, shareType = 'shared') {\r\n    // Define formula for top-left cell and share to rest\r\n    const decoded = colCache.decode(range);\r\n    const {top, left, bottom, right} = decoded;\r\n    const width = right - left + 1;\r\n    const masterAddress = colCache.encodeAddress(top, left);\r\n    const isShared = shareType === 'shared';\r\n\r\n    // work out result accessor\r\n    let getResult;\r\n    if (typeof results === 'function') {\r\n      getResult = results;\r\n    } else if (Array.isArray(results)) {\r\n      if (Array.isArray(results[0])) {\r\n        getResult = (row, col) => results[row - top][col - left];\r\n      } else {\r\n        // eslint-disable-next-line no-mixed-operators\r\n        getResult = (row, col) => results[(row - top) * width + (col - left)];\r\n      }\r\n    } else {\r\n      getResult = () => undefined;\r\n    }\r\n    let first = true;\r\n    for (let r = top; r <= bottom; r++) {\r\n      for (let c = left; c <= right; c++) {\r\n        if (first) {\r\n          this.getCell(r, c).value = {\r\n            shareType,\r\n            formula,\r\n            ref: range,\r\n            result: getResult(r, c),\r\n          };\r\n          first = false;\r\n        } else {\r\n          this.getCell(r, c).value = isShared\r\n            ? {\r\n                sharedFormula: masterAddress,\r\n                result: getResult(r, c),\r\n              }\r\n            : getResult(r, c);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // =========================================================================\r\n  // Images\r\n  addImage(imageId, range) {\r\n    const model = {\r\n      type: 'image',\r\n      imageId,\r\n      range,\r\n    };\r\n    this._media.push(new Image(this, model));\r\n  }\r\n\r\n  getImages() {\r\n    return this._media.filter(m => m.type === 'image');\r\n  }\r\n\r\n  addBackgroundImage(imageId) {\r\n    const model = {\r\n      type: 'background',\r\n      imageId,\r\n    };\r\n    this._media.push(new Image(this, model));\r\n  }\r\n\r\n  getBackgroundImageId() {\r\n    const image = this._media.find(m => m.type === 'background');\r\n    return image && image.imageId;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Worksheet Protection\r\n  protect(password, options) {\r\n    // TODO: make this function truly async\r\n    // perhaps marshal to worker thread or something\r\n    return new Promise(resolve => {\r\n      this.sheetProtection = {\r\n        sheet: true,\r\n      };\r\n      if (options && 'spinCount' in options) {\r\n        // force spinCount to be integer >= 0\r\n        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;\r\n      }\r\n      if (password) {\r\n        this.sheetProtection.algorithmName = 'SHA-512';\r\n        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\r\n        this.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\r\n        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(\r\n          password,\r\n          'SHA512',\r\n          this.sheetProtection.saltValue,\r\n          this.sheetProtection.spinCount\r\n        );\r\n      }\r\n      if (options) {\r\n        this.sheetProtection = Object.assign(this.sheetProtection, options);\r\n        if (!password && 'spinCount' in options) {\r\n          delete this.sheetProtection.spinCount;\r\n        }\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  unprotect() {\r\n    this.sheetProtection = null;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Tables\r\n  addTable(model) {\r\n    const table = new Table(this, model);\r\n    this.tables[model.name] = table;\r\n    return table;\r\n  }\r\n\r\n  getTable(name) {\r\n    return this.tables[name];\r\n  }\r\n\r\n  removeTable(name) {\r\n    delete this.tables[name];\r\n  }\r\n\r\n  getTables() {\r\n    return Object.values(this.tables);\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Conditional Formatting\r\n  addConditionalFormatting(cf) {\r\n    this.conditionalFormattings.push(cf);\r\n  }\r\n\r\n  removeConditionalFormatting(filter) {\r\n    if (typeof filter === 'number') {\r\n      this.conditionalFormattings.splice(filter, 1);\r\n    } else if (filter instanceof Function) {\r\n      this.conditionalFormattings = this.conditionalFormattings.filter(filter);\r\n    } else {\r\n      this.conditionalFormattings = [];\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Deprecated\r\n  get tabColor() {\r\n    // eslint-disable-next-line no-console\r\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\r\n    return this.properties.tabColor;\r\n  }\r\n\r\n  set tabColor(value) {\r\n    // eslint-disable-next-line no-console\r\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\r\n    this.properties.tabColor = value;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Model\r\n\r\n  get model() {\r\n    const model = {\r\n      id: this.id,\r\n      name: this.name,\r\n      dataValidations: this.dataValidations.model,\r\n      properties: this.properties,\r\n      state: this.state,\r\n      pageSetup: this.pageSetup,\r\n      headerFooter: this.headerFooter,\r\n      rowBreaks: this.rowBreaks,\r\n      views: this.views,\r\n      autoFilter: this.autoFilter,\r\n      media: this._media.map(medium => medium.model),\r\n      sheetProtection: this.sheetProtection,\r\n      tables: Object.values(this.tables).map(table => table.model),\r\n      conditionalFormattings: this.conditionalFormattings,\r\n    };\r\n\r\n    // =================================================\r\n    // columns\r\n    model.cols = Column.toModel(this.columns);\r\n\r\n    // ==========================================================\r\n    // Rows\r\n    const rows = (model.rows = []);\r\n    const dimensions = (model.dimensions = new Range());\r\n    this._rows.forEach(row => {\r\n      const rowModel = row && row.model;\r\n      if (rowModel) {\r\n        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);\r\n        rows.push(rowModel);\r\n      }\r\n    });\r\n\r\n    // ==========================================================\r\n    // Merges\r\n    model.merges = [];\r\n    _.each(this._merges, merge => {\r\n      model.merges.push(merge.range);\r\n    });\r\n\r\n    return model;\r\n  }\r\n\r\n  _parseRows(model) {\r\n    this._rows = [];\r\n    model.rows.forEach(rowModel => {\r\n      const row = new Row(this, rowModel.number);\r\n      this._rows[row.number - 1] = row;\r\n      row.model = rowModel;\r\n    });\r\n  }\r\n\r\n  _parseMergeCells(model) {\r\n    _.each(model.mergeCells, merge => {\r\n      // Do not merge styles when importing an Excel file\r\n      // since each cell may have different styles intentionally.\r\n      this.mergeCellsWithoutStyle(merge);\r\n    });\r\n  }\r\n\r\n  set model(value) {\r\n    this.name = value.name;\r\n    this._columns = Column.fromModel(this, value.cols);\r\n    this._parseRows(value);\r\n\r\n    this._parseMergeCells(value);\r\n    this.dataValidations = new DataValidations(value.dataValidations);\r\n    this.properties = value.properties;\r\n    this.pageSetup = value.pageSetup;\r\n    this.headerFooter = value.headerFooter;\r\n    this.views = value.views;\r\n    this.autoFilter = value.autoFilter;\r\n    this._media = value.media.map(medium => new Image(this, medium));\r\n    this.sheetProtection = value.sheetProtection;\r\n    this.tables = value.tables.reduce((tables, table) => {\r\n      const t = new Table();\r\n      t.model = table;\r\n      tables[table.name] = t;\r\n      return tables;\r\n    }, {});\r\n    this.conditionalFormattings = value.conditionalFormattings;\r\n  }\r\n}\r\n\r\nmodule.exports = Worksheet;\r\n","const {toString} = Object.prototype;\r\nconst escapeHtmlRegex = /[\"&<>]/;\r\nconst _ = {\r\n  each: function each(obj, cb) {\r\n    if (obj) {\r\n      if (Array.isArray(obj)) {\r\n        obj.forEach(cb);\r\n      } else {\r\n        Object.keys(obj).forEach(key => {\r\n          cb(obj[key], key);\r\n        });\r\n      }\r\n    }\r\n  },\r\n\r\n  some: function some(obj, cb) {\r\n    if (obj) {\r\n      if (Array.isArray(obj)) {\r\n        return obj.some(cb);\r\n      }\r\n      return Object.keys(obj).some(key => cb(obj[key], key));\r\n    }\r\n    return false;\r\n  },\r\n\r\n  every: function every(obj, cb) {\r\n    if (obj) {\r\n      if (Array.isArray(obj)) {\r\n        return obj.every(cb);\r\n      }\r\n      return Object.keys(obj).every(key => cb(obj[key], key));\r\n    }\r\n    return true;\r\n  },\r\n\r\n  map: function map(obj, cb) {\r\n    if (obj) {\r\n      if (Array.isArray(obj)) {\r\n        return obj.map(cb);\r\n      }\r\n      return Object.keys(obj).map(key => cb(obj[key], key));\r\n    }\r\n    return [];\r\n  },\r\n\r\n  keyBy(a, p) {\r\n    return a.reduce((o, v) => {\r\n      o[v[p]] = v;\r\n      return o;\r\n    }, {});\r\n  },\r\n\r\n  isEqual: function isEqual(a, b) {\r\n    const aType = typeof a;\r\n    const bType = typeof b;\r\n    const aArray = Array.isArray(a);\r\n    const bArray = Array.isArray(b);\r\n\r\n    if (aType !== bType) {\r\n      return false;\r\n    }\r\n    switch (typeof a) {\r\n      case 'object':\r\n        if (aArray || bArray) {\r\n          if (aArray && bArray) {\r\n            return (\r\n              a.length === b.length &&\r\n              a.every((aValue, index) => {\r\n                const bValue = b[index];\r\n                return _.isEqual(aValue, bValue);\r\n              })\r\n            );\r\n          }\r\n          return false;\r\n        }\r\n        return _.every(a, (aValue, key) => {\r\n          const bValue = b[key];\r\n          return _.isEqual(aValue, bValue);\r\n        });\r\n\r\n      default:\r\n        return a === b;\r\n    }\r\n  },\r\n\r\n  escapeHtml(html) {\r\n    const regexResult = escapeHtmlRegex.exec(html);\r\n    if (!regexResult) return html;\r\n\r\n    let result = '';\r\n    let escape = '';\r\n    let lastIndex = 0;\r\n    let i = regexResult.index;\r\n    for (; i < html.length; i++) {\r\n      switch (html.charAt(i)) {\r\n        case '\"':\r\n          escape = '&quot;';\r\n          break;\r\n        case '&':\r\n          escape = '&amp;';\r\n          break;\r\n        case '\\'':\r\n          escape = '&apos;';\r\n          break;\r\n        case '<':\r\n          escape = '&lt;';\r\n          break;\r\n        case '>':\r\n          escape = '&gt;';\r\n          break;\r\n        default:\r\n          continue;\r\n      }\r\n      if (lastIndex !== i) result += html.substring(lastIndex, i);\r\n      lastIndex = i + 1;\r\n      result += escape;\r\n    }\r\n    if (lastIndex !== i) return result + html.substring(lastIndex, i);\r\n    return result;\r\n  },\r\n\r\n  strcmp(a, b) {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n  },\r\n\r\n  isUndefined(val) {\r\n    return toString.call(val) === '[object Undefined]';\r\n  },\r\n\r\n  isObject(val) {\r\n    return toString.call(val) === '[object Object]';\r\n  },\r\n\r\n  deepMerge() {\r\n    const target = arguments[0] || {};\r\n    const {length} = arguments;\r\n    // eslint-disable-next-line one-var\r\n    let src, clone, copyIsArray;\r\n\r\n    function assignValue(val, key) {\r\n      src = target[key];\r\n      copyIsArray = Array.isArray(val);\r\n      if (_.isObject(val) || copyIsArray) {\r\n        if (copyIsArray) {\r\n          copyIsArray = false;\r\n          clone = src && Array.isArray(src) ? src : [];\r\n        } else {\r\n          clone = src && _.isObject(src) ? src : {};\r\n        }\r\n        target[key] = _.deepMerge(clone, val);\r\n      } else if (!_.isUndefined(val)) {\r\n        target[key] = val;\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      _.each(arguments[i], assignValue);\r\n    }\r\n    return target;\r\n  },\r\n};\r\n\r\nmodule.exports = _;\r\n","const addressRegex = /^[A-Z]+\\d+$/;\r\n// =========================================================================\r\n// Column Letter to Number conversion\r\nconst colCache = {\r\n  _dictionary: [\r\n    'A',\r\n    'B',\r\n    'C',\r\n    'D',\r\n    'E',\r\n    'F',\r\n    'G',\r\n    'H',\r\n    'I',\r\n    'J',\r\n    'K',\r\n    'L',\r\n    'M',\r\n    'N',\r\n    'O',\r\n    'P',\r\n    'Q',\r\n    'R',\r\n    'S',\r\n    'T',\r\n    'U',\r\n    'V',\r\n    'W',\r\n    'X',\r\n    'Y',\r\n    'Z',\r\n  ],\r\n  _l2nFill: 0,\r\n  _l2n: {},\r\n  _n2l: [],\r\n  _level(n) {\r\n    if (n <= 26) {\r\n      return 1;\r\n    }\r\n    if (n <= 26 * 26) {\r\n      return 2;\r\n    }\r\n    return 3;\r\n  },\r\n  _fill(level) {\r\n    let c;\r\n    let v;\r\n    let l1;\r\n    let l2;\r\n    let l3;\r\n    let n = 1;\r\n    if (level >= 4) {\r\n      throw new Error('Out of bounds. Excel supports columns from 1 to 16384');\r\n    }\r\n    if (this._l2nFill < 1 && level >= 1) {\r\n      while (n <= 26) {\r\n        c = this._dictionary[n - 1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 1;\r\n    }\r\n    if (this._l2nFill < 2 && level >= 2) {\r\n      n = 27;\r\n      while (n <= 26 + (26 * 26)) {\r\n        v = n - (26 + 1);\r\n        l1 = v % 26;\r\n        l2 = Math.floor(v / 26);\r\n        c = this._dictionary[l2] + this._dictionary[l1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 2;\r\n    }\r\n    if (this._l2nFill < 3 && level >= 3) {\r\n      n = 26 + (26 * 26) + 1;\r\n      while (n <= 16384) {\r\n        v = n - ((26 * 26) + 26 + 1);\r\n        l1 = v % 26;\r\n        l2 = Math.floor(v / 26) % 26;\r\n        l3 = Math.floor(v / (26 * 26));\r\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 3;\r\n    }\r\n  },\r\n  l2n(l) {\r\n    if (!this._l2n[l]) {\r\n      this._fill(l.length);\r\n    }\r\n    if (!this._l2n[l]) {\r\n      throw new Error(`Out of bounds. Invalid column letter: ${l}`);\r\n    }\r\n    return this._l2n[l];\r\n  },\r\n  n2l(n) {\r\n    if (n < 1 || n > 16384) {\r\n      throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);\r\n    }\r\n    if (!this._n2l[n]) {\r\n      this._fill(this._level(n));\r\n    }\r\n    return this._n2l[n];\r\n  },\r\n\r\n  // =========================================================================\r\n  // Address processing\r\n  _hash: {},\r\n\r\n  // check if value looks like an address\r\n  validateAddress(value) {\r\n    if (!addressRegex.test(value)) {\r\n      throw new Error(`Invalid Address: ${value}`);\r\n    }\r\n    return true;\r\n  },\r\n\r\n  // convert address string into structure\r\n  decodeAddress(value) {\r\n    const addr = value.length < 5 && this._hash[value];\r\n    if (addr) {\r\n      return addr;\r\n    }\r\n    let hasCol = false;\r\n    let col = '';\r\n    let colNumber = 0;\r\n    let hasRow = false;\r\n    let row = '';\r\n    let rowNumber = 0;\r\n    for (let i = 0, char; i < value.length; i++) {\r\n      char = value.charCodeAt(i);\r\n      // col should before row\r\n      if (!hasRow && char >= 65 && char <= 90) {\r\n        // 65 = 'A'.charCodeAt(0)\r\n        // 90 = 'Z'.charCodeAt(0)\r\n        hasCol = true;\r\n        col += value[i];\r\n        // colNumber starts from 1\r\n        colNumber = (colNumber * 26) + char - 64;\r\n      } else if (char >= 48 && char <= 57) {\r\n        // 48 = '0'.charCodeAt(0)\r\n        // 57 = '9'.charCodeAt(0)\r\n        hasRow = true;\r\n        row += value[i];\r\n        // rowNumber starts from 0\r\n        rowNumber = (rowNumber * 10) + char - 48;\r\n      } else if (hasRow && hasCol && char !== 36) {\r\n        // 36 = '$'.charCodeAt(0)\r\n        break;\r\n      }\r\n    }\r\n    if (!hasCol) {\r\n      colNumber = undefined;\r\n    } else if (colNumber > 16384) {\r\n      throw new Error(`Out of bounds. Invalid column letter: ${col}`);\r\n    }\r\n    if (!hasRow) {\r\n      rowNumber = undefined;\r\n    }\r\n\r\n    // in case $row$col\r\n    value = col + row;\r\n\r\n    const address = {\r\n      address: value,\r\n      col: colNumber,\r\n      row: rowNumber,\r\n      $col$row: `$${col}$${row}`,\r\n    };\r\n\r\n    // mem fix - cache only the tl 100x100 square\r\n    if (colNumber <= 100 && rowNumber <= 100) {\r\n      this._hash[value] = address;\r\n      this._hash[address.$col$row] = address;\r\n    }\r\n\r\n    return address;\r\n  },\r\n\r\n  // convert r,c into structure (if only 1 arg, assume r is address string)\r\n  getAddress(r, c) {\r\n    if (c) {\r\n      const address = this.n2l(c) + r;\r\n      return this.decodeAddress(address);\r\n    }\r\n    return this.decodeAddress(r);\r\n  },\r\n\r\n  // convert [address], [tl:br] into address structures\r\n  decode(value) {\r\n    const parts = value.split(':');\r\n    if (parts.length === 2) {\r\n      const tl = this.decodeAddress(parts[0]);\r\n      const br = this.decodeAddress(parts[1]);\r\n      const result = {\r\n        top: Math.min(tl.row, br.row),\r\n        left: Math.min(tl.col, br.col),\r\n        bottom: Math.max(tl.row, br.row),\r\n        right: Math.max(tl.col, br.col),\r\n      };\r\n      // reconstruct tl, br and dimensions\r\n      result.tl = this.n2l(result.left) + result.top;\r\n      result.br = this.n2l(result.right) + result.bottom;\r\n      result.dimensions = `${result.tl}:${result.br}`;\r\n      return result;\r\n    }\r\n    return this.decodeAddress(value);\r\n  },\r\n\r\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\r\n  decodeEx(value) {\r\n    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\r\n\r\n    const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\r\n    const reference = groups[3]; // Remaining address\r\n\r\n    const parts = reference.split(':');\r\n    if (parts.length > 1) {\r\n      let tl = this.decodeAddress(parts[0]);\r\n      let br = this.decodeAddress(parts[1]);\r\n      const top = Math.min(tl.row, br.row);\r\n      const left = Math.min(tl.col, br.col);\r\n      const bottom = Math.max(tl.row, br.row);\r\n      const right = Math.max(tl.col, br.col);\r\n\r\n      tl = this.n2l(left) + top;\r\n      br = this.n2l(right) + bottom;\r\n\r\n      return {\r\n        top,\r\n        left,\r\n        bottom,\r\n        right,\r\n        sheetName,\r\n        tl: {address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName},\r\n        br: {\r\n          address: br,\r\n          col: right,\r\n          row: bottom,\r\n          $col$row: `$${this.n2l(right)}$${bottom}`,\r\n          sheetName,\r\n        },\r\n        dimensions: `${tl}:${br}`,\r\n      };\r\n    }\r\n    if (reference.startsWith('#')) {\r\n      return sheetName ? {sheetName, error: reference} : {error: reference};\r\n    }\r\n\r\n    const address = this.decodeAddress(reference);\r\n    return sheetName ? {sheetName, ...address} : address;\r\n  },\r\n\r\n  // convert row,col into address string\r\n  encodeAddress(row, col) {\r\n    return colCache.n2l(col) + row;\r\n  },\r\n\r\n  // convert row,col into string address or t,l,b,r into range\r\n  encode() {\r\n    switch (arguments.length) {\r\n      case 2:\r\n        return colCache.encodeAddress(arguments[0], arguments[1]);\r\n      case 4:\r\n        return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(\r\n          arguments[2],\r\n          arguments[3]\r\n        )}`;\r\n      default:\r\n        throw new Error('Can only encode with 2 or 4 arguments');\r\n    }\r\n  },\r\n\r\n  // return true if address is contained within range\r\n  inRange(range, address) {\r\n    const [left, top, , right, bottom] = range;\r\n    const [col, row] = address;\r\n    return col >= left && col <= right && row >= top && row <= bottom;\r\n  },\r\n};\r\n\r\nmodule.exports = colCache;\r\n","const colCache = require('../utils/col-cache');\r\n\r\n// used by worksheet to calculate sheet dimensions\r\nclass Range {\r\n  constructor() {\r\n    this.decode(arguments);\r\n  }\r\n\r\n  setTLBR(t, l, b, r, s) {\r\n    if (arguments.length < 4) {\r\n      // setTLBR(tl, br, s)\r\n      const tl = colCache.decodeAddress(t);\r\n      const br = colCache.decodeAddress(l);\r\n      this.model = {\r\n        top: Math.min(tl.row, br.row),\r\n        left: Math.min(tl.col, br.col),\r\n        bottom: Math.max(tl.row, br.row),\r\n        right: Math.max(tl.col, br.col),\r\n        sheetName: b,\r\n      };\r\n\r\n      this.setTLBR(tl.row, tl.col, br.row, br.col, s);\r\n    } else {\r\n      // setTLBR(t, l, b, r, s)\r\n      this.model = {\r\n        top: Math.min(t, b),\r\n        left: Math.min(l, r),\r\n        bottom: Math.max(t, b),\r\n        right: Math.max(l, r),\r\n        sheetName: s,\r\n      };\r\n    }\r\n  }\r\n\r\n  decode(argv) {\r\n    switch (argv.length) {\r\n      case 5: // [t,l,b,r,s]\r\n        this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);\r\n        break;\r\n      case 4: // [t,l,b,r]\r\n        this.setTLBR(argv[0], argv[1], argv[2], argv[3]);\r\n        break;\r\n\r\n      case 3: // [tl,br,s]\r\n        this.setTLBR(argv[0], argv[1], argv[2]);\r\n        break;\r\n      case 2: // [tl,br]\r\n        this.setTLBR(argv[0], argv[1]);\r\n        break;\r\n\r\n      case 1: {\r\n        const value = argv[0];\r\n        if (value instanceof Range) {\r\n          // copy constructor\r\n          this.model = {\r\n            top: value.model.top,\r\n            left: value.model.left,\r\n            bottom: value.model.bottom,\r\n            right: value.model.right,\r\n            sheetName: value.sheetName,\r\n          };\r\n        } else if (value instanceof Array) {\r\n          // an arguments array\r\n          this.decode(value);\r\n        } else if (value.top && value.left && value.bottom && value.right) {\r\n          // a model\r\n          this.model = {\r\n            top: value.top,\r\n            left: value.left,\r\n            bottom: value.bottom,\r\n            right: value.right,\r\n            sheetName: value.sheetName,\r\n          };\r\n        } else {\r\n          // [sheetName!]tl:br\r\n          const tlbr = colCache.decodeEx(value);\r\n          if (tlbr.top) {\r\n            this.model = {\r\n              top: tlbr.top,\r\n              left: tlbr.left,\r\n              bottom: tlbr.bottom,\r\n              right: tlbr.right,\r\n              sheetName: tlbr.sheetName,\r\n            };\r\n          } else {\r\n            this.model = {\r\n              top: tlbr.row,\r\n              left: tlbr.col,\r\n              bottom: tlbr.row,\r\n              right: tlbr.col,\r\n              sheetName: tlbr.sheetName,\r\n            };\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 0:\r\n        this.model = {\r\n          top: 0,\r\n          left: 0,\r\n          bottom: 0,\r\n          right: 0,\r\n        };\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);\r\n    }\r\n  }\r\n\r\n  get top() {\r\n    return this.model.top || 1;\r\n  }\r\n\r\n  set top(value) {\r\n    this.model.top = value;\r\n  }\r\n\r\n  get left() {\r\n    return this.model.left || 1;\r\n  }\r\n\r\n  set left(value) {\r\n    this.model.left = value;\r\n  }\r\n\r\n  get bottom() {\r\n    return this.model.bottom || 1;\r\n  }\r\n\r\n  set bottom(value) {\r\n    this.model.bottom = value;\r\n  }\r\n\r\n  get right() {\r\n    return this.model.right || 1;\r\n  }\r\n\r\n  set right(value) {\r\n    this.model.right = value;\r\n  }\r\n\r\n  get sheetName() {\r\n    return this.model.sheetName;\r\n  }\r\n\r\n  set sheetName(value) {\r\n    this.model.sheetName = value;\r\n  }\r\n\r\n  get _serialisedSheetName() {\r\n    const {sheetName} = this.model;\r\n    if (sheetName) {\r\n      if (/^[a-zA-Z0-9]*$/.test(sheetName)) {\r\n        return `${sheetName}!`;\r\n      }\r\n      return `'${sheetName}'!`;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  expand(top, left, bottom, right) {\r\n    if (!this.model.top || top < this.top) this.top = top;\r\n    if (!this.model.left || left < this.left) this.left = left;\r\n    if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;\r\n    if (!this.model.right || right > this.right) this.right = right;\r\n  }\r\n\r\n  expandRow(row) {\r\n    if (row) {\r\n      const {dimensions, number} = row;\r\n      if (dimensions) {\r\n        this.expand(number, dimensions.min, number, dimensions.max);\r\n      }\r\n    }\r\n  }\r\n\r\n  expandToAddress(addressStr) {\r\n    const address = colCache.decodeEx(addressStr);\r\n    this.expand(address.row, address.col, address.row, address.col);\r\n  }\r\n\r\n  get tl() {\r\n    return colCache.n2l(this.left) + this.top;\r\n  }\r\n\r\n  get $t$l() {\r\n    return `$${colCache.n2l(this.left)}$${this.top}`;\r\n  }\r\n\r\n  get br() {\r\n    return colCache.n2l(this.right) + this.bottom;\r\n  }\r\n\r\n  get $b$r() {\r\n    return `$${colCache.n2l(this.right)}$${this.bottom}`;\r\n  }\r\n\r\n  get range() {\r\n    return `${this._serialisedSheetName + this.tl}:${this.br}`;\r\n  }\r\n\r\n  get $range() {\r\n    return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;\r\n  }\r\n\r\n  get shortRange() {\r\n    return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;\r\n  }\r\n\r\n  get $shortRange() {\r\n    return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;\r\n  }\r\n\r\n  get count() {\r\n    return (1 + this.bottom - this.top) * (1 + this.right - this.left);\r\n  }\r\n\r\n  toString() {\r\n    return this.range;\r\n  }\r\n\r\n  intersects(other) {\r\n    if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;\r\n    if (other.bottom < this.top) return false;\r\n    if (other.top > this.bottom) return false;\r\n    if (other.right < this.left) return false;\r\n    if (other.left > this.right) return false;\r\n    return true;\r\n  }\r\n\r\n  contains(addressStr) {\r\n    const address = colCache.decodeEx(addressStr);\r\n    return this.containsEx(address);\r\n  }\r\n\r\n  containsEx(address) {\r\n    if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;\r\n    return (\r\n      address.row >= this.top &&\r\n      address.row <= this.bottom &&\r\n      address.col >= this.left &&\r\n      address.col <= this.right\r\n    );\r\n  }\r\n\r\n  forEachAddress(cb) {\r\n    for (let col = this.left; col <= this.right; col++) {\r\n      for (let row = this.top; row <= this.bottom; row++) {\r\n        cb(colCache.encodeAddress(row, col), row, col);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Range;\r\n","\r\n\r\nconst _ = require('../utils/under-dash');\r\n\r\nconst Enums = require('./enums');\r\nconst colCache = require('../utils/col-cache');\r\nconst Cell = require('./cell');\r\n\r\nclass Row {\r\n  constructor(worksheet, number) {\r\n    this._worksheet = worksheet;\r\n    this._number = number;\r\n    this._cells = [];\r\n    this.style = {};\r\n    this.outlineLevel = 0;\r\n  }\r\n\r\n  // return the row number\r\n  get number() {\r\n    return this._number;\r\n  }\r\n\r\n  get worksheet() {\r\n    return this._worksheet;\r\n  }\r\n\r\n  // Inform Streaming Writer that this row (and all rows before it) are complete\r\n  // and ready to write. Has no effect on Worksheet document\r\n  commit() {\r\n    this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle\r\n  }\r\n\r\n  // helps GC by breaking cyclic references\r\n  destroy() {\r\n    delete this._worksheet;\r\n    delete this._cells;\r\n    delete this.style;\r\n  }\r\n\r\n  findCell(colNumber) {\r\n    return this._cells[colNumber - 1];\r\n  }\r\n\r\n  // given {address, row, col}, find or create new cell\r\n  getCellEx(address) {\r\n    let cell = this._cells[address.col - 1];\r\n    if (!cell) {\r\n      const column = this._worksheet.getColumn(address.col);\r\n      cell = new Cell(this, column, address.address);\r\n      this._cells[address.col - 1] = cell;\r\n    }\r\n    return cell;\r\n  }\r\n\r\n  // get cell by key, letter or column number\r\n  getCell(col) {\r\n    if (typeof col === 'string') {\r\n      // is it a key?\r\n      const column = this._worksheet.getColumnKey(col);\r\n      if (column) {\r\n        col = column.number;\r\n      } else {\r\n        col = colCache.l2n(col);\r\n      }\r\n    }\r\n    return (\r\n      this._cells[col - 1] ||\r\n      this.getCellEx({\r\n        address: colCache.encodeAddress(this._number, col),\r\n        row: this._number,\r\n        col,\r\n      })\r\n    );\r\n  }\r\n\r\n  // remove cell(s) and shift all higher cells down by count\r\n  splice(start, count, ...inserts) {\r\n    const nKeep = start + count;\r\n    const nExpand = inserts.length - count;\r\n    const nEnd = this._cells.length;\r\n    let i;\r\n    let cSrc;\r\n    let cDst;\r\n\r\n    if (nExpand < 0) {\r\n      // remove cells\r\n      for (i = start + inserts.length; i <= nEnd; i++) {\r\n        cDst = this._cells[i - 1];\r\n        cSrc = this._cells[i - nExpand - 1];\r\n        if (cSrc) {\r\n          cDst = this.getCell(i);\r\n          cDst.value = cSrc.value;\r\n          cDst.style = cSrc.style;\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = cSrc._comment;\r\n        } else if (cDst) {\r\n          cDst.value = null;\r\n          cDst.style = {};\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = undefined;\r\n        }\r\n      }\r\n    } else if (nExpand > 0) {\r\n      // insert new cells\r\n      for (i = nEnd; i >= nKeep; i--) {\r\n        cSrc = this._cells[i - 1];\r\n        if (cSrc) {\r\n          cDst = this.getCell(i + nExpand);\r\n          cDst.value = cSrc.value;\r\n          cDst.style = cSrc.style;\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = cSrc._comment;\r\n        } else {\r\n          this._cells[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    // now add the new values\r\n    for (i = 0; i < inserts.length; i++) {\r\n      cDst = this.getCell(start + i);\r\n      cDst.value = inserts[i];\r\n      cDst.style = {};\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      cDst._comment = undefined;\r\n    }\r\n  }\r\n\r\n  // Iterate over all non-null cells in this row\r\n  eachCell(options, iteratee) {\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = null;\r\n    }\r\n    if (options && options.includeEmpty) {\r\n      const n = this._cells.length;\r\n      for (let i = 1; i <= n; i++) {\r\n        iteratee(this.getCell(i), i);\r\n      }\r\n    } else {\r\n      this._cells.forEach((cell, index) => {\r\n        if (cell && cell.type !== Enums.ValueType.Null) {\r\n          iteratee(cell, index + 1);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Page Breaks\r\n  addPageBreak(lft, rght) {\r\n    const ws = this._worksheet;\r\n    const left = Math.max(0, lft - 1) || 0;\r\n    const right = Math.max(0, rght - 1) || 16838;\r\n    const pb = {\r\n      id: this._number,\r\n      max: right,\r\n      man: 1,\r\n    };\r\n    if (left) pb.min = left;\r\n\r\n    ws.rowBreaks.push(pb);\r\n  }\r\n\r\n  // return a sparse array of cell values\r\n  get values() {\r\n    const values = [];\r\n    this._cells.forEach(cell => {\r\n      if (cell && cell.type !== Enums.ValueType.Null) {\r\n        values[cell.col] = cell.value;\r\n      }\r\n    });\r\n    return values;\r\n  }\r\n\r\n  // set the values by contiguous or sparse array, or by key'd object literal\r\n  set values(value) {\r\n    // this operation is not additive - any prior cells are removed\r\n    this._cells = [];\r\n    if (!value) {\r\n      // empty row\r\n    } else if (value instanceof Array) {\r\n      let offset = 0;\r\n      if (value.hasOwnProperty('0')) {\r\n        // contiguous array - start at column 1\r\n        offset = 1;\r\n      }\r\n      value.forEach((item, index) => {\r\n        if (item !== undefined) {\r\n          this.getCellEx({\r\n            address: colCache.encodeAddress(this._number, index + offset),\r\n            row: this._number,\r\n            col: index + offset,\r\n          }).value = item;\r\n        }\r\n      });\r\n    } else {\r\n      // assume object with column keys\r\n      this._worksheet.eachColumnKey((column, key) => {\r\n        if (value[key] !== undefined) {\r\n          this.getCellEx({\r\n            address: colCache.encodeAddress(this._number, column.number),\r\n            row: this._number,\r\n            col: column.number,\r\n          }).value = value[key];\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // returns true if the row includes at least one cell with a value\r\n  get hasValues() {\r\n    return _.some(this._cells, cell => cell && cell.type !== Enums.ValueType.Null);\r\n  }\r\n\r\n  get cellCount() {\r\n    return this._cells.length;\r\n  }\r\n\r\n  get actualCellCount() {\r\n    let count = 0;\r\n    this.eachCell(() => {\r\n      count++;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // get the min and max column number for the non-null cells in this row or null\r\n  get dimensions() {\r\n    let min = 0;\r\n    let max = 0;\r\n    this._cells.forEach(cell => {\r\n      if (cell && cell.type !== Enums.ValueType.Null) {\r\n        if (!min || min > cell.col) {\r\n          min = cell.col;\r\n        }\r\n        if (max < cell.col) {\r\n          max = cell.col;\r\n        }\r\n      }\r\n    });\r\n    return min > 0\r\n      ? {\r\n          min,\r\n          max,\r\n        }\r\n      : null;\r\n  }\r\n\r\n  // =========================================================================\r\n  // styles\r\n  _applyStyle(name, value) {\r\n    this.style[name] = value;\r\n    this._cells.forEach(cell => {\r\n      if (cell) {\r\n        cell[name] = value;\r\n      }\r\n    });\r\n    return value;\r\n  }\r\n\r\n  get numFmt() {\r\n    return this.style.numFmt;\r\n  }\r\n\r\n  set numFmt(value) {\r\n    this._applyStyle('numFmt', value);\r\n  }\r\n\r\n  get font() {\r\n    return this.style.font;\r\n  }\r\n\r\n  set font(value) {\r\n    this._applyStyle('font', value);\r\n  }\r\n\r\n  get alignment() {\r\n    return this.style.alignment;\r\n  }\r\n\r\n  set alignment(value) {\r\n    this._applyStyle('alignment', value);\r\n  }\r\n\r\n  get protection() {\r\n    return this.style.protection;\r\n  }\r\n\r\n  set protection(value) {\r\n    this._applyStyle('protection', value);\r\n  }\r\n\r\n  get border() {\r\n    return this.style.border;\r\n  }\r\n\r\n  set border(value) {\r\n    this._applyStyle('border', value);\r\n  }\r\n\r\n  get fill() {\r\n    return this.style.fill;\r\n  }\r\n\r\n  set fill(value) {\r\n    this._applyStyle('fill', value);\r\n  }\r\n\r\n  get hidden() {\r\n    return !!this._hidden;\r\n  }\r\n\r\n  set hidden(value) {\r\n    this._hidden = value;\r\n  }\r\n\r\n  get outlineLevel() {\r\n    return this._outlineLevel || 0;\r\n  }\r\n\r\n  set outlineLevel(value) {\r\n    this._outlineLevel = value;\r\n  }\r\n\r\n  get collapsed() {\r\n    return !!(\r\n      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow\r\n    );\r\n  }\r\n\r\n  // =========================================================================\r\n  get model() {\r\n    const cells = [];\r\n    let min = 0;\r\n    let max = 0;\r\n    this._cells.forEach(cell => {\r\n      if (cell) {\r\n        const cellModel = cell.model;\r\n        if (cellModel) {\r\n          if (!min || min > cell.col) {\r\n            min = cell.col;\r\n          }\r\n          if (max < cell.col) {\r\n            max = cell.col;\r\n          }\r\n          cells.push(cellModel);\r\n        }\r\n      }\r\n    });\r\n\r\n    return this.height || cells.length\r\n      ? {\r\n          cells,\r\n          number: this.number,\r\n          min,\r\n          max,\r\n          height: this.height,\r\n          style: this.style,\r\n          hidden: this.hidden,\r\n          outlineLevel: this.outlineLevel,\r\n          collapsed: this.collapsed,\r\n        }\r\n      : null;\r\n  }\r\n\r\n  set model(value) {\r\n    if (value.number !== this._number) {\r\n      throw new Error('Invalid row number in model');\r\n    }\r\n    this._cells = [];\r\n    let previousAddress;\r\n    value.cells.forEach(cellModel => {\r\n      switch (cellModel.type) {\r\n        case Cell.Types.Merge:\r\n          // special case - don't add this types\r\n          break;\r\n        default: {\r\n          let address;\r\n          if (cellModel.address) {\r\n            address = colCache.decodeAddress(cellModel.address);\r\n          } else if (previousAddress) {\r\n            // This is a <c> element without an r attribute\r\n            // Assume that it's the cell for the next column\r\n            const {row} = previousAddress;\r\n            const col = previousAddress.col + 1;\r\n            address = {\r\n              row,\r\n              col,\r\n              address: colCache.encodeAddress(row, col),\r\n              $col$row: `$${colCache.n2l(col)}$${row}`,\r\n            };\r\n          }\r\n          previousAddress = address;\r\n          const cell = this.getCellEx(address);\r\n          cell.model = cellModel;\r\n          break;\r\n        }\r\n      }\r\n    });\r\n\r\n    if (value.height) {\r\n      this.height = value.height;\r\n    } else {\r\n      delete this.height;\r\n    }\r\n\r\n    this.hidden = value.hidden;\r\n    this.outlineLevel = value.outlineLevel || 0;\r\n\r\n    this.style = (value.style && JSON.parse(JSON.stringify(value.style))) || {};\r\n  }\r\n}\r\n\r\nmodule.exports = Row;\r\n","\r\n\r\nmodule.exports = {\r\n  ValueType: {\r\n    Null: 0,\r\n    Merge: 1,\r\n    Number: 2,\r\n    String: 3,\r\n    Date: 4,\r\n    Hyperlink: 5,\r\n    Formula: 6,\r\n    SharedString: 7,\r\n    RichText: 8,\r\n    Boolean: 9,\r\n    Error: 10,\r\n  },\r\n  FormulaType: {\r\n    None: 0,\r\n    Master: 1,\r\n    Shared: 2,\r\n  },\r\n  RelationshipType: {\r\n    None: 0,\r\n    OfficeDocument: 1,\r\n    Worksheet: 2,\r\n    CalcChain: 3,\r\n    SharedStrings: 4,\r\n    Styles: 5,\r\n    Theme: 6,\r\n    Hyperlink: 7,\r\n  },\r\n  DocumentType: {\r\n    Xlsx: 1,\r\n  },\r\n  ReadingOrder: {\r\n    LeftToRight: 1,\r\n    RightToLeft: 2,\r\n  },\r\n  ErrorValue: {\r\n    NotApplicable: '#N/A',\r\n    Ref: '#REF!',\r\n    Name: '#NAME?',\r\n    DivZero: '#DIV/0!',\r\n    Null: '#NULL!',\r\n    Value: '#VALUE!',\r\n    Num: '#NUM!',\r\n  },\r\n};\r\n","/* eslint-disable max-classes-per-file */\r\nconst colCache = require('../utils/col-cache');\r\nconst _ = require('../utils/under-dash');\r\nconst Enums = require('./enums');\r\nconst {slideFormula} = require('../utils/shared-formula');\r\nconst Note = require('./note');\r\n// Cell requirements\r\n//  Operate inside a worksheet\r\n//  Store and retrieve a value with a range of types: text, number, date, hyperlink, reference, formula, etc.\r\n//  Manage/use and manipulate cell format either as local to cell or inherited from column or row.\r\n\r\nclass Cell {\r\n  constructor(row, column, address) {\r\n    if (!row || !column) {\r\n      throw new Error('A Cell needs a Row');\r\n    }\r\n\r\n    this._row = row;\r\n    this._column = column;\r\n\r\n    colCache.validateAddress(address);\r\n    this._address = address;\r\n\r\n    // TODO: lazy evaluation of this._value\r\n    this._value = Value.create(Cell.Types.Null, this);\r\n\r\n    this.style = this._mergeStyle(row.style, column.style, {});\r\n\r\n    this._mergeCount = 0;\r\n  }\r\n\r\n  get worksheet() {\r\n    return this._row.worksheet;\r\n  }\r\n\r\n  get workbook() {\r\n    return this._row.worksheet.workbook;\r\n  }\r\n\r\n  // help GC by removing cyclic (and other) references\r\n  destroy() {\r\n    delete this.style;\r\n    delete this._value;\r\n    delete this._row;\r\n    delete this._column;\r\n    delete this._address;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Styles stuff\r\n  get numFmt() {\r\n    return this.style.numFmt;\r\n  }\r\n\r\n  set numFmt(value) {\r\n    this.style.numFmt = value;\r\n  }\r\n\r\n  get font() {\r\n    return this.style.font;\r\n  }\r\n\r\n  set font(value) {\r\n    this.style.font = value;\r\n  }\r\n\r\n  get alignment() {\r\n    return this.style.alignment;\r\n  }\r\n\r\n  set alignment(value) {\r\n    this.style.alignment = value;\r\n  }\r\n\r\n  get border() {\r\n    return this.style.border;\r\n  }\r\n\r\n  set border(value) {\r\n    this.style.border = value;\r\n  }\r\n\r\n  get fill() {\r\n    return this.style.fill;\r\n  }\r\n\r\n  set fill(value) {\r\n    this.style.fill = value;\r\n  }\r\n\r\n  get protection() {\r\n    return this.style.protection;\r\n  }\r\n\r\n  set protection(value) {\r\n    this.style.protection = value;\r\n  }\r\n\r\n  _mergeStyle(rowStyle, colStyle, style) {\r\n    const numFmt = (rowStyle && rowStyle.numFmt) || (colStyle && colStyle.numFmt);\r\n    if (numFmt) style.numFmt = numFmt;\r\n\r\n    const font = (rowStyle && rowStyle.font) || (colStyle && colStyle.font);\r\n    if (font) style.font = font;\r\n\r\n    const alignment = (rowStyle && rowStyle.alignment) || (colStyle && colStyle.alignment);\r\n    if (alignment) style.alignment = alignment;\r\n\r\n    const border = (rowStyle && rowStyle.border) || (colStyle && colStyle.border);\r\n    if (border) style.border = border;\r\n\r\n    const fill = (rowStyle && rowStyle.fill) || (colStyle && colStyle.fill);\r\n    if (fill) style.fill = fill;\r\n\r\n    const protection = (rowStyle && rowStyle.protection) || (colStyle && colStyle.protection);\r\n    if (protection) style.protection = protection;\r\n\r\n    return style;\r\n  }\r\n\r\n  // =========================================================================\r\n  // return the address for this cell\r\n  get address() {\r\n    return this._address;\r\n  }\r\n\r\n  get row() {\r\n    return this._row.number;\r\n  }\r\n\r\n  get col() {\r\n    return this._column.number;\r\n  }\r\n\r\n  get $col$row() {\r\n    return `$${this._column.letter}$${this.row}`;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Value stuff\r\n\r\n  get type() {\r\n    return this._value.type;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return this._value.effectiveType;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this._value.toCsvString();\r\n  }\r\n\r\n  // =========================================================================\r\n  // Merge stuff\r\n\r\n  addMergeRef() {\r\n    this._mergeCount++;\r\n  }\r\n\r\n  releaseMergeRef() {\r\n    this._mergeCount--;\r\n  }\r\n\r\n  get isMerged() {\r\n    return this._mergeCount > 0 || this.type === Cell.Types.Merge;\r\n  }\r\n\r\n  merge(master, ignoreStyle) {\r\n    this._value.release();\r\n    this._value = Value.create(Cell.Types.Merge, this, master);\r\n    if (!ignoreStyle) {\r\n      this.style = master.style;\r\n    }\r\n  }\r\n\r\n  unmerge() {\r\n    if (this.type === Cell.Types.Merge) {\r\n      this._value.release();\r\n      this._value = Value.create(Cell.Types.Null, this);\r\n      this.style = this._mergeStyle(this._row.style, this._column.style, {});\r\n    }\r\n  }\r\n\r\n  isMergedTo(master) {\r\n    if (this._value.type !== Cell.Types.Merge) return false;\r\n    return this._value.isMergedTo(master);\r\n  }\r\n\r\n  get master() {\r\n    if (this.type === Cell.Types.Merge) {\r\n      return this._value.master;\r\n    }\r\n    return this; // an unmerged cell is its own master\r\n  }\r\n\r\n  get isHyperlink() {\r\n    return this._value.type === Cell.Types.Hyperlink;\r\n  }\r\n\r\n  get hyperlink() {\r\n    return this._value.hyperlink;\r\n  }\r\n\r\n  // return the value\r\n  get value() {\r\n    return this._value.value;\r\n  }\r\n\r\n  // set the value - can be number, string or raw\r\n  set value(v) {\r\n    // special case - merge cells set their master's value\r\n    if (this.type === Cell.Types.Merge) {\r\n      this._value.master.value = v;\r\n      return;\r\n    }\r\n\r\n    this._value.release();\r\n\r\n    // assign value\r\n    this._value = Value.create(Value.getType(v), this, v);\r\n  }\r\n\r\n  get note() {\r\n    return this._comment && this._comment.note;\r\n  }\r\n\r\n  set note(note) {\r\n    this._comment = new Note(note);\r\n  }\r\n\r\n  get text() {\r\n    return this._value.toString();\r\n  }\r\n\r\n  get html() {\r\n    return _.escapeHtml(this.text);\r\n  }\r\n\r\n  toString() {\r\n    return this.text;\r\n  }\r\n\r\n  _upgradeToHyperlink(hyperlink) {\r\n    // if this cell is a string, turn it into a Hyperlink\r\n    if (this.type === Cell.Types.String) {\r\n      this._value = Value.create(Cell.Types.Hyperlink, this, {\r\n        text: this._value.value,\r\n        hyperlink,\r\n      });\r\n    }\r\n  }\r\n\r\n  // =========================================================================\r\n  // Formula stuff\r\n  get formula() {\r\n    return this._value.formula;\r\n  }\r\n\r\n  get result() {\r\n    return this._value.result;\r\n  }\r\n\r\n  get formulaType() {\r\n    return this._value.formulaType;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Name stuff\r\n  get fullAddress() {\r\n    const {worksheet} = this._row;\r\n    return {\r\n      sheetName: worksheet.name,\r\n      address: this.address,\r\n      row: this.row,\r\n      col: this.col,\r\n    };\r\n  }\r\n\r\n  get name() {\r\n    return this.names[0];\r\n  }\r\n\r\n  set name(value) {\r\n    this.names = [value];\r\n  }\r\n\r\n  get names() {\r\n    return this.workbook.definedNames.getNamesEx(this.fullAddress);\r\n  }\r\n\r\n  set names(value) {\r\n    const {definedNames} = this.workbook;\r\n    definedNames.removeAllNames(this.fullAddress);\r\n    value.forEach(name => {\r\n      definedNames.addEx(this.fullAddress, name);\r\n    });\r\n  }\r\n\r\n  addName(name) {\r\n    this.workbook.definedNames.addEx(this.fullAddress, name);\r\n  }\r\n\r\n  removeName(name) {\r\n    this.workbook.definedNames.removeEx(this.fullAddress, name);\r\n  }\r\n\r\n  removeAllNames() {\r\n    this.workbook.definedNames.removeAllNames(this.fullAddress);\r\n  }\r\n\r\n  // =========================================================================\r\n  // Data Validation stuff\r\n  get _dataValidations() {\r\n    return this.worksheet.dataValidations;\r\n  }\r\n\r\n  get dataValidation() {\r\n    return this._dataValidations.find(this.address);\r\n  }\r\n\r\n  set dataValidation(value) {\r\n    this._dataValidations.add(this.address, value);\r\n  }\r\n\r\n  // =========================================================================\r\n  // Model stuff\r\n\r\n  get model() {\r\n    const {model} = this._value;\r\n    model.style = this.style;\r\n    if (this._comment) {\r\n      model.comment = this._comment.model;\r\n    }\r\n    return model;\r\n  }\r\n\r\n  set model(value) {\r\n    this._value.release();\r\n    this._value = Value.create(value.type, this);\r\n    this._value.model = value;\r\n\r\n    if (value.comment) {\r\n      switch (value.comment.type) {\r\n        case 'note':\r\n          this._comment = Note.fromModel(value.comment);\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (value.style) {\r\n      this.style = value.style;\r\n    } else {\r\n      this.style = {};\r\n    }\r\n  }\r\n}\r\nCell.Types = Enums.ValueType;\r\n\r\n// =============================================================================\r\n// Internal Value Types\r\n\r\nclass NullValue {\r\n  constructor(cell) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Null,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return null;\r\n  }\r\n\r\n  set value(value) {\r\n    // nothing to do\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Null;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Null;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return '';\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return '';\r\n  }\r\n}\r\n\r\nclass NumberValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Number,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Number;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Number;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.value.toString();\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value.toString();\r\n  }\r\n}\r\n\r\nclass StringValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.String,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.String;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.String;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return `\"${this.model.value.replace(/\"/g, '\"\"')}\"`;\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value;\r\n  }\r\n}\r\n\r\nclass RichTextValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.String,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  toString() {\r\n    return this.model.value.richText.map(t => t.text).join('');\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.RichText;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.RichText;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return `\"${this.text.replace(/\"/g, '\"\"')}\"`;\r\n  }\r\n\r\n  release() {}\r\n}\r\n\r\nclass DateValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Date,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Date;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Date;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.value.toISOString();\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value.toString();\r\n  }\r\n}\r\n\r\nclass HyperlinkValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Hyperlink,\r\n      text: value ? value.text : undefined,\r\n      hyperlink: value ? value.hyperlink : undefined,\r\n    };\r\n    if (value && value.tooltip) {\r\n      this.model.tooltip = value.tooltip;\r\n    }\r\n  }\r\n\r\n  get value() {\r\n    const v = {\r\n      text: this.model.text,\r\n      hyperlink: this.model.hyperlink,\r\n    };\r\n    if (this.model.tooltip) {\r\n      v.tooltip = this.model.tooltip;\r\n    }\r\n    return v;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model = {\r\n      text: value.text,\r\n      hyperlink: value.hyperlink,\r\n    };\r\n    if (value.tooltip) {\r\n      this.model.tooltip = value.tooltip;\r\n    }\r\n  }\r\n\r\n  get text() {\r\n    return this.model.text;\r\n  }\r\n\r\n  set text(value) {\r\n    this.model.text = value;\r\n  }\r\n\r\n  /*\r\n  get tooltip() {\r\n    return this.model.tooltip;\r\n  }\r\n\r\n  set tooltip(value) {\r\n    this.model.tooltip = value;\r\n  } */\r\n\r\n  get hyperlink() {\r\n    return this.model.hyperlink;\r\n  }\r\n\r\n  set hyperlink(value) {\r\n    this.model.hyperlink = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Hyperlink;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Hyperlink;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.hyperlink;\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.text;\r\n  }\r\n}\r\n\r\nclass MergeValue {\r\n  constructor(cell, master) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Merge,\r\n      master: master ? master.address : undefined,\r\n    };\r\n    this._master = master;\r\n    if (master) {\r\n      master.addMergeRef();\r\n    }\r\n  }\r\n\r\n  get value() {\r\n    return this._master.value;\r\n  }\r\n\r\n  set value(value) {\r\n    if (value instanceof Cell) {\r\n      if (this._master) {\r\n        this._master.releaseMergeRef();\r\n      }\r\n      value.addMergeRef();\r\n      this._master = value;\r\n    } else {\r\n      this._master.value = value;\r\n    }\r\n  }\r\n\r\n  isMergedTo(master) {\r\n    return master === this._master;\r\n  }\r\n\r\n  get master() {\r\n    return this._master;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Merge;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return this._master.effectiveType;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return '';\r\n  }\r\n\r\n  release() {\r\n    this._master.releaseMergeRef();\r\n  }\r\n\r\n  toString() {\r\n    return this.value.toString();\r\n  }\r\n}\r\n\r\nclass FormulaValue {\r\n  constructor(cell, value) {\r\n    this.cell = cell;\r\n\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Formula,\r\n      shareType: value ? value.shareType : undefined,\r\n      ref: value ? value.ref : undefined,\r\n      formula: value ? value.formula : undefined,\r\n      sharedFormula: value ? value.sharedFormula : undefined,\r\n      result: value ? value.result : undefined,\r\n    };\r\n  }\r\n\r\n  _copyModel(model) {\r\n    const copy = {};\r\n    const cp = name => {\r\n      const value = model[name];\r\n      if (value) {\r\n        copy[name] = value;\r\n      }\r\n    };\r\n    cp('formula');\r\n    cp('result');\r\n    cp('ref');\r\n    cp('shareType');\r\n    cp('sharedFormula');\r\n    return copy;\r\n  }\r\n\r\n  get value() {\r\n    return this._copyModel(this.model);\r\n  }\r\n\r\n  set value(value) {\r\n    this.model = this._copyModel(value);\r\n  }\r\n\r\n  validate(value) {\r\n    switch (Value.getType(value)) {\r\n      case Cell.Types.Null:\r\n      case Cell.Types.String:\r\n      case Cell.Types.Number:\r\n      case Cell.Types.Date:\r\n        break;\r\n      case Cell.Types.Hyperlink:\r\n      case Cell.Types.Formula:\r\n      default:\r\n        throw new Error('Cannot process that type of result value');\r\n    }\r\n  }\r\n\r\n  get dependencies() {\r\n    // find all the ranges and cells mentioned in the formula\r\n    const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}:[A-Z]{1,3}\\d{1,4}/g);\r\n    const cells = this.formula\r\n      .replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}:[A-Z]{1,3}\\d{1,4}/g, '')\r\n      .match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}/g);\r\n    return {\r\n      ranges,\r\n      cells,\r\n    };\r\n  }\r\n\r\n  get formula() {\r\n    return this.model.formula || this._getTranslatedFormula();\r\n  }\r\n\r\n  set formula(value) {\r\n    this.model.formula = value;\r\n  }\r\n\r\n  get formulaType() {\r\n    if (this.model.formula) {\r\n      return Enums.FormulaType.Master;\r\n    }\r\n    if (this.model.sharedFormula) {\r\n      return Enums.FormulaType.Shared;\r\n    }\r\n    return Enums.FormulaType.None;\r\n  }\r\n\r\n  get result() {\r\n    return this.model.result;\r\n  }\r\n\r\n  set result(value) {\r\n    this.model.result = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Formula;\r\n  }\r\n\r\n  get effectiveType() {\r\n    const v = this.model.result;\r\n    if (v === null || v === undefined) {\r\n      return Enums.ValueType.Null;\r\n    }\r\n    if (v instanceof String || typeof v === 'string') {\r\n      return Enums.ValueType.String;\r\n    }\r\n    if (typeof v === 'number') {\r\n      return Enums.ValueType.Number;\r\n    }\r\n    if (v instanceof Date) {\r\n      return Enums.ValueType.Date;\r\n    }\r\n    if (v.text && v.hyperlink) {\r\n      return Enums.ValueType.Hyperlink;\r\n    }\r\n    if (v.formula) {\r\n      return Enums.ValueType.Formula;\r\n    }\r\n\r\n    return Enums.ValueType.Null;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  _getTranslatedFormula() {\r\n    if (!this._translatedFormula && this.model.sharedFormula) {\r\n      const {worksheet} = this.cell;\r\n      const master = worksheet.findCell(this.model.sharedFormula);\r\n      this._translatedFormula =\r\n        master && slideFormula(master.formula, master.address, this.model.address);\r\n    }\r\n    return this._translatedFormula;\r\n  }\r\n\r\n  toCsvString() {\r\n    return `${this.model.result || ''}`;\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.result ? this.model.result.toString() : '';\r\n  }\r\n}\r\n\r\nclass SharedStringValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.SharedString,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.SharedString;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.SharedString;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.value.toString();\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value.toString();\r\n  }\r\n}\r\n\r\nclass BooleanValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Boolean,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Boolean;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Boolean;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.value ? 1 : 0;\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value.toString();\r\n  }\r\n}\r\n\r\nclass ErrorValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.Error,\r\n      value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.value;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.value = value;\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.Error;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.Error;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.toString();\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value.error.toString();\r\n  }\r\n}\r\n\r\nclass JSONValue {\r\n  constructor(cell, value) {\r\n    this.model = {\r\n      address: cell.address,\r\n      type: Cell.Types.String,\r\n      value: JSON.stringify(value),\r\n      rawValue: value,\r\n    };\r\n  }\r\n\r\n  get value() {\r\n    return this.model.rawValue;\r\n  }\r\n\r\n  set value(value) {\r\n    this.model.rawValue = value;\r\n    this.model.value = JSON.stringify(value);\r\n  }\r\n\r\n  get type() {\r\n    return Cell.Types.String;\r\n  }\r\n\r\n  get effectiveType() {\r\n    return Cell.Types.String;\r\n  }\r\n\r\n  get address() {\r\n    return this.model.address;\r\n  }\r\n\r\n  set address(value) {\r\n    this.model.address = value;\r\n  }\r\n\r\n  toCsvString() {\r\n    return this.model.value;\r\n  }\r\n\r\n  release() {}\r\n\r\n  toString() {\r\n    return this.model.value;\r\n  }\r\n}\r\n\r\n// Value is a place to hold common static Value type functions\r\nconst Value = {\r\n  getType(value) {\r\n    if (value === null || value === undefined) {\r\n      return Cell.Types.Null;\r\n    }\r\n    if (value instanceof String || typeof value === 'string') {\r\n      return Cell.Types.String;\r\n    }\r\n    if (typeof value === 'number') {\r\n      return Cell.Types.Number;\r\n    }\r\n    if (typeof value === 'boolean') {\r\n      return Cell.Types.Boolean;\r\n    }\r\n    if (value instanceof Date) {\r\n      return Cell.Types.Date;\r\n    }\r\n    if (value.text && value.hyperlink) {\r\n      return Cell.Types.Hyperlink;\r\n    }\r\n    if (value.formula || value.sharedFormula) {\r\n      return Cell.Types.Formula;\r\n    }\r\n    if (value.richText) {\r\n      return Cell.Types.RichText;\r\n    }\r\n    if (value.sharedString) {\r\n      return Cell.Types.SharedString;\r\n    }\r\n    if (value.error) {\r\n      return Cell.Types.Error;\r\n    }\r\n    return Cell.Types.JSON;\r\n  },\r\n\r\n  // map valueType to constructor\r\n  types: [\r\n    {t: Cell.Types.Null, f: NullValue},\r\n    {t: Cell.Types.Number, f: NumberValue},\r\n    {t: Cell.Types.String, f: StringValue},\r\n    {t: Cell.Types.Date, f: DateValue},\r\n    {t: Cell.Types.Hyperlink, f: HyperlinkValue},\r\n    {t: Cell.Types.Formula, f: FormulaValue},\r\n    {t: Cell.Types.Merge, f: MergeValue},\r\n    {t: Cell.Types.JSON, f: JSONValue},\r\n    {t: Cell.Types.SharedString, f: SharedStringValue},\r\n    {t: Cell.Types.RichText, f: RichTextValue},\r\n    {t: Cell.Types.Boolean, f: BooleanValue},\r\n    {t: Cell.Types.Error, f: ErrorValue},\r\n  ].reduce((p, t) => {\r\n    p[t.t] = t.f;\r\n    return p;\r\n  }, []),\r\n\r\n  create(type, cell, value) {\r\n    const T = this.types[type];\r\n    if (!T) {\r\n      throw new Error(`Could not create Value of type ${type}`);\r\n    }\r\n    return new T(cell, value);\r\n  },\r\n};\r\n\r\nmodule.exports = Cell;\r\n","const colCache = require('./col-cache');\r\n\r\n// const cellRefRegex = /(([a-z_\\-0-9]*)!)?[$]?([a-z]+)[$]?([1-9][0-9]*)/i;\r\nconst replacementCandidateRx = /(([a-z_\\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;\r\nconst CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;\r\n\r\nfunction slideFormula(formula, fromCell, toCell) {\r\n  const offset = colCache.decode(fromCell);\r\n  const to = colCache.decode(toCell);\r\n  return formula.replace(\r\n    replacementCandidateRx,\r\n    (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {\r\n      if (trailingParen) {\r\n        return refMatch;\r\n      }\r\n      const match = CRrx.exec(addrPart);\r\n      if (match) {\r\n        const colDollar = match[1];\r\n        const colStr = match[2].toUpperCase();\r\n        const rowDollar = match[3];\r\n        const rowStr = match[4];\r\n        if (colStr.length > 3 || (colStr.length === 3 && colStr > 'XFD')) {\r\n          // > XFD is the highest col number in excel 2007 and beyond, so this is a named range\r\n          return refMatch;\r\n        }\r\n        let col = colCache.l2n(colStr);\r\n        let row = parseInt(rowStr, 10);\r\n        if (!colDollar) {\r\n          col += to.col - offset.col;\r\n        }\r\n        if (!rowDollar) {\r\n          row += to.row - offset.row;\r\n        }\r\n        const res = (sheet || '') + (colDollar || '') + colCache.n2l(col) + (rowDollar || '') + row;\r\n        return res;\r\n      }\r\n      return refMatch;\r\n    }\r\n  );\r\n}\r\n\r\nmodule.exports = {\r\n  slideFormula,\r\n};\r\n","const _ = require('../utils/under-dash');\r\n\r\nclass Note {\r\n  constructor(note) {\r\n    this.note = note;\r\n  }\r\n\r\n  get model() {\r\n    let value = null;\r\n    switch (typeof this.note) {\r\n      case 'string':\r\n        value = {\r\n          type: 'note',\r\n          note: {\r\n            texts: [\r\n              {\r\n                text: this.note,\r\n              },\r\n            ],\r\n          },\r\n        };\r\n        break;\r\n      default:\r\n        value = {\r\n          type: 'note',\r\n          note: this.note,\r\n        };\r\n        break;\r\n    }\r\n    // Suitable for all cell comments\r\n    return _.deepMerge({}, Note.DEFAULT_CONFIGS, value);\r\n  }\r\n\r\n  set model(value) {\r\n    const {note} = value;\r\n    const {texts} = note;\r\n    if (texts.length === 1 && Object.keys(texts[0]).length === 1) {\r\n      this.note = texts[0].text;\r\n    } else {\r\n      this.note = note;\r\n    }\r\n  }\r\n\r\n  static fromModel(model) {\r\n    const note = new Note();\r\n    note.model = model;\r\n    return note;\r\n  }\r\n}\r\n\r\nNote.DEFAULT_CONFIGS = {\r\n  note: {\r\n    margins: {\r\n      insetmode: 'auto',\r\n      inset: [0.13, 0.13, 0.25, 0.25],\r\n    },\r\n    protection: {\r\n      locked: 'True',\r\n      lockText: 'True',\r\n    },\r\n    editAs: 'absolute',\r\n  },\r\n};\r\n\r\nmodule.exports = Note;\r\n","\r\n\r\nconst _ = require('../utils/under-dash');\r\n\r\nconst Enums = require('./enums');\r\nconst colCache = require('../utils/col-cache');\r\n\r\nconst DEFAULT_COLUMN_WIDTH = 9;\r\n\r\n// Column defines the column properties for 1 column.\r\n// This includes header rows, widths, key, (style), etc.\r\n// Worksheet will condense the columns as appropriate during serialization\r\nclass Column {\r\n  constructor(worksheet, number, defn) {\r\n    this._worksheet = worksheet;\r\n    this._number = number;\r\n    if (defn !== false) {\r\n      // sometimes defn will follow\r\n      this.defn = defn;\r\n    }\r\n  }\r\n\r\n  get number() {\r\n    return this._number;\r\n  }\r\n\r\n  get worksheet() {\r\n    return this._worksheet;\r\n  }\r\n\r\n  get letter() {\r\n    return colCache.n2l(this._number);\r\n  }\r\n\r\n  get isCustomWidth() {\r\n    return this.width !== undefined && this.width !== DEFAULT_COLUMN_WIDTH;\r\n  }\r\n\r\n  get defn() {\r\n    return {\r\n      header: this._header,\r\n      key: this.key,\r\n      width: this.width,\r\n      style: this.style,\r\n      hidden: this.hidden,\r\n      outlineLevel: this.outlineLevel,\r\n    };\r\n  }\r\n\r\n  set defn(value) {\r\n    if (value) {\r\n      this.key = value.key;\r\n      this.width = value.width !== undefined ? value.width : DEFAULT_COLUMN_WIDTH;\r\n      this.outlineLevel = value.outlineLevel;\r\n      if (value.style) {\r\n        this.style = value.style;\r\n      } else {\r\n        this.style = {};\r\n      }\r\n\r\n      // headers must be set after style\r\n      this.header = value.header;\r\n      this._hidden = !!value.hidden;\r\n    } else {\r\n      delete this._header;\r\n      delete this._key;\r\n      delete this.width;\r\n      this.style = {};\r\n      this.outlineLevel = 0;\r\n    }\r\n  }\r\n\r\n  get headers() {\r\n    return this._header && this._header instanceof Array ? this._header : [this._header];\r\n  }\r\n\r\n  get header() {\r\n    return this._header;\r\n  }\r\n\r\n  set header(value) {\r\n    if (value !== undefined) {\r\n      this._header = value;\r\n      this.headers.forEach((text, index) => {\r\n        this._worksheet.getCell(index + 1, this.number).value = text;\r\n      });\r\n    } else {\r\n      this._header = undefined;\r\n    }\r\n  }\r\n\r\n  get key() {\r\n    return this._key;\r\n  }\r\n\r\n  set key(value) {\r\n    const column = this._key && this._worksheet.getColumnKey(this._key);\r\n    if (column === this) {\r\n      this._worksheet.deleteColumnKey(this._key);\r\n    }\r\n\r\n    this._key = value;\r\n    if (value) {\r\n      this._worksheet.setColumnKey(this._key, this);\r\n    }\r\n  }\r\n\r\n  get hidden() {\r\n    return !!this._hidden;\r\n  }\r\n\r\n  set hidden(value) {\r\n    this._hidden = value;\r\n  }\r\n\r\n  get outlineLevel() {\r\n    return this._outlineLevel || 0;\r\n  }\r\n\r\n  set outlineLevel(value) {\r\n    this._outlineLevel = value;\r\n  }\r\n\r\n  get collapsed() {\r\n    return !!(\r\n      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol\r\n    );\r\n  }\r\n\r\n  toString() {\r\n    return JSON.stringify({\r\n      key: this.key,\r\n      width: this.width,\r\n      headers: this.headers.length ? this.headers : undefined,\r\n    });\r\n  }\r\n\r\n  equivalentTo(other) {\r\n    return (\r\n      this.width === other.width &&\r\n      this.hidden === other.hidden &&\r\n      this.outlineLevel === other.outlineLevel &&\r\n      _.isEqual(this.style, other.style)\r\n    );\r\n  }\r\n\r\n  get isDefault() {\r\n    if (this.isCustomWidth) {\r\n      return false;\r\n    }\r\n    if (this.hidden) {\r\n      return false;\r\n    }\r\n    if (this.outlineLevel) {\r\n      return false;\r\n    }\r\n    const s = this.style;\r\n    if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  get headerCount() {\r\n    return this.headers.length;\r\n  }\r\n\r\n  eachCell(options, iteratee) {\r\n    const colNumber = this.number;\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = null;\r\n    }\r\n    this._worksheet.eachRow(options, (row, rowNumber) => {\r\n      iteratee(row.getCell(colNumber), rowNumber);\r\n    });\r\n  }\r\n\r\n  get values() {\r\n    const v = [];\r\n    this.eachCell((cell, rowNumber) => {\r\n      if (cell && cell.type !== Enums.ValueType.Null) {\r\n        v[rowNumber] = cell.value;\r\n      }\r\n    });\r\n    return v;\r\n  }\r\n\r\n  set values(v) {\r\n    if (!v) {\r\n      return;\r\n    }\r\n    const colNumber = this.number;\r\n    let offset = 0;\r\n    if (v.hasOwnProperty('0')) {\r\n      // assume contiguous array, start at row 1\r\n      offset = 1;\r\n    }\r\n    v.forEach((value, index) => {\r\n      this._worksheet.getCell(index + offset, colNumber).value = value;\r\n    });\r\n  }\r\n\r\n  // =========================================================================\r\n  // styles\r\n  _applyStyle(name, value) {\r\n    this.style[name] = value;\r\n    this.eachCell(cell => {\r\n      cell[name] = value;\r\n    });\r\n    return value;\r\n  }\r\n\r\n  get numFmt() {\r\n    return this.style.numFmt;\r\n  }\r\n\r\n  set numFmt(value) {\r\n    this._applyStyle('numFmt', value);\r\n  }\r\n\r\n  get font() {\r\n    return this.style.font;\r\n  }\r\n\r\n  set font(value) {\r\n    this._applyStyle('font', value);\r\n  }\r\n\r\n  get alignment() {\r\n    return this.style.alignment;\r\n  }\r\n\r\n  set alignment(value) {\r\n    this._applyStyle('alignment', value);\r\n  }\r\n\r\n  get protection() {\r\n    return this.style.protection;\r\n  }\r\n\r\n  set protection(value) {\r\n    this._applyStyle('protection', value);\r\n  }\r\n\r\n  get border() {\r\n    return this.style.border;\r\n  }\r\n\r\n  set border(value) {\r\n    this._applyStyle('border', value);\r\n  }\r\n\r\n  get fill() {\r\n    return this.style.fill;\r\n  }\r\n\r\n  set fill(value) {\r\n    this._applyStyle('fill', value);\r\n  }\r\n\r\n  // =============================================================================\r\n  // static functions\r\n\r\n  static toModel(columns) {\r\n    // Convert array of Column into compressed list cols\r\n    const cols = [];\r\n    let col = null;\r\n    if (columns) {\r\n      columns.forEach((column, index) => {\r\n        if (column.isDefault) {\r\n          if (col) {\r\n            col = null;\r\n          }\r\n        } else if (!col || !column.equivalentTo(col)) {\r\n          col = {\r\n            min: index + 1,\r\n            max: index + 1,\r\n            width: column.width !== undefined ? column.width : DEFAULT_COLUMN_WIDTH,\r\n            style: column.style,\r\n            isCustomWidth: column.isCustomWidth,\r\n            hidden: column.hidden,\r\n            outlineLevel: column.outlineLevel,\r\n            collapsed: column.collapsed,\r\n          };\r\n          cols.push(col);\r\n        } else {\r\n          col.max = index + 1;\r\n        }\r\n      });\r\n    }\r\n    return cols.length ? cols : undefined;\r\n  }\r\n\r\n  static fromModel(worksheet, cols) {\r\n    cols = cols || [];\r\n    const columns = [];\r\n    let count = 1;\r\n    let index = 0;\r\n    while (index < cols.length) {\r\n      const col = cols[index++];\r\n      while (count < col.min) {\r\n        columns.push(new Column(worksheet, count++));\r\n      }\r\n      while (count <= col.max) {\r\n        columns.push(new Column(worksheet, count++, col));\r\n      }\r\n    }\r\n    return columns.length ? columns : null;\r\n  }\r\n}\r\n\r\nmodule.exports = Column;\r\n","const colCache = require('../utils/col-cache');\r\nconst Anchor = require('./anchor');\r\n\r\nclass Image {\r\n  constructor(worksheet, model) {\r\n    this.worksheet = worksheet;\r\n    this.model = model;\r\n  }\r\n\r\n  get model() {\r\n    switch (this.type) {\r\n      case 'background':\r\n        return {\r\n          type: this.type,\r\n          imageId: this.imageId,\r\n        };\r\n      case 'image':\r\n        return {\r\n          type: this.type,\r\n          imageId: this.imageId,\r\n          hyperlinks: this.range.hyperlinks,\r\n          range: {\r\n            tl: this.range.tl.model,\r\n            br: this.range.br && this.range.br.model,\r\n            ext: this.range.ext,\r\n            editAs: this.range.editAs,\r\n          },\r\n        };\r\n      default:\r\n        throw new Error('Invalid Image Type');\r\n    }\r\n  }\r\n\r\n  set model({type, imageId, range, hyperlinks}) {\r\n    this.type = type;\r\n    this.imageId = imageId;\r\n\r\n    if (type === 'image') {\r\n      if (typeof range === 'string') {\r\n        const decoded = colCache.decode(range);\r\n        this.range = {\r\n          tl: new Anchor(this.worksheet, {col: decoded.left, row: decoded.top}, -1),\r\n          br: new Anchor(this.worksheet, {col: decoded.right, row: decoded.bottom}, 0),\r\n          editAs: 'oneCell',\r\n        };\r\n      } else {\r\n        this.range = {\r\n          tl: new Anchor(this.worksheet, range.tl, 0),\r\n          br: range.br && new Anchor(this.worksheet, range.br, 0),\r\n          ext: range.ext,\r\n          editAs: range.editAs,\r\n          hyperlinks: hyperlinks || range.hyperlinks,\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Image;\r\n","\r\n\r\nconst colCache = require('../utils/col-cache');\r\n\r\nclass Anchor {\r\n  constructor(worksheet, address, offset = 0) {\r\n    if (!address) {\r\n      this.nativeCol = 0;\r\n      this.nativeColOff = 0;\r\n      this.nativeRow = 0;\r\n      this.nativeRowOff = 0;\r\n    } else if (typeof address === 'string') {\r\n      const decoded = colCache.decodeAddress(address);\r\n      this.nativeCol = decoded.col + offset;\r\n      this.nativeColOff = 0;\r\n      this.nativeRow = decoded.row + offset;\r\n      this.nativeRowOff = 0;\r\n    } else if (address.nativeCol !== undefined) {\r\n      this.nativeCol = address.nativeCol || 0;\r\n      this.nativeColOff = address.nativeColOff || 0;\r\n      this.nativeRow = address.nativeRow || 0;\r\n      this.nativeRowOff = address.nativeRowOff || 0;\r\n    } else if (address.col !== undefined) {\r\n      this.col = address.col + offset;\r\n      this.row = address.row + offset;\r\n    } else {\r\n      this.nativeCol = 0;\r\n      this.nativeColOff = 0;\r\n      this.nativeRow = 0;\r\n      this.nativeRowOff = 0;\r\n    }\r\n\r\n    this.worksheet = worksheet;\r\n  }\r\n\r\n  static asInstance(model) {\r\n    return model instanceof Anchor || model == null ? model : new Anchor(model);\r\n  }\r\n\r\n  get col() {\r\n    return this.nativeCol + (Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth);\r\n  }\r\n\r\n  set col(v) {\r\n    this.nativeCol = Math.floor(v);\r\n    this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);\r\n  }\r\n\r\n  get row() {\r\n    return this.nativeRow + (Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight);\r\n  }\r\n\r\n  set row(v) {\r\n    this.nativeRow = Math.floor(v);\r\n    this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);\r\n  }\r\n\r\n  get colWidth() {\r\n    return this.worksheet &&\r\n      this.worksheet.getColumn(this.nativeCol + 1) &&\r\n      this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth\r\n      ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 10000)\r\n      : 640000;\r\n  }\r\n\r\n  get rowHeight() {\r\n    return this.worksheet &&\r\n      this.worksheet.getRow(this.nativeRow + 1) &&\r\n      this.worksheet.getRow(this.nativeRow + 1).height\r\n      ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 10000)\r\n      : 180000;\r\n  }\r\n\r\n  get model() {\r\n    return {\r\n      nativeCol: this.nativeCol,\r\n      nativeColOff: this.nativeColOff,\r\n      nativeRow: this.nativeRow,\r\n      nativeRowOff: this.nativeRowOff,\r\n    };\r\n  }\r\n\r\n  set model(value) {\r\n    this.nativeCol = value.nativeCol;\r\n    this.nativeColOff = value.nativeColOff;\r\n    this.nativeRow = value.nativeRow;\r\n    this.nativeRowOff = value.nativeRowOff;\r\n  }\r\n}\r\n\r\nmodule.exports = Anchor;\r\n","/* eslint-disable max-classes-per-file */\r\nconst colCache = require('../utils/col-cache');\r\n\r\nclass Column {\r\n  // wrapper around column model, allowing access and manipulation\r\n  constructor(table, column, index) {\r\n    this.table = table;\r\n    this.column = column;\r\n    this.index = index;\r\n  }\r\n\r\n  _set(name, value) {\r\n    this.table.cacheState();\r\n    this.column[name] = value;\r\n  }\r\n\r\n  /* eslint-disable lines-between-class-members */\r\n  get name() {\r\n    return this.column.name;\r\n  }\r\n  set name(value) {\r\n    this._set('name', value);\r\n  }\r\n\r\n  get filterButton() {\r\n    return this.column.filterButton;\r\n  }\r\n  set filterButton(value) {\r\n    this.column.filterButton = value;\r\n  }\r\n\r\n  get style() {\r\n    return this.column.style;\r\n  }\r\n  set style(value) {\r\n    this.column.style = value;\r\n  }\r\n\r\n  get totalsRowLabel() {\r\n    return this.column.totalsRowLabel;\r\n  }\r\n  set totalsRowLabel(value) {\r\n    this._set('totalsRowLabel', value);\r\n  }\r\n\r\n  get totalsRowFunction() {\r\n    return this.column.totalsRowFunction;\r\n  }\r\n  set totalsRowFunction(value) {\r\n    this._set('totalsRowFunction', value);\r\n  }\r\n\r\n  get totalsRowResult() {\r\n    return this.column.totalsRowResult;\r\n  }\r\n  set totalsRowResult(value) {\r\n    this._set('totalsRowResult', value);\r\n  }\r\n\r\n  get totalsRowFormula() {\r\n    return this.column.totalsRowFormula;\r\n  }\r\n  set totalsRowFormula(value) {\r\n    this._set('totalsRowFormula', value);\r\n  }\r\n  /* eslint-enable lines-between-class-members */\r\n}\r\n\r\nclass Table {\r\n  constructor(worksheet, table) {\r\n    this.worksheet = worksheet;\r\n    if (table) {\r\n      this.table = table;\r\n      // check things are ok first\r\n      this.validate();\r\n\r\n      this.store();\r\n    }\r\n  }\r\n\r\n  getFormula(column) {\r\n    // get the correct formula to apply to the totals row\r\n    switch (column.totalsRowFunction) {\r\n      case 'none':\r\n        return null;\r\n      case 'average':\r\n        return `SUBTOTAL(101,${this.table.name}[${column.name}])`;\r\n      case 'countNums':\r\n        return `SUBTOTAL(102,${this.table.name}[${column.name}])`;\r\n      case 'count':\r\n        return `SUBTOTAL(103,${this.table.name}[${column.name}])`;\r\n      case 'max':\r\n        return `SUBTOTAL(104,${this.table.name}[${column.name}])`;\r\n      case 'min':\r\n        return `SUBTOTAL(105,${this.table.name}[${column.name}])`;\r\n      case 'stdDev':\r\n        return `SUBTOTAL(106,${this.table.name}[${column.name}])`;\r\n      case 'var':\r\n        return `SUBTOTAL(107,${this.table.name}[${column.name}])`;\r\n      case 'sum':\r\n        return `SUBTOTAL(109,${this.table.name}[${column.name}])`;\r\n      case 'custom':\r\n        return column.totalsRowFormula;\r\n      default:\r\n        throw new Error(`Invalid Totals Row Function: ${column.totalsRowFunction}`);\r\n    }\r\n  }\r\n\r\n  get width() {\r\n    // width of the table\r\n    return this.table.columns.length;\r\n  }\r\n\r\n  get height() {\r\n    // height of the table data\r\n    return this.table.rows.length;\r\n  }\r\n\r\n  get filterHeight() {\r\n    // height of the table data plus optional header row\r\n    return this.height + (this.table.headerRow ? 1 : 0);\r\n  }\r\n\r\n  get tableHeight() {\r\n    // full height of the table on the sheet\r\n    return this.filterHeight + (this.table.totalsRow ? 1 : 0);\r\n  }\r\n\r\n  validate() {\r\n    const {table} = this;\r\n    // set defaults and check is valid\r\n    const assign = (o, name, dflt) => {\r\n      if (o[name] === undefined) {\r\n        o[name] = dflt;\r\n      }\r\n    };\r\n    assign(table, 'headerRow', true);\r\n    assign(table, 'totalsRow', false);\r\n\r\n    assign(table, 'style', {});\r\n    assign(table.style, 'theme', 'TableStyleMedium2');\r\n    assign(table.style, 'showFirstColumn', false);\r\n    assign(table.style, 'showLastColumn', false);\r\n    assign(table.style, 'showRowStripes', false);\r\n    assign(table.style, 'showColumnStripes', false);\r\n\r\n    const assert = (test, message) => {\r\n      if (!test) {\r\n        throw new Error(message);\r\n      }\r\n    };\r\n    assert(table.ref, 'Table must have ref');\r\n    assert(table.columns, 'Table must have column definitions');\r\n    assert(table.rows, 'Table must have row definitions');\r\n\r\n    table.tl = colCache.decodeAddress(table.ref);\r\n    const {row, col} = table.tl;\r\n    assert(row > 0, 'Table must be on valid row');\r\n    assert(col > 0, 'Table must be on valid col');\r\n\r\n    const {width, filterHeight, tableHeight} = this;\r\n\r\n    // autoFilterRef is a range that includes optional headers only\r\n    table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width - 1);\r\n\r\n    // tableRef is a range that includes optional headers and totals\r\n    table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width - 1);\r\n\r\n    table.columns.forEach((column, i) => {\r\n      assert(column.name, `Column ${i} must have a name`);\r\n      if (i === 0) {\r\n        assign(column, 'totalsRowLabel', 'Total');\r\n      } else {\r\n        assign(column, 'totalsRowFunction', 'none');\r\n        column.totalsRowFormula = this.getFormula(column);\r\n      }\r\n    });\r\n  }\r\n\r\n  store() {\r\n    // where the table needs to store table data, headers, footers in\r\n    // the sheet...\r\n    const assignStyle = (cell, style) => {\r\n      if (style) {\r\n        Object.keys(style).forEach(key => {\r\n          cell[key] = style[key];\r\n        });\r\n      }\r\n    };\r\n\r\n    const {worksheet, table} = this;\r\n    const {row, col} = table.tl;\r\n    let count = 0;\r\n    if (table.headerRow) {\r\n      const r = worksheet.getRow(row + count++);\r\n      table.columns.forEach((column, j) => {\r\n        const {style, name} = column;\r\n        const cell = r.getCell(col + j);\r\n        cell.value = name;\r\n        assignStyle(cell, style);\r\n      });\r\n    }\r\n    table.rows.forEach(data => {\r\n      const r = worksheet.getRow(row + count++);\r\n      data.forEach((value, j) => {\r\n        const cell = r.getCell(col + j);\r\n        cell.value = value;\r\n\r\n        assignStyle(cell, table.columns[j].style);\r\n      });\r\n    });\r\n\r\n    if (table.totalsRow) {\r\n      const r = worksheet.getRow(row + count++);\r\n      table.columns.forEach((column, j) => {\r\n        const cell = r.getCell(col + j);\r\n        if (j === 0) {\r\n          cell.value = column.totalsRowLabel;\r\n        } else {\r\n          const formula = this.getFormula(column);\r\n          if (formula) {\r\n            cell.value = {\r\n              formula: column.totalsRowFormula,\r\n              result: column.totalsRowResult,\r\n            };\r\n          } else {\r\n            cell.value = null;\r\n          }\r\n        }\r\n\r\n        assignStyle(cell, column.style);\r\n      });\r\n    }\r\n  }\r\n\r\n  load(worksheet) {\r\n    // where the table will read necessary features from a loaded sheet\r\n    const {table} = this;\r\n    const {row, col} = table.tl;\r\n    let count = 0;\r\n    if (table.headerRow) {\r\n      const r = worksheet.getRow(row + count++);\r\n      table.columns.forEach((column, j) => {\r\n        const cell = r.getCell(col + j);\r\n        cell.value = column.name;\r\n      });\r\n    }\r\n    table.rows.forEach(data => {\r\n      const r = worksheet.getRow(row + count++);\r\n      data.forEach((value, j) => {\r\n        const cell = r.getCell(col + j);\r\n        cell.value = value;\r\n      });\r\n    });\r\n\r\n    if (table.totalsRow) {\r\n      const r = worksheet.getRow(row + count++);\r\n      table.columns.forEach((column, j) => {\r\n        const cell = r.getCell(col + j);\r\n        if (j === 0) {\r\n          cell.value = column.totalsRowLabel;\r\n        } else {\r\n          const formula = this.getFormula(column);\r\n          if (formula) {\r\n            cell.value = {\r\n              formula: column.totalsRowFormula,\r\n              result: column.totalsRowResult,\r\n            };\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  get model() {\r\n    return this.table;\r\n  }\r\n\r\n  set model(value) {\r\n    this.table = value;\r\n  }\r\n\r\n  // ================================================================\r\n  // TODO: Mutating methods\r\n  cacheState() {\r\n    if (!this._cache) {\r\n      this._cache = {\r\n        ref: this.ref,\r\n        width: this.width,\r\n        tableHeight: this.tableHeight,\r\n      };\r\n    }\r\n  }\r\n\r\n  commit() {\r\n    // changes may have been made that might have on-sheet effects\r\n    if (!this._cache) {\r\n      return;\r\n    }\r\n\r\n    // check things are ok first\r\n    this.validate();\r\n\r\n    const ref = colCache.decodeAddress(this._cache.ref);\r\n    if (this.ref !== this._cache.ref) {\r\n      // wipe out whole table footprint at previous location\r\n      for (let i = 0; i < this._cache.tableHeight; i++) {\r\n        const row = this.worksheet.getRow(ref.row + i);\r\n        for (let j = 0; j < this._cache.width; j++) {\r\n          const cell = row.getCell(ref.col + j);\r\n          cell.value = null;\r\n        }\r\n      }\r\n    } else {\r\n      // clear out below table if it has shrunk\r\n      for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {\r\n        const row = this.worksheet.getRow(ref.row + i);\r\n        for (let j = 0; j < this._cache.width; j++) {\r\n          const cell = row.getCell(ref.col + j);\r\n          cell.value = null;\r\n        }\r\n      }\r\n\r\n      // clear out to right of table if it has lost columns\r\n      for (let i = 0; i < this.tableHeight; i++) {\r\n        const row = this.worksheet.getRow(ref.row + i);\r\n        for (let j = this.width; j < this._cache.width; j++) {\r\n          const cell = row.getCell(ref.col + j);\r\n          cell.value = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.store();\r\n  }\r\n\r\n  addRow(values, rowNumber) {\r\n    // Add a row of data, either insert at rowNumber or append\r\n    this.cacheState();\r\n\r\n    if (rowNumber === undefined) {\r\n      this.table.rows.push(values);\r\n    } else {\r\n      this.table.rows.splice(rowNumber, 0, values);\r\n    }\r\n  }\r\n\r\n  removeRows(rowIndex, count = 1) {\r\n    // Remove a rows of data\r\n    this.cacheState();\r\n    this.table.rows.splice(rowIndex, count);\r\n  }\r\n\r\n  getColumn(colIndex) {\r\n    const column = this.table.columns[colIndex];\r\n    return new Column(this, column, colIndex);\r\n  }\r\n\r\n  addColumn(column, values, colIndex) {\r\n    // Add a new column, including column defn and values\r\n    // Inserts at colNumber or adds to the right\r\n    this.cacheState();\r\n\r\n    if (colIndex === undefined) {\r\n      this.table.columns.push(column);\r\n      this.table.rows.forEach((row, i) => {\r\n        row.push(values[i]);\r\n      });\r\n    } else {\r\n      this.table.columns.splice(colIndex, 0, column);\r\n      this.table.rows.forEach((row, i) => {\r\n        row.splice(colIndex, 0, values[i]);\r\n      });\r\n    }\r\n  }\r\n\r\n  removeColumns(colIndex, count = 1) {\r\n    // Remove a column with data\r\n    this.cacheState();\r\n\r\n    this.table.columns.splice(colIndex, count);\r\n    this.table.rows.forEach(row => {\r\n      row.splice(colIndex, count);\r\n    });\r\n  }\r\n\r\n  _assign(target, prop, value) {\r\n    this.cacheState();\r\n    target[prop] = value;\r\n  }\r\n\r\n  /* eslint-disable lines-between-class-members */\r\n  get ref() {\r\n    return this.table.ref;\r\n  }\r\n  set ref(value) {\r\n    this._assign(this.table, 'ref', value);\r\n  }\r\n\r\n  get name() {\r\n    return this.table.name;\r\n  }\r\n  set name(value) {\r\n    this.table.name = value;\r\n  }\r\n\r\n  get displayName() {\r\n    return this.table.displyName || this.table.name;\r\n  }\r\n  set displayNamename(value) {\r\n    this.table.displayName = value;\r\n  }\r\n\r\n  get headerRow() {\r\n    return this.table.headerRow;\r\n  }\r\n  set headerRow(value) {\r\n    this._assign(this.table, 'headerRow', value);\r\n  }\r\n\r\n  get totalsRow() {\r\n    return this.table.totalsRow;\r\n  }\r\n  set totalsRow(value) {\r\n    this._assign(this.table, 'totalsRow', value);\r\n  }\r\n\r\n  get theme() {\r\n    return this.table.style.name;\r\n  }\r\n  set theme(value) {\r\n    this.table.style.name = value;\r\n  }\r\n\r\n  get showFirstColumn() {\r\n    return this.table.style.showFirstColumn;\r\n  }\r\n  set showFirstColumn(value) {\r\n    this.table.style.showFirstColumn = value;\r\n  }\r\n\r\n  get showLastColumn() {\r\n    return this.table.style.showLastColumn;\r\n  }\r\n  set showLastColumn(value) {\r\n    this.table.style.showLastColumn = value;\r\n  }\r\n\r\n  get showRowStripes() {\r\n    return this.table.style.showRowStripes;\r\n  }\r\n  set showRowStripes(value) {\r\n    this.table.style.showRowStripes = value;\r\n  }\r\n\r\n  get showColumnStripes() {\r\n    return this.table.style.showColumnStripes;\r\n  }\r\n  set showColumnStripes(value) {\r\n    this.table.style.showColumnStripes = value;\r\n  }\r\n  /* eslint-enable lines-between-class-members */\r\n}\r\n\r\nmodule.exports = Table;\r\n","class DataValidations {\r\n  constructor(model) {\r\n    this.model = model || {};\r\n  }\r\n\r\n  add(address, validation) {\r\n    return (this.model[address] = validation);\r\n  }\r\n\r\n  find(address) {\r\n    return this.model[address];\r\n  }\r\n\r\n  remove(address) {\r\n    this.model[address] = undefined;\r\n  }\r\n}\r\n\r\nmodule.exports = DataValidations;\r\n","\r\n\r\nconst crypto = require('crypto');\r\n\r\nconst Encryptor = {\r\n  /**\r\n   * Calculate a hash of the concatenated buffers with the given algorithm.\r\n   * @param {string} algorithm - The hash algorithm.\r\n   * @returns {Buffer} The hash\r\n   */\r\n  hash(algorithm, ...buffers) {\r\n    const hash = crypto.createHash(algorithm);\r\n    hash.update(Buffer.concat(buffers));\r\n    return hash.digest();\r\n  },\r\n  /**\r\n   * Convert a password into an encryption key\r\n   * @param {string} password - The password\r\n   * @param {string} hashAlgorithm - The hash algoritm\r\n   * @param {string} saltValue - The salt value\r\n   * @param {number} spinCount - The spin count\r\n   * @param {number} keyBits - The length of the key in bits\r\n   * @param {Buffer} blockKey - The block key\r\n   * @returns {Buffer} The encryption key\r\n   */\r\n  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {\r\n    hashAlgorithm = hashAlgorithm.toLowerCase();\r\n    const hashes = crypto.getHashes();\r\n    if (hashes.indexOf(hashAlgorithm) < 0) {\r\n      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);\r\n    }\r\n\r\n    // Password must be in unicode buffer\r\n    const passwordBuffer = Buffer.from(password, 'utf16le');\r\n    // Generate the initial hash\r\n    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer);\r\n    // Now regenerate until spin count\r\n    for (let i = 0; i < spinCount; i++) {\r\n      const iterator = Buffer.alloc(4);\r\n      // this is the 'special' element of Excel password hashing\r\n      // that stops us from using crypto.pbkdf2()\r\n      iterator.writeUInt32LE(i, 0);\r\n      key = this.hash(hashAlgorithm, key, iterator);\r\n    }\r\n    return key.toString('base64');\r\n  },\r\n  /**\r\n   * Generates cryptographically strong pseudo-random data.\r\n   * @param size The size argument is a number indicating the number of bytes to generate.\r\n   */\r\n  randomBytes(size) {\r\n    return crypto.randomBytes(size);\r\n  },\r\n};\r\nmodule.exports = Encryptor;\r\n","\r\n\r\nconst _ = require('../utils/under-dash');\r\nconst colCache = require('../utils/col-cache');\r\nconst CellMatrix = require('../utils/cell-matrix');\r\nconst Range = require('./range');\r\n\r\nconst rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\r\n\r\nclass DefinedNames {\r\n  constructor() {\r\n    this.matrixMap = {};\r\n  }\r\n\r\n  getMatrix(name) {\r\n    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\r\n    return matrix;\r\n  }\r\n\r\n  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\r\n  add(locStr, name) {\r\n    const location = colCache.decodeEx(locStr);\r\n    this.addEx(location, name);\r\n  }\r\n\r\n  addEx(location, name) {\r\n    const matrix = this.getMatrix(name);\r\n    if (location.top) {\r\n      for (let col = location.left; col <= location.right; col++) {\r\n        for (let row = location.top; row <= location.bottom; row++) {\r\n          const address = {\r\n            sheetName: location.sheetName,\r\n            address: colCache.n2l(col) + row,\r\n            row,\r\n            col,\r\n          };\r\n\r\n          matrix.addCellEx(address);\r\n        }\r\n      }\r\n    } else {\r\n      matrix.addCellEx(location);\r\n    }\r\n  }\r\n\r\n  remove(locStr, name) {\r\n    const location = colCache.decodeEx(locStr);\r\n    this.removeEx(location, name);\r\n  }\r\n\r\n  removeEx(location, name) {\r\n    const matrix = this.getMatrix(name);\r\n    matrix.removeCellEx(location);\r\n  }\r\n\r\n  removeAllNames(location) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.removeCellEx(location);\r\n    });\r\n  }\r\n\r\n  forEach(callback) {\r\n    _.each(this.matrixMap, (matrix, name) => {\r\n      matrix.forEach(cell => {\r\n        callback(name, cell);\r\n      });\r\n    });\r\n  }\r\n\r\n  // get all the names of a cell\r\n  getNames(addressStr) {\r\n    return this.getNamesEx(colCache.decodeEx(addressStr));\r\n  }\r\n\r\n  getNamesEx(address) {\r\n    return _.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(\r\n      Boolean\r\n    );\r\n  }\r\n\r\n  _explore(matrix, cell) {\r\n    cell.mark = false;\r\n    const {sheetName} = cell;\r\n\r\n    const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\r\n    let x;\r\n    let y;\r\n\r\n    // grow vertical - only one col to worry about\r\n    function vGrow(yy, edge) {\r\n      const c = matrix.findCellAt(sheetName, yy, cell.col);\r\n      if (!c || !c.mark) {\r\n        return false;\r\n      }\r\n      range[edge] = yy;\r\n      c.mark = false;\r\n      return true;\r\n    }\r\n    for (y = cell.row - 1; vGrow(y, 'top'); y--);\r\n    for (y = cell.row + 1; vGrow(y, 'bottom'); y++);\r\n\r\n    // grow horizontal - ensure all rows can grow\r\n    function hGrow(xx, edge) {\r\n      const cells = [];\r\n      for (y = range.top; y <= range.bottom; y++) {\r\n        const c = matrix.findCellAt(sheetName, y, xx);\r\n        if (c && c.mark) {\r\n          cells.push(c);\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      range[edge] = xx;\r\n      for (let i = 0; i < cells.length; i++) {\r\n        cells[i].mark = false;\r\n      }\r\n      return true;\r\n    }\r\n    for (x = cell.col - 1; hGrow(x, 'left'); x--);\r\n    for (x = cell.col + 1; hGrow(x, 'right'); x++);\r\n\r\n    return range;\r\n  }\r\n\r\n  getRanges(name, matrix) {\r\n    matrix = matrix || this.matrixMap[name];\r\n\r\n    if (!matrix) {\r\n      return {name, ranges: []};\r\n    }\r\n\r\n    // mark and sweep!\r\n    matrix.forEach(cell => {\r\n      cell.mark = true;\r\n    });\r\n    const ranges = matrix\r\n      .map(cell => cell.mark && this._explore(matrix, cell))\r\n      .filter(Boolean)\r\n      .map(range => range.$shortRange);\r\n\r\n    return {\r\n      name,\r\n      ranges,\r\n    };\r\n  }\r\n\r\n  normaliseMatrix(matrix, sheetName) {\r\n    // some of the cells might have shifted on specified sheet\r\n    // need to reassign rows, cols\r\n    matrix.forEachInSheet(sheetName, (cell, row, col) => {\r\n      if (cell) {\r\n        if (cell.row !== row || cell.col !== col) {\r\n          cell.row = row;\r\n          cell.col = col;\r\n          cell.address = colCache.n2l(col) + row;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  spliceRows(sheetName, start, numDelete, numInsert) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.spliceRows(sheetName, start, numDelete, numInsert);\r\n      this.normaliseMatrix(matrix, sheetName);\r\n    });\r\n  }\r\n\r\n  spliceColumns(sheetName, start, numDelete, numInsert) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.spliceColumns(sheetName, start, numDelete, numInsert);\r\n      this.normaliseMatrix(matrix, sheetName);\r\n    });\r\n  }\r\n\r\n  get model() {\r\n    // To get names per cell - just iterate over all names finding cells if they exist\r\n    return _.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(\r\n      definedName => definedName.ranges.length\r\n    );\r\n  }\r\n\r\n  set model(value) {\r\n    // value is [ { name, ranges }, ... ]\r\n    const matrixMap = (this.matrixMap = {});\r\n    value.forEach(definedName => {\r\n      const matrix = (matrixMap[definedName.name] = new CellMatrix());\r\n      definedName.ranges.forEach(rangeStr => {\r\n        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\r\n          matrix.addCell(rangeStr);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = DefinedNames;\r\n","const _ = require('./under-dash');\r\nconst colCache = require('./col-cache');\r\n\r\nclass CellMatrix {\r\n  constructor(template) {\r\n    this.template = template;\r\n    this.sheets = {};\r\n  }\r\n\r\n  addCell(addressStr) {\r\n    this.addCellEx(colCache.decodeEx(addressStr));\r\n  }\r\n\r\n  getCell(addressStr) {\r\n    return this.findCellEx(colCache.decodeEx(addressStr), true);\r\n  }\r\n\r\n  findCell(addressStr) {\r\n    return this.findCellEx(colCache.decodeEx(addressStr), false);\r\n  }\r\n\r\n  findCellAt(sheetName, rowNumber, colNumber) {\r\n    const sheet = this.sheets[sheetName];\r\n    const row = sheet && sheet[rowNumber];\r\n    return row && row[colNumber];\r\n  }\r\n\r\n  addCellEx(address) {\r\n    if (address.top) {\r\n      for (let row = address.top; row <= address.bottom; row++) {\r\n        for (let col = address.left; col <= address.right; col++) {\r\n          this.getCellAt(address.sheetName, row, col);\r\n        }\r\n      }\r\n    } else {\r\n      this.findCellEx(address, true);\r\n    }\r\n  }\r\n\r\n  getCellEx(address) {\r\n    return this.findCellEx(address, true);\r\n  }\r\n\r\n  findCellEx(address, create) {\r\n    const sheet = this.findSheet(address, create);\r\n    const row = this.findSheetRow(sheet, address, create);\r\n    return this.findRowCell(row, address, create);\r\n  }\r\n\r\n  getCellAt(sheetName, rowNumber, colNumber) {\r\n    const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);\r\n    const row = sheet[rowNumber] || (sheet[rowNumber] = []);\r\n    const cell =\r\n      row[colNumber] ||\r\n      (row[colNumber] = {\r\n        sheetName,\r\n        address: colCache.n2l(colNumber) + rowNumber,\r\n        row: rowNumber,\r\n        col: colNumber,\r\n      });\r\n    return cell;\r\n  }\r\n\r\n  removeCellEx(address) {\r\n    const sheet = this.findSheet(address);\r\n    if (!sheet) {\r\n      return;\r\n    }\r\n    const row = this.findSheetRow(sheet, address);\r\n    if (!row) {\r\n      return;\r\n    }\r\n    delete row[address.col];\r\n  }\r\n\r\n  forEachInSheet(sheetName, callback) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      sheet.forEach((row, rowNumber) => {\r\n        if (row) {\r\n          row.forEach((cell, colNumber) => {\r\n            if (cell) {\r\n              callback(cell, rowNumber, colNumber);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  forEach(callback) {\r\n    _.each(this.sheets, (sheet, sheetName) => {\r\n      this.forEachInSheet(sheetName, callback);\r\n    });\r\n  }\r\n\r\n  map(callback) {\r\n    const results = [];\r\n    this.forEach(cell => {\r\n      results.push(callback(cell));\r\n    });\r\n    return results;\r\n  }\r\n\r\n  findSheet(address, create) {\r\n    const name = address.sheetName;\r\n    if (this.sheets[name]) {\r\n      return this.sheets[name];\r\n    }\r\n    if (create) {\r\n      return (this.sheets[name] = []);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  findSheetRow(sheet, address, create) {\r\n    const {row} = address;\r\n    if (sheet && sheet[row]) {\r\n      return sheet[row];\r\n    }\r\n    if (create) {\r\n      return (sheet[row] = []);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  findRowCell(row, address, create) {\r\n    const {col} = address;\r\n    if (row && row[col]) {\r\n      return row[col];\r\n    }\r\n    if (create) {\r\n      return (row[col] = this.template\r\n        ? Object.assign(address, JSON.parse(JSON.stringify(this.template)))\r\n        : address);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  spliceRows(sheetName, start, numDelete, numInsert) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      const inserts = [];\r\n      for (let i = 0; i < numInsert; i++) {\r\n        inserts.push([]);\r\n      }\r\n      sheet.splice(start, numDelete, ...inserts);\r\n    }\r\n  }\r\n\r\n  spliceColumns(sheetName, start, numDelete, numInsert) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      const inserts = [];\r\n      for (let i = 0; i < numInsert; i++) {\r\n        inserts.push(null);\r\n      }\r\n      _.each(sheet, row => {\r\n        row.splice(start, numDelete, ...inserts);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CellMatrix;\r\n","const fs = require('fs');\r\nconst JSZip = require('jszip');\r\nconst {PassThrough} = require('readable-stream');\r\nconst ZipStream = require('../utils/zip-stream');\r\nconst StreamBuf = require('../utils/stream-buf');\r\n\r\nconst utils = require('../utils/utils');\r\nconst XmlStream = require('../utils/xml-stream');\r\nconst {bufferToString} = require('../utils/browser-buffer-decode');\r\n\r\nconst StylesXform = require('./xform/style/styles-xform');\r\n\r\nconst CoreXform = require('./xform/core/core-xform');\r\nconst SharedStringsXform = require('./xform/strings/shared-strings-xform');\r\nconst RelationshipsXform = require('./xform/core/relationships-xform');\r\nconst ContentTypesXform = require('./xform/core/content-types-xform');\r\nconst AppXform = require('./xform/core/app-xform');\r\nconst WorkbookXform = require('./xform/book/workbook-xform');\r\nconst WorksheetXform = require('./xform/sheet/worksheet-xform');\r\nconst DrawingXform = require('./xform/drawing/drawing-xform');\r\nconst TableXform = require('./xform/table/table-xform');\r\nconst CommentsXform = require('./xform/comment/comments-xform');\r\nconst VmlNotesXform = require('./xform/comment/vml-notes-xform');\r\n\r\nconst theme1Xml = require('./xml/theme1.js');\r\n\r\nfunction fsReadFileAsync(filename, options) {\r\n  return new Promise((resolve, reject) => {\r\n    fs.readFile(filename, options, (error, data) => {\r\n      if (error) {\r\n        reject(error);\r\n      } else {\r\n        resolve(data);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nclass XLSX {\r\n  constructor(workbook) {\r\n    this.workbook = workbook;\r\n  }\r\n\r\n  // ===============================================================================\r\n  // Workbook\r\n  // =========================================================================\r\n  // Read\r\n\r\n  async readFile(filename, options) {\r\n    if (!(await utils.fs.exists(filename))) {\r\n      throw new Error(`File not found: ${filename}`);\r\n    }\r\n    const stream = fs.createReadStream(filename);\r\n    try {\r\n      const workbook = await this.read(stream, options);\r\n      stream.close();\r\n      return workbook;\r\n    } catch (error) {\r\n      stream.close();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  parseRels(stream) {\r\n    const xform = new RelationshipsXform();\r\n    return xform.parseStream(stream);\r\n  }\r\n\r\n  parseWorkbook(stream) {\r\n    const xform = new WorkbookXform();\r\n    return xform.parseStream(stream);\r\n  }\r\n\r\n  parseSharedStrings(stream) {\r\n    const xform = new SharedStringsXform();\r\n    return xform.parseStream(stream);\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    const workbookXform = new WorkbookXform();\r\n    const worksheetXform = new WorksheetXform(options);\r\n    const drawingXform = new DrawingXform();\r\n    const tableXform = new TableXform();\r\n\r\n    workbookXform.reconcile(model);\r\n\r\n    // reconcile drawings with their rels\r\n    const drawingOptions = {\r\n      media: model.media,\r\n      mediaIndex: model.mediaIndex,\r\n    };\r\n    Object.keys(model.drawings).forEach(name => {\r\n      const drawing = model.drawings[name];\r\n      const drawingRel = model.drawingRels[name];\r\n      if (drawingRel) {\r\n        drawingOptions.rels = drawingRel.reduce((o, rel) => {\r\n          o[rel.Id] = rel;\r\n          return o;\r\n        }, {});\r\n        (drawing.anchors || []).forEach(anchor => {\r\n          const hyperlinks = anchor.picture && anchor.picture.hyperlinks;\r\n          if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {\r\n            hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;\r\n            delete hyperlinks.rId;\r\n          }\r\n        });\r\n        drawingXform.reconcile(drawing, drawingOptions);\r\n      }\r\n    });\r\n\r\n    // reconcile tables with the default styles\r\n    const tableOptions = {\r\n      styles: model.styles,\r\n    };\r\n    Object.values(model.tables).forEach(table => {\r\n      tableXform.reconcile(table, tableOptions);\r\n    });\r\n\r\n    const sheetOptions = {\r\n      styles: model.styles,\r\n      sharedStrings: model.sharedStrings,\r\n      media: model.media,\r\n      mediaIndex: model.mediaIndex,\r\n      date1904: model.properties && model.properties.date1904,\r\n      drawings: model.drawings,\r\n      comments: model.comments,\r\n      tables: model.tables,\r\n      vmlDrawings: model.vmlDrawings,\r\n    };\r\n    model.worksheets.forEach(worksheet => {\r\n      worksheet.relationships = model.worksheetRels[worksheet.sheetNo];\r\n      worksheetXform.reconcile(worksheet, sheetOptions);\r\n    });\r\n\r\n    // delete unnecessary parts\r\n    delete model.worksheetHash;\r\n    delete model.worksheetRels;\r\n    delete model.globalRels;\r\n    delete model.sharedStrings;\r\n    delete model.workbookRels;\r\n    delete model.sheetDefs;\r\n    delete model.styles;\r\n    delete model.mediaIndex;\r\n    delete model.drawings;\r\n    delete model.drawingRels;\r\n    delete model.vmlDrawings;\r\n  }\r\n\r\n  async _processWorksheetEntry(stream, model, sheetNo, options, path) {\r\n    const xform = new WorksheetXform(options);\r\n    const worksheet = await xform.parseStream(stream);\r\n    worksheet.sheetNo = sheetNo;\r\n    model.worksheetHash[path] = worksheet;\r\n    model.worksheets.push(worksheet);\r\n  }\r\n\r\n  async _processCommentEntry(stream, model, name) {\r\n    const xform = new CommentsXform();\r\n    const comments = await xform.parseStream(stream);\r\n    model.comments[`../${name}.xml`] = comments;\r\n  }\r\n\r\n  async _processTableEntry(stream, model, name) {\r\n    const xform = new TableXform();\r\n    const table = await xform.parseStream(stream);\r\n    model.tables[`../tables/${name}.xml`] = table;\r\n  }\r\n\r\n  async _processWorksheetRelsEntry(stream, model, sheetNo) {\r\n    const xform = new RelationshipsXform();\r\n    const relationships = await xform.parseStream(stream);\r\n    model.worksheetRels[sheetNo] = relationships;\r\n  }\r\n\r\n  async _processMediaEntry(entry, model, filename) {\r\n    const lastDot = filename.lastIndexOf('.');\r\n    // if we can't determine extension, ignore it\r\n    if (lastDot >= 1) {\r\n      const extension = filename.substr(lastDot + 1);\r\n      const name = filename.substr(0, lastDot);\r\n      await new Promise((resolve, reject) => {\r\n        const streamBuf = new StreamBuf();\r\n        streamBuf.on('finish', () => {\r\n          model.mediaIndex[filename] = model.media.length;\r\n          model.mediaIndex[name] = model.media.length;\r\n          const medium = {\r\n            type: 'image',\r\n            name,\r\n            extension,\r\n            buffer: streamBuf.toBuffer(),\r\n          };\r\n          model.media.push(medium);\r\n          resolve();\r\n        });\r\n        entry.on('error', error => {\r\n          reject(error);\r\n        });\r\n        entry.pipe(streamBuf);\r\n      });\r\n    }\r\n  }\r\n\r\n  async _processDrawingEntry(entry, model, name) {\r\n    const xform = new DrawingXform();\r\n    const drawing = await xform.parseStream(entry);\r\n    model.drawings[name] = drawing;\r\n  }\r\n\r\n  async _processDrawingRelsEntry(entry, model, name) {\r\n    const xform = new RelationshipsXform();\r\n    const relationships = await xform.parseStream(entry);\r\n    model.drawingRels[name] = relationships;\r\n  }\r\n\r\n  async _processVmlDrawingEntry(entry, model, name) {\r\n    const xform = new VmlNotesXform();\r\n    const vmlDrawing = await xform.parseStream(entry);\r\n    model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;\r\n  }\r\n\r\n  async _processThemeEntry(entry, model, name) {\r\n    await new Promise((resolve, reject) => {\r\n      // TODO: stream entry into buffer and store the xml in the model.themes[]\r\n      const stream = new StreamBuf();\r\n      entry.on('error', reject);\r\n      stream.on('error', reject);\r\n      stream.on('finish', () => {\r\n        model.themes[name] = stream.read().toString();\r\n        resolve();\r\n      });\r\n      entry.pipe(stream);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md\r\n   */\r\n  createInputStream() {\r\n    throw new Error(\r\n      '`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'\r\n    );\r\n  }\r\n\r\n  async read(stream, options) {\r\n    // TODO: Remove once node v8 is deprecated\r\n    // Detect and upgrade old streams\r\n    if (!stream[Symbol.asyncIterator] && stream.pipe) {\r\n      stream = stream.pipe(new PassThrough());\r\n    }\r\n    const chunks = [];\r\n    for await (const chunk of stream) {\r\n      chunks.push(chunk);\r\n    }\r\n    return this.load(Buffer.concat(chunks), options);\r\n  }\r\n\r\n  async load(data, options) {\r\n    let buffer;\r\n    if (options && options.base64) {\r\n      buffer = Buffer.from(data.toString(), 'base64');\r\n    } else {\r\n      buffer = data;\r\n    }\r\n\r\n    const model = {\r\n      worksheets: [],\r\n      worksheetHash: {},\r\n      worksheetRels: [],\r\n      themes: {},\r\n      media: [],\r\n      mediaIndex: {},\r\n      drawings: {},\r\n      drawingRels: {},\r\n      comments: {},\r\n      tables: {},\r\n      vmlDrawings: {},\r\n    };\r\n\r\n    const zip = await JSZip.loadAsync(buffer);\r\n    for (const entry of Object.values(zip.files)) {\r\n      /* eslint-disable no-await-in-loop */\r\n      if (!entry.dir) {\r\n        let entryName = entry.name;\r\n        if (entryName[0] === '/') {\r\n          entryName = entryName.substr(1);\r\n        }\r\n        let stream;\r\n        if (entryName.match(/xl\\/media\\//) ||\r\n          // themes are not parsed as stream\r\n          entryName.match(/xl\\/theme\\/([a-zA-Z0-9]+)[.]xml/)) {\r\n          stream = new PassThrough();\r\n          stream.write(await entry.async('nodebuffer'));\r\n        } else {\r\n          // use object mode to avoid buffer-string convention\r\n          stream = new PassThrough({\r\n            writableObjectMode: true,\r\n            readableObjectMode: true,\r\n          });\r\n          let content;\r\n          // https://www.npmjs.com/package/process\r\n          if (process.browser) {\r\n            // running in browser, use TextDecoder if possible\r\n            content = bufferToString(await entry.async('nodebuffer'));\r\n          } else {\r\n            // running in node.js\r\n            content = await entry.async('string');\r\n          }\r\n          const chunkSize = 16 * 1024;\r\n          for (let i = 0; i < content.length; i += chunkSize) {\r\n            stream.write(content.substring(i, i + chunkSize));\r\n          }\r\n        }\r\n        stream.end();\r\n        switch (entryName) {\r\n          case '_rels/.rels':\r\n            model.globalRels = await this.parseRels(stream);\r\n            break;\r\n\r\n          case 'xl/workbook.xml': {\r\n            const workbook = await this.parseWorkbook(stream);\r\n            model.sheets = workbook.sheets;\r\n            model.definedNames = workbook.definedNames;\r\n            model.views = workbook.views;\r\n            model.properties = workbook.properties;\r\n            model.calcProperties = workbook.calcProperties;\r\n            break;\r\n          }\r\n\r\n          case 'xl/_rels/workbook.xml.rels':\r\n            model.workbookRels = await this.parseRels(stream);\r\n            break;\r\n\r\n          case 'xl/sharedStrings.xml':\r\n            model.sharedStrings = new SharedStringsXform();\r\n            await model.sharedStrings.parseStream(stream);\r\n            break;\r\n\r\n          case 'xl/styles.xml':\r\n            model.styles = new StylesXform();\r\n            await model.styles.parseStream(stream);\r\n            break;\r\n\r\n          case 'docProps/app.xml': {\r\n            const appXform = new AppXform();\r\n            const appProperties = await appXform.parseStream(stream);\r\n            model.company = appProperties.company;\r\n            model.manager = appProperties.manager;\r\n            break;\r\n          }\r\n\r\n          case 'docProps/core.xml': {\r\n            const coreXform = new CoreXform();\r\n            const coreProperties = await coreXform.parseStream(stream);\r\n            Object.assign(model, coreProperties);\r\n            break;\r\n          }\r\n\r\n          default: {\r\n            let match = entryName.match(/xl\\/worksheets\\/sheet(\\d+)[.]xml/);\r\n            if (match) {\r\n              await this._processWorksheetEntry(stream, model, match[1], options, entryName);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/worksheets\\/_rels\\/sheet(\\d+)[.]xml.rels/);\r\n            if (match) {\r\n              await this._processWorksheetRelsEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/theme\\/([a-zA-Z0-9]+)[.]xml/);\r\n            if (match) {\r\n              await this._processThemeEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/media\\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);\r\n            if (match) {\r\n              await this._processMediaEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/drawings\\/([a-zA-Z0-9]+)[.]xml/);\r\n            if (match) {\r\n              await this._processDrawingEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/(comments\\d+)[.]xml/);\r\n            if (match) {\r\n              await this._processCommentEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/tables\\/(table\\d+)[.]xml/);\r\n            if (match) {\r\n              await this._processTableEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/drawings\\/_rels\\/([a-zA-Z0-9]+)[.]xml[.]rels/);\r\n            if (match) {\r\n              await this._processDrawingRelsEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n            match = entryName.match(/xl\\/drawings\\/(vmlDrawing\\d+)[.]vml/);\r\n            if (match) {\r\n              await this._processVmlDrawingEntry(stream, model, match[1]);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.reconcile(model, options);\r\n\r\n    // apply model\r\n    this.workbook.model = model;\r\n    return this.workbook;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Write\r\n\r\n  async addMedia(zip, model) {\r\n    await Promise.all(\r\n      model.media.map(async medium => {\r\n        if (medium.type === 'image') {\r\n          const filename = `xl/media/${medium.name}.${medium.extension}`;\r\n          if (medium.filename) {\r\n            const data = await fsReadFileAsync(medium.filename);\r\n            return zip.append(data, {name: filename});\r\n          }\r\n          if (medium.buffer) {\r\n            return zip.append(medium.buffer, {name: filename});\r\n          }\r\n          if (medium.base64) {\r\n            const dataimg64 = medium.base64;\r\n            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);\r\n            return zip.append(content, {name: filename, base64: true});\r\n          }\r\n        }\r\n        throw new Error('Unsupported media');\r\n      })\r\n    );\r\n  }\r\n\r\n  addDrawings(zip, model) {\r\n    const drawingXform = new DrawingXform();\r\n    const relsXform = new RelationshipsXform();\r\n\r\n    model.worksheets.forEach(worksheet => {\r\n      const {drawing} = worksheet;\r\n      if (drawing) {\r\n        drawingXform.prepare(drawing, {});\r\n        let xml = drawingXform.toXml(drawing);\r\n        zip.append(xml, {name: `xl/drawings/${drawing.name}.xml`});\r\n\r\n        xml = relsXform.toXml(drawing.rels);\r\n        zip.append(xml, {name: `xl/drawings/_rels/${drawing.name}.xml.rels`});\r\n      }\r\n    });\r\n  }\r\n\r\n  addTables(zip, model) {\r\n    const tableXform = new TableXform();\r\n\r\n    model.worksheets.forEach(worksheet => {\r\n      const {tables} = worksheet;\r\n      tables.forEach(table => {\r\n        tableXform.prepare(table, {});\r\n        const tableXml = tableXform.toXml(table);\r\n        zip.append(tableXml, {name: `xl/tables/${table.target}`});\r\n      });\r\n    });\r\n  }\r\n\r\n  async addContentTypes(zip, model) {\r\n    const xform = new ContentTypesXform();\r\n    const xml = xform.toXml(model);\r\n    zip.append(xml, {name: '[Content_Types].xml'});\r\n  }\r\n\r\n  async addApp(zip, model) {\r\n    const xform = new AppXform();\r\n    const xml = xform.toXml(model);\r\n    zip.append(xml, {name: 'docProps/app.xml'});\r\n  }\r\n\r\n  async addCore(zip, model) {\r\n    const coreXform = new CoreXform();\r\n    zip.append(coreXform.toXml(model), {name: 'docProps/core.xml'});\r\n  }\r\n\r\n  async addThemes(zip, model) {\r\n    const themes = model.themes || {theme1: theme1Xml};\r\n    Object.keys(themes).forEach(name => {\r\n      const xml = themes[name];\r\n      const path = `xl/theme/${name}.xml`;\r\n      zip.append(xml, {name: path});\r\n    });\r\n  }\r\n\r\n  async addOfficeRels(zip) {\r\n    const xform = new RelationshipsXform();\r\n    const xml = xform.toXml([\r\n      {Id: 'rId1', Type: XLSX.RelType.OfficeDocument, Target: 'xl/workbook.xml'},\r\n      {Id: 'rId2', Type: XLSX.RelType.CoreProperties, Target: 'docProps/core.xml'},\r\n      {Id: 'rId3', Type: XLSX.RelType.ExtenderProperties, Target: 'docProps/app.xml'},\r\n    ]);\r\n    zip.append(xml, {name: '_rels/.rels'});\r\n  }\r\n\r\n  async addWorkbookRels(zip, model) {\r\n    let count = 1;\r\n    const relationships = [\r\n      {Id: `rId${count++}`, Type: XLSX.RelType.Styles, Target: 'styles.xml'},\r\n      {Id: `rId${count++}`, Type: XLSX.RelType.Theme, Target: 'theme/theme1.xml'},\r\n    ];\r\n    if (model.sharedStrings.count) {\r\n      relationships.push({\r\n        Id: `rId${count++}`,\r\n        Type: XLSX.RelType.SharedStrings,\r\n        Target: 'sharedStrings.xml',\r\n      });\r\n    }\r\n    model.worksheets.forEach(worksheet => {\r\n      worksheet.rId = `rId${count++}`;\r\n      relationships.push({\r\n        Id: worksheet.rId,\r\n        Type: XLSX.RelType.Worksheet,\r\n        Target: `worksheets/sheet${worksheet.id}.xml`,\r\n      });\r\n    });\r\n    const xform = new RelationshipsXform();\r\n    const xml = xform.toXml(relationships);\r\n    zip.append(xml, {name: 'xl/_rels/workbook.xml.rels'});\r\n  }\r\n\r\n  async addSharedStrings(zip, model) {\r\n    if (model.sharedStrings && model.sharedStrings.count) {\r\n      zip.append(model.sharedStrings.xml, {name: 'xl/sharedStrings.xml'});\r\n    }\r\n  }\r\n\r\n  async addStyles(zip, model) {\r\n    const {xml} = model.styles;\r\n    if (xml) {\r\n      zip.append(xml, {name: 'xl/styles.xml'});\r\n    }\r\n  }\r\n\r\n  async addWorkbook(zip, model) {\r\n    const xform = new WorkbookXform();\r\n    zip.append(xform.toXml(model), {name: 'xl/workbook.xml'});\r\n  }\r\n\r\n  async addWorksheets(zip, model) {\r\n    // preparation phase\r\n    const worksheetXform = new WorksheetXform();\r\n    const relationshipsXform = new RelationshipsXform();\r\n    const commentsXform = new CommentsXform();\r\n    const vmlNotesXform = new VmlNotesXform();\r\n\r\n    // write sheets\r\n    model.worksheets.forEach(worksheet => {\r\n      let xmlStream = new XmlStream();\r\n      worksheetXform.render(xmlStream, worksheet);\r\n      zip.append(xmlStream.xml, {name: `xl/worksheets/sheet${worksheet.id}.xml`});\r\n\r\n      if (worksheet.rels && worksheet.rels.length) {\r\n        xmlStream = new XmlStream();\r\n        relationshipsXform.render(xmlStream, worksheet.rels);\r\n        zip.append(xmlStream.xml, {name: `xl/worksheets/_rels/sheet${worksheet.id}.xml.rels`});\r\n      }\r\n\r\n      if (worksheet.comments.length > 0) {\r\n        xmlStream = new XmlStream();\r\n        commentsXform.render(xmlStream, worksheet);\r\n        zip.append(xmlStream.xml, {name: `xl/comments${worksheet.id}.xml`});\r\n\r\n        xmlStream = new XmlStream();\r\n        vmlNotesXform.render(xmlStream, worksheet);\r\n        zip.append(xmlStream.xml, {name: `xl/drawings/vmlDrawing${worksheet.id}.vml`});\r\n      }\r\n    });\r\n  }\r\n\r\n  _finalize(zip) {\r\n    return new Promise((resolve, reject) => {\r\n      zip.on('finish', () => {\r\n        resolve(this);\r\n      });\r\n      zip.on('error', reject);\r\n      zip.finalize();\r\n    });\r\n  }\r\n\r\n  prepareModel(model, options) {\r\n    // ensure following properties have sane values\r\n    model.creator = model.creator || 'ExcelJS';\r\n    model.lastModifiedBy = model.lastModifiedBy || 'ExcelJS';\r\n    model.created = model.created || new Date();\r\n    model.modified = model.modified || new Date();\r\n\r\n    model.useSharedStrings =\r\n      options.useSharedStrings !== undefined ? options.useSharedStrings : true;\r\n    model.useStyles = options.useStyles !== undefined ? options.useStyles : true;\r\n\r\n    // Manage the shared strings\r\n    model.sharedStrings = new SharedStringsXform();\r\n\r\n    // add a style manager to handle cell formats, fonts, etc.\r\n    model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();\r\n\r\n    // prepare all of the things before the render\r\n    const workbookXform = new WorkbookXform();\r\n    const worksheetXform = new WorksheetXform();\r\n\r\n    workbookXform.prepare(model);\r\n\r\n    const worksheetOptions = {\r\n      sharedStrings: model.sharedStrings,\r\n      styles: model.styles,\r\n      date1904: model.properties.date1904,\r\n      drawingsCount: 0,\r\n      media: model.media,\r\n    };\r\n    worksheetOptions.drawings = model.drawings = [];\r\n    worksheetOptions.commentRefs = model.commentRefs = [];\r\n    let tableCount = 0;\r\n    model.tables = [];\r\n    model.worksheets.forEach(worksheet => {\r\n      // assign unique filenames to tables\r\n      worksheet.tables.forEach(table => {\r\n        tableCount++;\r\n        table.target = `table${tableCount}.xml`;\r\n        table.id = tableCount;\r\n        model.tables.push(table);\r\n      });\r\n\r\n      worksheetXform.prepare(worksheet, worksheetOptions);\r\n    });\r\n\r\n    // TODO: workbook drawing list\r\n  }\r\n\r\n  async write(stream, options) {\r\n    options = options || {};\r\n    const {model} = this.workbook;\r\n    const zip = new ZipStream.ZipWriter(options.zip);\r\n    zip.pipe(stream);\r\n\r\n    this.prepareModel(model, options);\r\n\r\n    // render\r\n    await this.addContentTypes(zip, model);\r\n    await this.addOfficeRels(zip, model);\r\n    await this.addWorkbookRels(zip, model);\r\n    await this.addWorksheets(zip, model);\r\n    await this.addSharedStrings(zip, model); // always after worksheets\r\n    await this.addDrawings(zip, model);\r\n    await this.addTables(zip, model);\r\n    await Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);\r\n    await this.addMedia(zip, model);\r\n    await Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);\r\n    await this.addWorkbook(zip, model);\r\n    return this._finalize(zip);\r\n  }\r\n\r\n  writeFile(filename, options) {\r\n    const stream = fs.createWriteStream(filename);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      stream.on('finish', () => {\r\n        resolve();\r\n      });\r\n      stream.on('error', error => {\r\n        reject(error);\r\n      });\r\n\r\n      this.write(stream, options).then(() => {\r\n        stream.end();\r\n      });\r\n    });\r\n  }\r\n\r\n  async writeBuffer(options) {\r\n    const stream = new StreamBuf();\r\n    await this.write(stream, options);\r\n    return stream.read();\r\n  }\r\n}\r\n\r\nXLSX.RelType = require('./rel-type');\r\n\r\nmodule.exports = XLSX;\r\n","const events = require('events');\r\nconst JSZip = require('jszip');\r\n\r\nconst StreamBuf = require('./stream-buf');\r\nconst {stringToBuffer} = require('./browser-buffer-encode');\r\n\r\n// =============================================================================\r\n// The ZipWriter class\r\n// Packs streamed data into an output zip stream\r\nclass ZipWriter extends events.EventEmitter {\r\n  constructor(options) {\r\n    super();\r\n    this.options = Object.assign(\r\n      {\r\n        type: 'nodebuffer',\r\n        compression: 'DEFLATE',\r\n      },\r\n      options\r\n    );\r\n\r\n    this.zip = new JSZip();\r\n    this.stream = new StreamBuf();\r\n  }\r\n\r\n  append(data, options) {\r\n    if (options.hasOwnProperty('base64') && options.base64) {\r\n      this.zip.file(options.name, data, {base64: true});\r\n    } else {\r\n      // https://www.npmjs.com/package/process\r\n      if (process.browser && typeof data === 'string') {\r\n        // use TextEncoder in browser\r\n        data = stringToBuffer(data);\r\n      }\r\n      this.zip.file(options.name, data);\r\n    }\r\n  }\r\n\r\n  async finalize() {\r\n    const content = await this.zip.generateAsync(this.options);\r\n    this.stream.end(content);\r\n    this.emit('finish');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Stream.Readable interface\r\n  read(size) {\r\n    return this.stream.read(size);\r\n  }\r\n\r\n  setEncoding(encoding) {\r\n    return this.stream.setEncoding(encoding);\r\n  }\r\n\r\n  pause() {\r\n    return this.stream.pause();\r\n  }\r\n\r\n  resume() {\r\n    return this.stream.resume();\r\n  }\r\n\r\n  isPaused() {\r\n    return this.stream.isPaused();\r\n  }\r\n\r\n  pipe(destination, options) {\r\n    return this.stream.pipe(destination, options);\r\n  }\r\n\r\n  unpipe(destination) {\r\n    return this.stream.unpipe(destination);\r\n  }\r\n\r\n  unshift(chunk) {\r\n    return this.stream.unshift(chunk);\r\n  }\r\n\r\n  wrap(stream) {\r\n    return this.stream.wrap(stream);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n\r\nmodule.exports = {\r\n  ZipWriter,\r\n};\r\n","/* eslint-disable max-classes-per-file */\r\nconst Stream = require('readable-stream');\r\n\r\nconst utils = require('./utils');\r\nconst StringBuf = require('./string-buf');\r\n\r\n// =============================================================================\r\n// data chunks - encapsulating incoming data\r\nclass StringChunk {\r\n  constructor(data, encoding) {\r\n    this._data = data;\r\n    this._encoding = encoding;\r\n  }\r\n\r\n  get length() {\r\n    return this.toBuffer().length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    return this.toBuffer().copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.from(this._data, this._encoding);\r\n    }\r\n    return this._buffer;\r\n  }\r\n}\r\n\r\nclass StringBufChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    return this._data._buf.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data.toBuffer();\r\n  }\r\n}\r\n\r\nclass BufferChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    this._data.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ReadWriteBuf - a single buffer supporting simple read-write\r\nclass ReadWriteBuf {\r\n  constructor(size) {\r\n    this.size = size;\r\n    // the buffer\r\n    this.buffer = Buffer.alloc(size);\r\n    // read index\r\n    this.iRead = 0;\r\n    // write index\r\n    this.iWrite = 0;\r\n  }\r\n\r\n  toBuffer() {\r\n    if (this.iRead === 0 && this.iWrite === this.size) {\r\n      return this.buffer;\r\n    }\r\n\r\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\r\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\r\n    return buf;\r\n  }\r\n\r\n  get length() {\r\n    return this.iWrite - this.iRead;\r\n  }\r\n\r\n  get eod() {\r\n    return this.iRead === this.iWrite;\r\n  }\r\n\r\n  get full() {\r\n    return this.iWrite === this.size;\r\n  }\r\n\r\n  read(size) {\r\n    let buf;\r\n    // read size bytes from buffer and return buffer\r\n    if (size === 0) {\r\n      // special case - return null if no data requested\r\n      return null;\r\n    }\r\n\r\n    if (size === undefined || size >= this.length) {\r\n      // if no size specified or size is at least what we have then return all of the bytes\r\n      buf = this.toBuffer();\r\n      this.iRead = this.iWrite;\r\n      return buf;\r\n    }\r\n\r\n    // otherwise return a chunk\r\n    buf = Buffer.alloc(size);\r\n    this.buffer.copy(buf, 0, this.iRead, size);\r\n    this.iRead += size;\r\n    return buf;\r\n  }\r\n\r\n  write(chunk, offset, length) {\r\n    // write as many bytes from data from optional source offset\r\n    // and return number of bytes written\r\n    const size = Math.min(length, this.size - this.iWrite);\r\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\r\n    this.iWrite += size;\r\n    return size;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// StreamBuf - a multi-purpose read-write stream\r\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\r\n//  As StreamHub - pipe to multiple writables\r\n//  As readable stream - feed data into the writable part and have some other code read from it.\r\n\r\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\r\n// integration tests\r\nconst StreamBuf = function(options) {\r\n  options = options || {};\r\n  this.bufSize = options.bufSize || 1024 * 1024;\r\n  this.buffers = [];\r\n\r\n  // batch mode fills a buffer completely before passing the data on\r\n  // to pipes or 'readable' event listeners\r\n  this.batch = options.batch || false;\r\n\r\n  this.corked = false;\r\n  // where in the current writable buffer we're up to\r\n  this.inPos = 0;\r\n\r\n  // where in the current readable buffer we've read up to\r\n  this.outPos = 0;\r\n\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n\r\n  // controls emit('data')\r\n  this.paused = false;\r\n\r\n  this.encoding = null;\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n  toBuffer() {\r\n    switch (this.buffers.length) {\r\n      case 0:\r\n        return null;\r\n      case 1:\r\n        return this.buffers[0].toBuffer();\r\n      default:\r\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\r\n    }\r\n  },\r\n\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  _getWritableBuffer() {\r\n    if (this.buffers.length) {\r\n      const last = this.buffers[this.buffers.length - 1];\r\n      if (!last.full) {\r\n        return last;\r\n      }\r\n    }\r\n    const buf = new ReadWriteBuf(this.bufSize);\r\n    this.buffers.push(buf);\r\n    return buf;\r\n  },\r\n\r\n  async _pipe(chunk) {\r\n    const write = function(pipe) {\r\n      return new Promise(resolve => {\r\n        pipe.write(chunk.toBuffer(), () => {\r\n          resolve();\r\n        });\r\n      });\r\n    };\r\n    await Promise.all(this.pipes.map(write));\r\n  },\r\n  _writeToBuffers(chunk) {\r\n    let inPos = 0;\r\n    const inLen = chunk.length;\r\n    while (inPos < inLen) {\r\n      // find writable buffer\r\n      const buffer = this._getWritableBuffer();\r\n\r\n      // write some data\r\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\r\n    }\r\n  },\r\n  async write(data, encoding, callback) {\r\n    if (encoding instanceof Function) {\r\n      callback = encoding;\r\n      encoding = 'utf8';\r\n    }\r\n    callback = callback || utils.nop;\r\n\r\n    // encapsulate data into a chunk\r\n    let chunk;\r\n    if (data instanceof StringBuf) {\r\n      chunk = new StringBufChunk(data);\r\n    } else if (data instanceof Buffer) {\r\n      chunk = new BufferChunk(data);\r\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\r\n      chunk = new StringChunk(data, encoding);\r\n    } else {\r\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\r\n    }\r\n\r\n    // now, do something with the chunk\r\n    if (this.pipes.length) {\r\n      if (this.batch) {\r\n        this._writeToBuffers(chunk);\r\n        while (!this.corked && this.buffers.length > 1) {\r\n          this._pipe(this.buffers.shift());\r\n        }\r\n      } else if (!this.corked) {\r\n        await this._pipe(chunk);\r\n        callback();\r\n      } else {\r\n        this._writeToBuffers(chunk);\r\n        process.nextTick(callback);\r\n      }\r\n    } else {\r\n      if (!this.paused) {\r\n        this.emit('data', chunk.toBuffer());\r\n      }\r\n\r\n      this._writeToBuffers(chunk);\r\n      this.emit('readable');\r\n    }\r\n\r\n    return true;\r\n  },\r\n  cork() {\r\n    this.corked = true;\r\n  },\r\n  _flush(/* destination */) {\r\n    // if we have comsumers...\r\n    if (this.pipes.length) {\r\n      // and there's stuff not written\r\n      while (this.buffers.length) {\r\n        this._pipe(this.buffers.shift());\r\n      }\r\n    }\r\n  },\r\n  uncork() {\r\n    this.corked = false;\r\n    this._flush();\r\n  },\r\n  end(chunk, encoding, callback) {\r\n    const writeComplete = error => {\r\n      if (error) {\r\n        callback(error);\r\n      } else {\r\n        this._flush();\r\n        this.pipes.forEach(pipe => {\r\n          pipe.end();\r\n        });\r\n        this.emit('finish');\r\n      }\r\n    };\r\n    if (chunk) {\r\n      this.write(chunk, encoding, writeComplete);\r\n    } else {\r\n      writeComplete();\r\n    }\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read(size) {\r\n    let buffers;\r\n    // read min(buffer, size || infinity)\r\n    if (size) {\r\n      buffers = [];\r\n      while (size && this.buffers.length && !this.buffers[0].eod) {\r\n        const first = this.buffers[0];\r\n        const buffer = first.read(size);\r\n        size -= buffer.length;\r\n        buffers.push(buffer);\r\n        if (first.eod && first.full) {\r\n          this.buffers.shift();\r\n        }\r\n      }\r\n      return Buffer.concat(buffers);\r\n    }\r\n\r\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\r\n    this.buffers = [];\r\n    return Buffer.concat(buffers);\r\n  },\r\n  setEncoding(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause() {\r\n    this.paused = true;\r\n  },\r\n  resume() {\r\n    this.paused = false;\r\n  },\r\n  isPaused() {\r\n    return !!this.paused;\r\n  },\r\n  pipe(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n    if (!this.paused && this.buffers.length) {\r\n      this.end();\r\n    }\r\n  },\r\n  unpipe(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\r\n  },\r\n  unshift(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  },\r\n});\r\n\r\nmodule.exports = StreamBuf;\r\n","const fs = require('fs');\r\n\r\n// useful stuff\r\nconst inherits = function(cls, superCtor, statics, prototype) {\r\n  // eslint-disable-next-line no-underscore-dangle\r\n  cls.super_ = superCtor;\r\n\r\n  if (!prototype) {\r\n    prototype = statics;\r\n    statics = null;\r\n  }\r\n\r\n  if (statics) {\r\n    Object.keys(statics).forEach(i => {\r\n      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));\r\n    });\r\n  }\r\n\r\n  const properties = {\r\n    constructor: {\r\n      value: cls,\r\n      enumerable: false,\r\n      writable: false,\r\n      configurable: true,\r\n    },\r\n  };\r\n  if (prototype) {\r\n    Object.keys(prototype).forEach(i => {\r\n      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);\r\n    });\r\n  }\r\n\r\n  cls.prototype = Object.create(superCtor.prototype, properties);\r\n};\r\n\r\n// eslint-disable-next-line no-control-regex\r\nconst xmlDecodeRegex = /[<>&'\"\\x7F\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/;\r\nconst utils = {\r\n  nop() {},\r\n  promiseImmediate(value) {\r\n    return new Promise(resolve => {\r\n      if (global.setImmediate) {\r\n        setImmediate(() => {\r\n          resolve(value);\r\n        });\r\n      } else {\r\n        // poorman's setImmediate - must wait at least 1ms\r\n        setTimeout(() => {\r\n          resolve(value);\r\n        }, 1);\r\n      }\r\n    });\r\n  },\r\n  inherits,\r\n  dateToExcel(d, date1904) {\r\n    return 25569 + ( d.getTime() / (24 * 3600 * 1000) ) - (date1904 ? 1462 : 0);\r\n  },\r\n  excelToDate(v, date1904) {\r\n    const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);\r\n    return new Date(millisecondSinceEpoch);\r\n  },\r\n  parsePath(filepath) {\r\n    const last = filepath.lastIndexOf('/');\r\n    return {\r\n      path: filepath.substring(0, last),\r\n      name: filepath.substring(last + 1),\r\n    };\r\n  },\r\n  getRelsPath(filepath) {\r\n    const path = utils.parsePath(filepath);\r\n    return `${path.path}/_rels/${path.name}.rels`;\r\n  },\r\n  xmlEncode(text) {\r\n    const regexResult = xmlDecodeRegex.exec(text);\r\n    if (!regexResult) return text;\r\n\r\n    let result = '';\r\n    let escape = '';\r\n    let lastIndex = 0;\r\n    let i = regexResult.index;\r\n    for (; i < text.length; i++) {\r\n      const charCode = text.charCodeAt(i);\r\n      switch (charCode) {\r\n        case 34: // \"\r\n          escape = '&quot;';\r\n          break;\r\n        case 38: // &\r\n          escape = '&amp;';\r\n          break;\r\n        case 39: // '\r\n          escape = '&apos;';\r\n          break;\r\n        case 60: // <\r\n          escape = '&lt;';\r\n          break;\r\n        case 62: // >\r\n          escape = '&gt;';\r\n          break;\r\n        case 127:\r\n          escape = '';\r\n          break;\r\n        default: {\r\n          if (charCode <= 31 && (charCode <= 8 || (charCode >= 11 && charCode !== 13))) {\r\n            escape = '';\r\n            break;\r\n          }\r\n          continue;\r\n        }\r\n      }\r\n      if (lastIndex !== i) result += text.substring(lastIndex, i);\r\n      lastIndex = i + 1;\r\n      if (escape) result += escape;\r\n    }\r\n    if (lastIndex !== i) return result + text.substring(lastIndex, i);\r\n    return result;\r\n  },\r\n  xmlDecode(text) {\r\n    return text.replace(/&([a-z]*);/g, c => {\r\n      switch (c) {\r\n        case '&lt;':\r\n          return '<';\r\n        case '&gt;':\r\n          return '>';\r\n        case '&amp;':\r\n          return '&';\r\n        case '&apos;':\r\n          return '\\'';\r\n        case '&quot;':\r\n          return '\"';\r\n        default:\r\n          return c;\r\n      }\r\n    });\r\n  },\r\n  validInt(value) {\r\n    const i = parseInt(value, 10);\r\n    return !Number.isNaN(i) ? i : 0;\r\n  },\r\n\r\n  isDateFmt(fmt) {\r\n    if (!fmt) {\r\n      return false;\r\n    }\r\n\r\n    // must remove all chars inside quotes and []\r\n    fmt = fmt.replace(/\\[[^\\]]*]/g, '');\r\n    fmt = fmt.replace(/\"[^\"]*\"/g, '');\r\n    // then check for date formatting chars\r\n    const result = fmt.match(/[ymdhMsb]+/) !== null;\r\n    return result;\r\n  },\r\n\r\n  fs: {\r\n    exists(path) {\r\n      return new Promise(resolve => {\r\n        fs.access(path, fs.constants.F_OK, err => {\r\n          resolve(!err);\r\n        });\r\n      });\r\n    },\r\n  },\r\n\r\n  toIsoDateString(dt) {\r\n    return dt.toIsoString().subsstr(0, 10);\r\n  },\r\n};\r\n\r\nmodule.exports = utils;\r\n","// StringBuf - a way to keep string memory operations to a minimum\r\n// while building the strings for the xml files\r\nclass StringBuf {\r\n  constructor(options) {\r\n    this._buf = Buffer.alloc((options && options.size) || 16384);\r\n    this._encoding = (options && options.encoding) || 'utf8';\r\n\r\n    // where in the buffer we are at\r\n    this._inPos = 0;\r\n\r\n    // for use by toBuffer()\r\n    this._buffer = undefined;\r\n  }\r\n\r\n  get length() {\r\n    return this._inPos;\r\n  }\r\n\r\n  get capacity() {\r\n    return this._buf.length;\r\n  }\r\n\r\n  get buffer() {\r\n    return this._buf;\r\n  }\r\n\r\n  toBuffer() {\r\n    // return the current data as a single enclosing buffer\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.alloc(this.length);\r\n      this._buf.copy(this._buffer, 0, 0, this.length);\r\n    }\r\n    return this._buffer;\r\n  }\r\n\r\n  reset(position) {\r\n    position = position || 0;\r\n    this._buffer = undefined;\r\n    this._inPos = position;\r\n  }\r\n\r\n  _grow(min) {\r\n    let size = this._buf.length * 2;\r\n    while (size < min) {\r\n      size *= 2;\r\n    }\r\n    const buf = Buffer.alloc(size);\r\n    this._buf.copy(buf, 0);\r\n    this._buf = buf;\r\n  }\r\n\r\n  addText(text) {\r\n    this._buffer = undefined;\r\n\r\n    let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\r\n\r\n    // if we've hit (or nearing capacity), grow the buf\r\n    while (inPos >= this._buf.length - 4) {\r\n      this._grow(this._inPos + text.length);\r\n\r\n      // keep trying to write until we've completely written the text\r\n      inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\r\n    }\r\n\r\n    this._inPos = inPos;\r\n  }\r\n\r\n  addStringBuf(inBuf) {\r\n    if (inBuf.length) {\r\n      this._buffer = undefined;\r\n\r\n      if (this.length + inBuf.length > this.capacity) {\r\n        this._grow(this.length + inBuf.length);\r\n      }\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);\r\n      this._inPos += inBuf.length;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = StringBuf;\r\n","// eslint-disable-next-line node/no-unsupported-features/node-builtins\r\nconst textEncoder = typeof TextEncoder === 'undefined' ? null : new TextEncoder('utf-8');\r\nconst {Buffer} = require('buffer');\r\n\r\nfunction stringToBuffer(str) {\r\n  if (typeof str !== 'string') {\r\n    return str;\r\n  }\r\n  if (textEncoder) {\r\n    return Buffer.from(textEncoder.encode(str).buffer);\r\n  }\r\n  return Buffer.from(str);\r\n}\r\n\r\nexports.stringToBuffer = stringToBuffer;\r\n","const _ = require('./under-dash');\r\n\r\nconst utils = require('./utils');\r\n\r\n// constants\r\nconst OPEN_ANGLE = '<';\r\nconst CLOSE_ANGLE = '>';\r\nconst OPEN_ANGLE_SLASH = '</';\r\nconst CLOSE_SLASH_ANGLE = '/>';\r\nconst EQUALS_QUOTE = '=\"';\r\nconst QUOTE = '\"';\r\nconst SPACE = ' ';\r\n\r\nfunction pushAttribute(xml, name, value) {\r\n  xml.push(SPACE);\r\n  xml.push(name);\r\n  xml.push(EQUALS_QUOTE);\r\n  xml.push(utils.xmlEncode(value.toString()));\r\n  xml.push(QUOTE);\r\n}\r\nfunction pushAttributes(xml, attributes) {\r\n  if (attributes) {\r\n    _.each(attributes, (value, name) => {\r\n      if (value !== undefined) {\r\n        pushAttribute(xml, name, value);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass XmlStream {\r\n  constructor() {\r\n    this._xml = [];\r\n    this._stack = [];\r\n    this._rollbacks = [];\r\n  }\r\n\r\n  get tos() {\r\n    return this._stack.length ? this._stack[this._stack.length - 1] : undefined;\r\n  }\r\n\r\n  get cursor() {\r\n    // handy way to track whether anything has been added\r\n    return this._xml.length;\r\n  }\r\n\r\n  openXml(docAttributes) {\r\n    const xml = this._xml;\r\n    // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    xml.push('<?xml');\r\n    pushAttributes(xml, docAttributes);\r\n    xml.push('?>\\n');\r\n  }\r\n\r\n  openNode(name, attributes) {\r\n    const parent = this.tos;\r\n    const xml = this._xml;\r\n    if (parent && this.open) {\r\n      xml.push(CLOSE_ANGLE);\r\n    }\r\n\r\n    this._stack.push(name);\r\n\r\n    // start streaming node\r\n    xml.push(OPEN_ANGLE);\r\n    xml.push(name);\r\n    pushAttributes(xml, attributes);\r\n    this.leaf = true;\r\n    this.open = true;\r\n  }\r\n\r\n  addAttribute(name, value) {\r\n    if (!this.open) {\r\n      throw new Error('Cannot write attributes to node if it is not open');\r\n    }\r\n    if (value !== undefined) {\r\n      pushAttribute(this._xml, name, value);\r\n    }\r\n  }\r\n\r\n  addAttributes(attrs) {\r\n    if (!this.open) {\r\n      throw new Error('Cannot write attributes to node if it is not open');\r\n    }\r\n    pushAttributes(this._xml, attrs);\r\n  }\r\n\r\n  writeText(text) {\r\n    const xml = this._xml;\r\n    if (this.open) {\r\n      xml.push(CLOSE_ANGLE);\r\n      this.open = false;\r\n    }\r\n    this.leaf = false;\r\n    xml.push(utils.xmlEncode(text.toString()));\r\n  }\r\n\r\n  writeXml(xml) {\r\n    if (this.open) {\r\n      this._xml.push(CLOSE_ANGLE);\r\n      this.open = false;\r\n    }\r\n    this.leaf = false;\r\n    this._xml.push(xml);\r\n  }\r\n\r\n  closeNode() {\r\n    const node = this._stack.pop();\r\n    const xml = this._xml;\r\n    if (this.leaf) {\r\n      xml.push(CLOSE_SLASH_ANGLE);\r\n    } else {\r\n      xml.push(OPEN_ANGLE_SLASH);\r\n      xml.push(node);\r\n      xml.push(CLOSE_ANGLE);\r\n    }\r\n    this.open = false;\r\n    this.leaf = false;\r\n  }\r\n\r\n  leafNode(name, attributes, text) {\r\n    this.openNode(name, attributes);\r\n    if (text !== undefined) {\r\n      // zeros need to be written\r\n      this.writeText(text);\r\n    }\r\n    this.closeNode();\r\n  }\r\n\r\n  closeAll() {\r\n    while (this._stack.length) {\r\n      this.closeNode();\r\n    }\r\n  }\r\n\r\n  addRollback() {\r\n    this._rollbacks.push({\r\n      xml: this._xml.length,\r\n      stack: this._stack.length,\r\n      leaf: this.leaf,\r\n      open: this.open,\r\n    });\r\n    return this.cursor;\r\n  }\r\n\r\n  commit() {\r\n    this._rollbacks.pop();\r\n  }\r\n\r\n  rollback() {\r\n    const r = this._rollbacks.pop();\r\n    if (this._xml.length > r.xml) {\r\n      this._xml.splice(r.xml, this._xml.length - r.xml);\r\n    }\r\n    if (this._stack.length > r.stack) {\r\n      this._stack.splice(r.stack, this._stack.length - r.stack);\r\n    }\r\n    this.leaf = r.leaf;\r\n    this.open = r.open;\r\n  }\r\n\r\n  get xml() {\r\n    this.closeAll();\r\n    return this._xml.join('');\r\n  }\r\n}\r\n\r\nXmlStream.StdDocAttributes = {\r\n  version: '1.0',\r\n  encoding: 'UTF-8',\r\n  standalone: 'yes',\r\n};\r\n\r\nmodule.exports = XmlStream;\r\n","// eslint-disable-next-line node/no-unsupported-features/node-builtins\r\nconst textDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\r\n\r\nfunction bufferToString(chunk) {\r\n  if (typeof chunk === 'string') {\r\n    return chunk;\r\n  }\r\n  if (textDecoder) {\r\n    return textDecoder.decode(chunk);\r\n  }\r\n  return chunk.toString();\r\n}\r\n\r\nexports.bufferToString = bufferToString;\r\n","/* eslint-disable max-classes-per-file */\r\nconst Enums = require('../../../doc/enums');\r\nconst XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst StaticXform = require('../static-xform');\r\nconst ListXform = require('../list-xform');\r\nconst FontXform = require('./font-xform');\r\nconst FillXform = require('./fill-xform');\r\nconst BorderXform = require('./border-xform');\r\nconst NumFmtXform = require('./numfmt-xform');\r\nconst StyleXform = require('./style-xform');\r\nconst DxfXform = require('./dxf-xform');\r\n\r\n// custom numfmt ids start here\r\nconst NUMFMT_BASE = 164;\r\n\r\n// =============================================================================\r\n// StylesXform is used to generate and parse the styles.xml file\r\n// it manages the collections of fonts, number formats, alignments, etc\r\nclass StylesXform extends BaseXform {\r\n  constructor(initialise) {\r\n    super();\r\n\r\n    this.map = {\r\n      numFmts: new ListXform({tag: 'numFmts', count: true, childXform: new NumFmtXform()}),\r\n      fonts: new ListXform({\r\n        tag: 'fonts',\r\n        count: true,\r\n        childXform: new FontXform(),\r\n        $: {'x14ac:knownFonts': 1},\r\n      }),\r\n      fills: new ListXform({tag: 'fills', count: true, childXform: new FillXform()}),\r\n      borders: new ListXform({tag: 'borders', count: true, childXform: new BorderXform()}),\r\n      cellStyleXfs: new ListXform({tag: 'cellStyleXfs', count: true, childXform: new StyleXform()}),\r\n      cellXfs: new ListXform({\r\n        tag: 'cellXfs',\r\n        count: true,\r\n        childXform: new StyleXform({xfId: true}),\r\n      }),\r\n      dxfs: new ListXform({tag: 'dxfs', always: true, count: true, childXform: new DxfXform()}),\r\n\r\n      // for style manager\r\n      numFmt: new NumFmtXform(),\r\n      font: new FontXform(),\r\n      fill: new FillXform(),\r\n      border: new BorderXform(),\r\n      style: new StyleXform({xfId: true}),\r\n\r\n      cellStyles: StylesXform.STATIC_XFORMS.cellStyles,\r\n      tableStyles: StylesXform.STATIC_XFORMS.tableStyles,\r\n      extLst: StylesXform.STATIC_XFORMS.extLst,\r\n    };\r\n\r\n    if (initialise) {\r\n      // StylesXform also acts as style manager and is used to build up styles-model during worksheet processing\r\n      this.init();\r\n    }\r\n  }\r\n\r\n  initIndex() {\r\n    this.index = {\r\n      style: {},\r\n      numFmt: {},\r\n      numFmtNextId: 164, // start custom format ids here\r\n      font: {},\r\n      border: {},\r\n      fill: {},\r\n    };\r\n  }\r\n\r\n  init() {\r\n    // Prepare for Style Manager role\r\n    this.model = {\r\n      styles: [],\r\n      numFmts: [],\r\n      fonts: [],\r\n      borders: [],\r\n      fills: [],\r\n      dxfs: [],\r\n    };\r\n\r\n    this.initIndex();\r\n\r\n    // default (zero) border\r\n    this._addBorder({});\r\n\r\n    // add default (all zero) style\r\n    this._addStyle({numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0});\r\n\r\n    // add default fills\r\n    this._addFill({type: 'pattern', pattern: 'none'});\r\n    this._addFill({type: 'pattern', pattern: 'gray125'});\r\n\r\n    this.weakMap = new WeakMap();\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this.model;\r\n    //\r\n    //   <fonts count=\"2\" x14ac:knownFonts=\"1\">\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n\r\n    xmlStream.openNode('styleSheet', StylesXform.STYLESHEET_ATTRIBUTES);\r\n\r\n    if (this.index) {\r\n      // model has been built by style manager role (contains xml)\r\n      if (model.numFmts && model.numFmts.length) {\r\n        xmlStream.openNode('numFmts', {count: model.numFmts.length});\r\n        model.numFmts.forEach(numFmtXml => {\r\n          xmlStream.writeXml(numFmtXml);\r\n        });\r\n        xmlStream.closeNode();\r\n      }\r\n\r\n      if (!model.fonts.length) {\r\n        // default (zero) font\r\n        this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});\r\n      }\r\n      xmlStream.openNode('fonts', {count: model.fonts.length, 'x14ac:knownFonts': 1});\r\n      model.fonts.forEach(fontXml => {\r\n        xmlStream.writeXml(fontXml);\r\n      });\r\n      xmlStream.closeNode();\r\n\r\n      xmlStream.openNode('fills', {count: model.fills.length});\r\n      model.fills.forEach(fillXml => {\r\n        xmlStream.writeXml(fillXml);\r\n      });\r\n      xmlStream.closeNode();\r\n\r\n      xmlStream.openNode('borders', {count: model.borders.length});\r\n      model.borders.forEach(borderXml => {\r\n        xmlStream.writeXml(borderXml);\r\n      });\r\n      xmlStream.closeNode();\r\n\r\n      this.map.cellStyleXfs.render(xmlStream, [\r\n        {numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0},\r\n      ]);\r\n\r\n      xmlStream.openNode('cellXfs', {count: model.styles.length});\r\n      model.styles.forEach(styleXml => {\r\n        xmlStream.writeXml(styleXml);\r\n      });\r\n      xmlStream.closeNode();\r\n    } else {\r\n      // model is plain JSON and needs to be xformed\r\n      this.map.numFmts.render(xmlStream, model.numFmts);\r\n      this.map.fonts.render(xmlStream, model.fonts);\r\n      this.map.fills.render(xmlStream, model.fills);\r\n      this.map.borders.render(xmlStream, model.borders);\r\n      this.map.cellStyleXfs.render(xmlStream, [\r\n        {numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0},\r\n      ]);\r\n      this.map.cellXfs.render(xmlStream, model.styles);\r\n    }\r\n\r\n    StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream);\r\n\r\n    this.map.dxfs.render(xmlStream, model.dxfs);\r\n\r\n    StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream);\r\n    StylesXform.STATIC_XFORMS.extLst.render(xmlStream);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'styleSheet':\r\n        this.initIndex();\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'styleSheet': {\r\n        this.model = {};\r\n        const add = (propName, xform) => {\r\n          if (xform.model && xform.model.length) {\r\n            this.model[propName] = xform.model;\r\n          }\r\n        };\r\n        add('numFmts', this.map.numFmts);\r\n        add('fonts', this.map.fonts);\r\n        add('fills', this.map.fills);\r\n        add('borders', this.map.borders);\r\n        add('styles', this.map.cellXfs);\r\n        add('dxfs', this.map.dxfs);\r\n\r\n        // index numFmts\r\n        this.index = {\r\n          model: [],\r\n          numFmt: [],\r\n        };\r\n        if (this.model.numFmts) {\r\n          const numFmtIndex = this.index.numFmt;\r\n          this.model.numFmts.forEach(numFmt => {\r\n            numFmtIndex[numFmt.id] = numFmt.formatCode;\r\n          });\r\n        }\r\n\r\n        return false;\r\n      }\r\n      default:\r\n        // not quite sure how we get here!\r\n        return true;\r\n    }\r\n  }\r\n\r\n  // add a cell's style model to the collection\r\n  // each style property is processed and cross-referenced, etc.\r\n  // the styleId is returned. Note: cellType is used when numFmt not defined\r\n  addStyleModel(model, cellType) {\r\n    if (!model) {\r\n      return 0;\r\n    }\r\n\r\n    // if we have no default font, add it here now\r\n    if (!this.model.fonts.length) {\r\n      // default (zero) font\r\n      this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});\r\n    }\r\n\r\n    // if we have seen this style object before, assume it has the same styleId\r\n    if (this.weakMap && this.weakMap.has(model)) {\r\n      return this.weakMap.get(model);\r\n    }\r\n\r\n    const style = {};\r\n    cellType = cellType || Enums.ValueType.Number;\r\n\r\n    if (model.numFmt) {\r\n      style.numFmtId = this._addNumFmtStr(model.numFmt);\r\n    } else {\r\n      switch (cellType) {\r\n        case Enums.ValueType.Number:\r\n          style.numFmtId = this._addNumFmtStr('General');\r\n          break;\r\n        case Enums.ValueType.Date:\r\n          style.numFmtId = this._addNumFmtStr('mm-dd-yy');\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (model.font) {\r\n      style.fontId = this._addFont(model.font);\r\n    }\r\n\r\n    if (model.border) {\r\n      style.borderId = this._addBorder(model.border);\r\n    }\r\n\r\n    if (model.fill) {\r\n      style.fillId = this._addFill(model.fill);\r\n    }\r\n\r\n    if (model.alignment) {\r\n      style.alignment = model.alignment;\r\n    }\r\n\r\n    if (model.protection) {\r\n      style.protection = model.protection;\r\n    }\r\n\r\n    const styleId = this._addStyle(style);\r\n    if (this.weakMap) {\r\n      this.weakMap.set(model, styleId);\r\n    }\r\n    return styleId;\r\n  }\r\n\r\n  // given a styleId (i.e. s=\"n\"), get the cell's style model\r\n  // objects are shared where possible.\r\n  getStyleModel(id) {\r\n    // if the style doesn't exist return null\r\n    const style = this.model.styles[id];\r\n    if (!style) return null;\r\n\r\n    // have we built this model before?\r\n    let model = this.index.model[id];\r\n    if (model) return model;\r\n\r\n    // build a new model\r\n    model = this.index.model[id] = {};\r\n\r\n    // -------------------------------------------------------\r\n    // number format\r\n    if (style.numFmtId) {\r\n      const numFmt =\r\n        this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);\r\n      if (numFmt) {\r\n        model.numFmt = numFmt;\r\n      }\r\n    }\r\n\r\n    function addStyle(name, group, styleId) {\r\n      if (styleId || styleId === 0) {\r\n        const part = group[styleId];\r\n        if (part) {\r\n          model[name] = part;\r\n        }\r\n      }\r\n    }\r\n\r\n    addStyle('font', this.model.fonts, style.fontId);\r\n    addStyle('border', this.model.borders, style.borderId);\r\n    addStyle('fill', this.model.fills, style.fillId);\r\n\r\n    // -------------------------------------------------------\r\n    // alignment\r\n    if (style.alignment) {\r\n      model.alignment = style.alignment;\r\n    }\r\n\r\n    // -------------------------------------------------------\r\n    // protection\r\n    if (style.protection) {\r\n      model.protection = style.protection;\r\n    }\r\n\r\n    return model;\r\n  }\r\n\r\n  addDxfStyle(style) {\r\n    this.model.dxfs.push(style);\r\n    return this.model.dxfs.length - 1;\r\n  }\r\n\r\n  getDxfStyle(id) {\r\n    return this.model.dxfs[id];\r\n  }\r\n\r\n  // =========================================================================\r\n  // Private Interface\r\n  _addStyle(style) {\r\n    const xml = this.map.style.toXml(style);\r\n    let index = this.index.style[xml];\r\n    if (index === undefined) {\r\n      index = this.index.style[xml] = this.model.styles.length;\r\n      this.model.styles.push(xml);\r\n    }\r\n    return index;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Number Formats\r\n  _addNumFmtStr(formatCode) {\r\n    // check if default format\r\n    let index = NumFmtXform.getDefaultFmtId(formatCode);\r\n    if (index !== undefined) return index;\r\n\r\n    // check if already in\r\n    index = this.index.numFmt[formatCode];\r\n    if (index !== undefined) return index;\r\n\r\n    index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;\r\n    const xml = this.map.numFmt.toXml({id: index, formatCode});\r\n    this.model.numFmts.push(xml);\r\n    return index;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Fonts\r\n  _addFont(font) {\r\n    const xml = this.map.font.toXml(font);\r\n    let index = this.index.font[xml];\r\n    if (index === undefined) {\r\n      index = this.index.font[xml] = this.model.fonts.length;\r\n      this.model.fonts.push(xml);\r\n    }\r\n    return index;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Borders\r\n  _addBorder(border) {\r\n    const xml = this.map.border.toXml(border);\r\n    let index = this.index.border[xml];\r\n    if (index === undefined) {\r\n      index = this.index.border[xml] = this.model.borders.length;\r\n      this.model.borders.push(xml);\r\n    }\r\n    return index;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Fills\r\n  _addFill(fill) {\r\n    const xml = this.map.fill.toXml(fill);\r\n    let index = this.index.fill[xml];\r\n    if (index === undefined) {\r\n      index = this.index.fill[xml] = this.model.fills.length;\r\n      this.model.fills.push(xml);\r\n    }\r\n    return index;\r\n  }\r\n\r\n  // =========================================================================\r\n}\r\n\r\nStylesXform.STYLESHEET_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\r\n  'mc:Ignorable': 'x14ac x16r2',\r\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',\r\n  'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',\r\n};\r\nStylesXform.STATIC_XFORMS = {\r\n  cellStyles: new StaticXform({\r\n    tag: 'cellStyles',\r\n    $: {count: 1},\r\n    c: [{tag: 'cellStyle', $: {name: 'Normal', xfId: 0, builtinId: 0}}],\r\n  }),\r\n  dxfs: new StaticXform({tag: 'dxfs', $: {count: 0}}),\r\n  tableStyles: new StaticXform({\r\n    tag: 'tableStyles',\r\n    $: {count: 0, defaultTableStyle: 'TableStyleMedium2', defaultPivotStyle: 'PivotStyleLight16'},\r\n  }),\r\n  extLst: new StaticXform({\r\n    tag: 'extLst',\r\n    c: [\r\n      {\r\n        tag: 'ext',\r\n        $: {\r\n          uri: '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}',\r\n          'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\r\n        },\r\n        c: [{tag: 'x14:slicerStyles', $: {defaultSlicerStyle: 'SlicerStyleLight1'}}],\r\n      },\r\n      {\r\n        tag: 'ext',\r\n        $: {\r\n          uri: '{9260A510-F301-46a8-8635-F512D64BE5F5}',\r\n          'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',\r\n        },\r\n        c: [{tag: 'x15:timelineStyles', $: {defaultTimelineStyle: 'TimeSlicerStyleLight1'}}],\r\n      },\r\n    ],\r\n  }),\r\n};\r\n\r\n// the stylemanager mock acts like StyleManager except that it always returns 0 or {}\r\nclass StylesXformMock extends StylesXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.model = {\r\n      styles: [{numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0}],\r\n      numFmts: [],\r\n      fonts: [{size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'}],\r\n      borders: [{}],\r\n      fills: [\r\n        {type: 'pattern', pattern: 'none'},\r\n        {type: 'pattern', pattern: 'gray125'},\r\n      ],\r\n    };\r\n  }\r\n\r\n  // =========================================================================\r\n  // Style Manager Interface\r\n\r\n  // override normal behaviour - consume and dispose\r\n  parseStream(stream) {\r\n    stream.autodrain();\r\n    return Promise.resolve();\r\n  }\r\n\r\n  // add a cell's style model to the collection\r\n  // each style property is processed and cross-referenced, etc.\r\n  // the styleId is returned. Note: cellType is used when numFmt not defined\r\n  addStyleModel(model, cellType) {\r\n    switch (cellType) {\r\n      case Enums.ValueType.Date:\r\n        return this.dateStyleId;\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  get dateStyleId() {\r\n    if (!this._dateStyleId) {\r\n      const dateStyle = {\r\n        numFmtId: NumFmtXform.getDefaultFmtId('mm-dd-yy'),\r\n      };\r\n      this._dateStyleId = this.model.styles.length;\r\n      this.model.styles.push(dateStyle);\r\n    }\r\n    return this._dateStyleId;\r\n  }\r\n\r\n  // given a styleId (i.e. s=\"n\"), get the cell's style model\r\n  // objects are shared where possible.\r\n  getStyleModel(/* id */) {\r\n    return {};\r\n  }\r\n}\r\n\r\nStylesXform.Mock = StylesXformMock;\r\n\r\nmodule.exports = StylesXform;\r\n","const parseSax = require('../../utils/parse-sax');\r\nconst XmlStream = require('../../utils/xml-stream');\r\n\r\n/* 'virtual' methods used as a form of documentation */\r\n/* eslint-disable class-methods-use-this */\r\n\r\n// Base class for Xforms\r\nclass BaseXform {\r\n  // constructor(/* model, name */) {}\r\n\r\n  // ============================================================\r\n  // Virtual Interface\r\n  prepare(/* model, options */) {\r\n    // optional preparation (mutation) of model so it is ready for write\r\n  }\r\n\r\n  render(/* xmlStream, model */) {\r\n    // convert model to xml\r\n  }\r\n\r\n  parseOpen(node) {\r\n    // XML node opened\r\n  }\r\n\r\n  parseText(text) {\r\n    // chunk of text encountered for current node\r\n  }\r\n\r\n  parseClose(name) {\r\n    // XML node closed\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    // optional post-parse step (opposite to prepare)\r\n  }\r\n\r\n  // ============================================================\r\n  reset() {\r\n    // to make sure parses don't bleed to next iteration\r\n    this.model = null;\r\n\r\n    // if we have a map - reset them too\r\n    if (this.map) {\r\n      Object.values(this.map).forEach(xform => {\r\n        if (xform instanceof BaseXform) {\r\n          xform.reset();\r\n        } else if (xform.xform) {\r\n          xform.xform.reset();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  mergeModel(obj) {\r\n    // set obj's props to this.model\r\n    this.model = Object.assign(this.model || {}, obj);\r\n  }\r\n\r\n  async parse(saxParser) {\r\n    for await (const events of saxParser) {\r\n      for (const {eventType, value} of events) {\r\n        if (eventType === 'opentag') {\r\n          this.parseOpen(value);\r\n        } else if (eventType === 'text') {\r\n          this.parseText(value);\r\n        } else if (eventType === 'closetag') {\r\n          if (!this.parseClose(value.name)) {\r\n            return this.model;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return this.model;\r\n  }\r\n\r\n  async parseStream(stream) {\r\n    return this.parse(parseSax(stream));\r\n  }\r\n\r\n  get xml() {\r\n    // convenience function to get the xml of this.model\r\n    // useful for manager types that are built during the prepare phase\r\n    return this.toXml(this.model);\r\n  }\r\n\r\n  toXml(model) {\r\n    const xmlStream = new XmlStream();\r\n    this.render(xmlStream, model);\r\n    return xmlStream.xml;\r\n  }\r\n\r\n  // ============================================================\r\n  // Useful Utilities\r\n  static toAttribute(value, dflt, always = false) {\r\n    if (value === undefined) {\r\n      if (always) {\r\n        return dflt;\r\n      }\r\n    } else if (always || value !== dflt) {\r\n      return value.toString();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  static toStringAttribute(value, dflt, always = false) {\r\n    return BaseXform.toAttribute(value, dflt, always);\r\n  }\r\n\r\n  static toStringValue(attr, dflt) {\r\n    return attr === undefined ? dflt : attr;\r\n  }\r\n\r\n  static toBoolAttribute(value, dflt, always = false) {\r\n    if (value === undefined) {\r\n      if (always) {\r\n        return dflt;\r\n      }\r\n    } else if (always || value !== dflt) {\r\n      return value ? '1' : '0';\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  static toBoolValue(attr, dflt) {\r\n    return attr === undefined ? dflt : attr === '1';\r\n  }\r\n\r\n  static toIntAttribute(value, dflt, always = false) {\r\n    return BaseXform.toAttribute(value, dflt, always);\r\n  }\r\n\r\n  static toIntValue(attr, dflt) {\r\n    return attr === undefined ? dflt : parseInt(attr, 10);\r\n  }\r\n\r\n  static toFloatAttribute(value, dflt, always = false) {\r\n    return BaseXform.toAttribute(value, dflt, always);\r\n  }\r\n\r\n  static toFloatValue(attr, dflt) {\r\n    return attr === undefined ? dflt : parseFloat(attr);\r\n  }\r\n}\r\n\r\nmodule.exports = BaseXform;\r\n","const {SaxesParser} = require('saxes');\r\nconst {PassThrough} = require('readable-stream');\r\nconst {bufferToString} = require('./browser-buffer-decode');\r\n\r\nmodule.exports = async function* (iterable) {\r\n  // TODO: Remove once node v8 is deprecated\r\n  // Detect and upgrade old streams\r\n  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {\r\n    iterable = iterable.pipe(new PassThrough());\r\n  }\r\n  const saxesParser = new SaxesParser();\r\n  let error;\r\n  saxesParser.on('error', err => {\r\n    error = err;\r\n  });\r\n  let events = [];\r\n  saxesParser.on('opentag', value => events.push({eventType: 'opentag', value}));\r\n  saxesParser.on('text', value => events.push({eventType: 'text', value}));\r\n  saxesParser.on('closetag', value => events.push({eventType: 'closetag', value}));\r\n  for await (const chunk of iterable) {\r\n    saxesParser.write(bufferToString(chunk));\r\n    // saxesParser.write and saxesParser.on() are synchronous,\r\n    // so we can only reach the below line once all events have been emitted\r\n    if (error) throw error;\r\n    // As a performance optimization, we gather all events instead of passing\r\n    // them one by one, which would cause each event to go through the event queue\r\n    yield events;\r\n    events = [];\r\n  }\r\n};\r\n","const BaseXform = require('./base-xform');\r\nconst XmlStream = require('../../utils/xml-stream');\r\n\r\n// const model = {\r\n//   tag: 'name',\r\n//   $: {attr: 'value'},\r\n//   c: [\r\n//     { tag: 'child' }\r\n//   ],\r\n//   t: 'some text'\r\n// };\r\n\r\nfunction build(xmlStream, model) {\r\n  xmlStream.openNode(model.tag, model.$);\r\n  if (model.c) {\r\n    model.c.forEach(child => {\r\n      build(xmlStream, child);\r\n    });\r\n  }\r\n  if (model.t) {\r\n    xmlStream.writeText(model.t);\r\n  }\r\n  xmlStream.closeNode();\r\n}\r\n\r\nclass StaticXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n\r\n    // This class is an optimisation for static (unimportant and unchanging) xml\r\n    // It is stateless - apart from its static model and so can be used as a singleton\r\n    // Being stateless - it will only track entry to and exit from it's root xml tag during parsing and nothing else\r\n    // Known issues:\r\n    //    since stateless - parseOpen always returns true. Parent xform must know when to start using this xform\r\n    //    if the root tag is recursive, the parsing will behave unpredictably\r\n    this._model = model;\r\n  }\r\n\r\n  render(xmlStream) {\r\n    if (!this._xml) {\r\n      const stream = new XmlStream();\r\n      build(stream, this._model);\r\n      this._xml = stream.xml;\r\n    }\r\n    xmlStream.writeXml(this._xml);\r\n  }\r\n\r\n  parseOpen() {\r\n    return true;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case this._model.tag:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = StaticXform;\r\n","const BaseXform = require('./base-xform');\r\n\r\nclass ListXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.always = !!options.always;\r\n    this.count = options.count;\r\n    this.empty = options.empty;\r\n    this.$count = options.$count || 'count';\r\n    this.$ = options.$;\r\n    this.childXform = options.childXform;\r\n    this.maxItems = options.maxItems;\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const {childXform} = this;\r\n    if (model) {\r\n      model.forEach((childModel, index) => {\r\n        options.index = index;\r\n        childXform.prepare(childModel, options);\r\n      });\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (this.always || (model && model.length)) {\r\n      xmlStream.openNode(this.tag, this.$);\r\n      if (this.count) {\r\n        xmlStream.addAttribute(this.$count, (model && model.length) || 0);\r\n      }\r\n\r\n      const {childXform} = this;\r\n      (model || []).forEach((childModel, index) => {\r\n        childXform.render(xmlStream, childModel, index);\r\n      });\r\n\r\n      xmlStream.closeNode();\r\n    } else if (this.empty) {\r\n      xmlStream.leafNode(this.tag);\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = [];\r\n        return true;\r\n      default:\r\n        if (this.childXform.parseOpen(node)) {\r\n          this.parser = this.childXform;\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.push(this.parser.model);\r\n        this.parser = undefined;\r\n\r\n        if (this.maxItems && this.model.length > this.maxItems) {\r\n          throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    if (model) {\r\n      const {childXform} = this;\r\n      model.forEach(childModel => {\r\n        childXform.reconcile(childModel, options);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = ListXform;\r\n","\r\n\r\nconst ColorXform = require('./color-xform');\r\nconst BooleanXform = require('../simple/boolean-xform');\r\nconst IntegerXform = require('../simple/integer-xform');\r\nconst StringXform = require('../simple/string-xform');\r\nconst UnderlineXform = require('./underline-xform');\r\n\r\nconst _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\n// Font encapsulates translation from font model to xlsx\r\nclass FontXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.options = options || FontXform.OPTIONS;\r\n\r\n    this.map = {\r\n      b: {prop: 'bold', xform: new BooleanXform({tag: 'b', attr: 'val'})},\r\n      i: {prop: 'italic', xform: new BooleanXform({tag: 'i', attr: 'val'})},\r\n      u: {prop: 'underline', xform: new UnderlineXform()},\r\n      charset: {prop: 'charset', xform: new IntegerXform({tag: 'charset', attr: 'val'})},\r\n      color: {prop: 'color', xform: new ColorXform()},\r\n      condense: {prop: 'condense', xform: new BooleanXform({tag: 'condense', attr: 'val'})},\r\n      extend: {prop: 'extend', xform: new BooleanXform({tag: 'extend', attr: 'val'})},\r\n      family: {prop: 'family', xform: new IntegerXform({tag: 'family', attr: 'val'})},\r\n      outline: {prop: 'outline', xform: new BooleanXform({tag: 'outline', attr: 'val'})},\r\n      vertAlign: {prop: 'vertAlign', xform: new StringXform({tag: 'vertAlign', attr: 'val'})},\r\n      scheme: {prop: 'scheme', xform: new StringXform({tag: 'scheme', attr: 'val'})},\r\n      shadow: {prop: 'shadow', xform: new BooleanXform({tag: 'shadow', attr: 'val'})},\r\n      strike: {prop: 'strike', xform: new BooleanXform({tag: 'strike', attr: 'val'})},\r\n      sz: {prop: 'size', xform: new IntegerXform({tag: 'sz', attr: 'val'})},\r\n    };\r\n    this.map[this.options.fontNameTag] = {\r\n      prop: 'name',\r\n      xform: new StringXform({tag: this.options.fontNameTag, attr: 'val'}),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return this.options.tagName;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const {map} = this;\r\n\r\n    xmlStream.openNode(this.options.tagName);\r\n    _.each(this.map, (defn, tag) => {\r\n      map[tag].xform.render(xmlStream, model[defn.prop]);\r\n    });\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (this.map[node.name]) {\r\n      this.parser = this.map[node.name].xform;\r\n      return this.parser.parseOpen(node);\r\n    }\r\n    switch (node.name) {\r\n      case this.options.tagName:\r\n        this.model = {};\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser && !this.parser.parseClose(name)) {\r\n      const item = this.map[name];\r\n      if (this.parser.model) {\r\n        this.model[item.prop] = this.parser.model;\r\n      }\r\n      this.parser = undefined;\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.options.tagName:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nFontXform.OPTIONS = {\r\n  tagName: 'font',\r\n  fontNameTag: 'name',\r\n};\r\n\r\nmodule.exports = FontXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\n// Color encapsulates translation from color model to/from xlsx\r\nclass ColorXform extends BaseXform {\r\n  constructor(name) {\r\n    super();\r\n\r\n    // this.name controls the xm node name\r\n    this.name = name || 'color';\r\n  }\r\n\r\n  get tag() {\r\n    return this.name;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.openNode(this.name);\r\n      if (model.argb) {\r\n        xmlStream.addAttribute('rgb', model.argb);\r\n      } else if (model.theme !== undefined) {\r\n        xmlStream.addAttribute('theme', model.theme);\r\n        if (model.tint !== undefined) {\r\n          xmlStream.addAttribute('tint', model.tint);\r\n        }\r\n      } else if (model.indexed !== undefined) {\r\n        xmlStream.addAttribute('indexed', model.indexed);\r\n      } else {\r\n        xmlStream.addAttribute('auto', '1');\r\n      }\r\n      xmlStream.closeNode();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.name) {\r\n      if (node.attributes.rgb) {\r\n        this.model = {argb: node.attributes.rgb};\r\n      } else if (node.attributes.theme) {\r\n        this.model = {theme: parseInt(node.attributes.theme, 10)};\r\n        if (node.attributes.tint) {\r\n          this.model.tint = parseFloat(node.attributes.tint);\r\n        }\r\n      } else if (node.attributes.indexed) {\r\n        this.model = {indexed: parseInt(node.attributes.indexed, 10)};\r\n      } else {\r\n        this.model = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = ColorXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass BooleanXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.attr = options.attr;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.openNode(this.tag);\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      this.model = true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = BooleanXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass IntegerXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.attr = options.attr;\r\n    this.attrs = options.attrs;\r\n\r\n    // option to render zero\r\n    this.zero = options.zero;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    // int is different to float in that zero is not rendered\r\n    if (model || this.zero) {\r\n      xmlStream.openNode(this.tag);\r\n      if (this.attrs) {\r\n        xmlStream.addAttributes(this.attrs);\r\n      }\r\n      if (this.attr) {\r\n        xmlStream.addAttribute(this.attr, model);\r\n      } else {\r\n        xmlStream.writeText(model);\r\n      }\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      if (this.attr) {\r\n        this.model = parseInt(node.attributes[this.attr], 10);\r\n      } else {\r\n        this.text = [];\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (!this.attr) {\r\n      this.text.push(text);\r\n    }\r\n  }\r\n\r\n  parseClose() {\r\n    if (!this.attr) {\r\n      this.model = parseInt(this.text.join('') || 0, 10);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = IntegerXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass StringXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.attr = options.attr;\r\n    this.attrs = options.attrs;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model !== undefined) {\r\n      xmlStream.openNode(this.tag);\r\n      if (this.attrs) {\r\n        xmlStream.addAttributes(this.attrs);\r\n      }\r\n      if (this.attr) {\r\n        xmlStream.addAttribute(this.attr, model);\r\n      } else {\r\n        xmlStream.writeText(model);\r\n      }\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      if (this.attr) {\r\n        this.model = node.attributes[this.attr];\r\n      } else {\r\n        this.text = [];\r\n      }\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (!this.attr) {\r\n      this.text.push(text);\r\n    }\r\n  }\r\n\r\n  parseClose() {\r\n    if (!this.attr) {\r\n      this.model = this.text.join('');\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = StringXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass UnderlineXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n\r\n    this.model = model;\r\n  }\r\n\r\n  get tag() {\r\n    return 'u';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this.model;\r\n\r\n    if (model === true) {\r\n      xmlStream.leafNode('u');\r\n    } else {\r\n      const attr = UnderlineXform.Attributes[model];\r\n      if (attr) {\r\n        xmlStream.leafNode('u', attr);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'u') {\r\n      this.model = node.attributes.val || true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nUnderlineXform.Attributes = {\r\n  single: {},\r\n  double: {val: 'double'},\r\n  singleAccounting: {val: 'singleAccounting'},\r\n  doubleAccounting: {val: 'doubleAccounting'},\r\n};\r\n\r\nmodule.exports = UnderlineXform;\r\n","/* eslint-disable max-classes-per-file */\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst ColorXform = require('./color-xform');\r\n\r\nclass StopXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      color: new ColorXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'stop';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('stop');\r\n    xmlStream.addAttribute('position', model.position);\r\n    this.map.color.render(xmlStream, model.color);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'stop':\r\n        this.model = {\r\n          position: parseFloat(node.attributes.position),\r\n        };\r\n        return true;\r\n      case 'color':\r\n        this.parser = this.map.color;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.color = this.parser.model;\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nclass PatternFillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      fgColor: new ColorXform('fgColor'),\r\n      bgColor: new ColorXform('bgColor'),\r\n    };\r\n  }\r\n\r\n  get name() {\r\n    return 'pattern';\r\n  }\r\n\r\n  get tag() {\r\n    return 'patternFill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('patternFill');\r\n    xmlStream.addAttribute('patternType', model.pattern);\r\n    if (model.fgColor) {\r\n      this.map.fgColor.render(xmlStream, model.fgColor);\r\n    }\r\n    if (model.bgColor) {\r\n      this.map.bgColor.render(xmlStream, model.bgColor);\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'patternFill':\r\n        this.model = {\r\n          type: 'pattern',\r\n          pattern: node.attributes.patternType,\r\n        };\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        if (this.parser.model) {\r\n          this.model[name] = this.parser.model;\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nclass GradientFillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      stop: new StopXform(),\r\n    };\r\n    // if (model) {\r\n    //   this.gradient = model.gradient;\r\n    //   if (model.center) {\r\n    //     this.center = model.center;\r\n    //   }\r\n    //   if (model.degree !== undefined) {\r\n    //     this.degree = model.degree;\r\n    //   }\r\n    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });\r\n    // } else {\r\n    //   this.stops = [];\r\n    // }\r\n  }\r\n\r\n  get name() {\r\n    return 'gradient';\r\n  }\r\n\r\n  get tag() {\r\n    return 'gradientFill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('gradientFill');\r\n    switch (model.gradient) {\r\n      case 'angle':\r\n        xmlStream.addAttribute('degree', model.degree);\r\n        break;\r\n      case 'path':\r\n        xmlStream.addAttribute('type', 'path');\r\n        if (model.center.left) {\r\n          xmlStream.addAttribute('left', model.center.left);\r\n          if (model.center.right === undefined) {\r\n            xmlStream.addAttribute('right', model.center.left);\r\n          }\r\n        }\r\n        if (model.center.right) {\r\n          xmlStream.addAttribute('right', model.center.right);\r\n        }\r\n        if (model.center.top) {\r\n          xmlStream.addAttribute('top', model.center.top);\r\n          if (model.center.bottom === undefined) {\r\n            xmlStream.addAttribute('bottom', model.center.top);\r\n          }\r\n        }\r\n        if (model.center.bottom) {\r\n          xmlStream.addAttribute('bottom', model.center.bottom);\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    const stopXform = this.map.stop;\r\n    model.stops.forEach(stopModel => {\r\n      stopXform.render(xmlStream, stopModel);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'gradientFill': {\r\n        const model = (this.model = {\r\n          stops: [],\r\n        });\r\n        if (node.attributes.degree) {\r\n          model.gradient = 'angle';\r\n          model.degree = parseInt(node.attributes.degree, 10);\r\n        } else if (node.attributes.type === 'path') {\r\n          model.gradient = 'path';\r\n          model.center = {\r\n            left: node.attributes.left ? parseFloat(node.attributes.left) : 0,\r\n            top: node.attributes.top ? parseFloat(node.attributes.top) : 0,\r\n          };\r\n          if (node.attributes.right !== node.attributes.left) {\r\n            model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;\r\n          }\r\n          if (node.attributes.bottom !== node.attributes.top) {\r\n            model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n\r\n      case 'stop':\r\n        this.parser = this.map.stop;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.stops.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// Fill encapsulates translation from fill model to/from xlsx\r\nclass FillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      patternFill: new PatternFillXform(),\r\n      gradientFill: new GradientFillXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'fill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.addRollback();\r\n    xmlStream.openNode('fill');\r\n    switch (model.type) {\r\n      case 'pattern':\r\n        this.map.patternFill.render(xmlStream, model);\r\n        break;\r\n      case 'gradient':\r\n        this.map.gradientFill.render(xmlStream, model);\r\n        break;\r\n      default:\r\n        xmlStream.rollback();\r\n        return;\r\n    }\r\n    xmlStream.closeNode();\r\n    xmlStream.commit();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'fill':\r\n        this.model = {};\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model = this.parser.model;\r\n        this.model.type = this.parser.name;\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  validStyle(value) {\r\n    return FillXform.validPatternValues[value];\r\n  }\r\n}\r\n\r\nFillXform.validPatternValues = [\r\n  'none',\r\n  'solid',\r\n  'darkVertical',\r\n  'darkGray',\r\n  'mediumGray',\r\n  'lightGray',\r\n  'gray125',\r\n  'gray0625',\r\n  'darkHorizontal',\r\n  'darkVertical',\r\n  'darkDown',\r\n  'darkUp',\r\n  'darkGrid',\r\n  'darkTrellis',\r\n  'lightHorizontal',\r\n  'lightVertical',\r\n  'lightDown',\r\n  'lightUp',\r\n  'lightGrid',\r\n  'lightTrellis',\r\n  'lightGrid',\r\n].reduce((p, v) => {\r\n  p[v] = true;\r\n  return p;\r\n}, {});\r\n\r\nFillXform.StopXform = StopXform;\r\nFillXform.PatternFillXform = PatternFillXform;\r\nFillXform.GradientFillXform = GradientFillXform;\r\n\r\nmodule.exports = FillXform;\r\n","/* eslint-disable max-classes-per-file */\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst ColorXform = require('./color-xform');\r\n\r\nclass EdgeXform extends BaseXform {\r\n  constructor(name) {\r\n    super();\r\n\r\n    this.name = name;\r\n    this.map = {\r\n      color: new ColorXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return this.name;\r\n  }\r\n\r\n  render(xmlStream, model, defaultColor) {\r\n    const color = (model && model.color) || defaultColor || this.defaultColor;\r\n    xmlStream.openNode(this.name);\r\n    if (model && model.style) {\r\n      xmlStream.addAttribute('style', model.style);\r\n      if (color) {\r\n        this.map.color.render(xmlStream, color);\r\n      }\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.name: {\r\n        const {style} = node.attributes;\r\n        if (style) {\r\n          this.model = {\r\n            style,\r\n          };\r\n        } else {\r\n          this.model = undefined;\r\n        }\r\n        return true;\r\n      }\r\n      case 'color':\r\n        this.parser = this.map.color;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    if (name === this.name) {\r\n      if (this.map.color.model) {\r\n        if (!this.model) {\r\n          this.model = {};\r\n        }\r\n        this.model.color = this.map.color.model;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  validStyle(value) {\r\n    return EdgeXform.validStyleValues[value];\r\n  }\r\n}\r\n\r\nEdgeXform.validStyleValues = [\r\n  'thin',\r\n  'dotted',\r\n  'dashDot',\r\n  'hair',\r\n  'dashDotDot',\r\n  'slantDashDot',\r\n  'mediumDashed',\r\n  'mediumDashDotDot',\r\n  'mediumDashDot',\r\n  'medium',\r\n  'double',\r\n  'thick',\r\n].reduce((p, v) => {\r\n  p[v] = true;\r\n  return p;\r\n}, {});\r\n\r\n// Border encapsulates translation from border model to/from xlsx\r\nclass BorderXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      top: new EdgeXform('top'),\r\n      left: new EdgeXform('left'),\r\n      bottom: new EdgeXform('bottom'),\r\n      right: new EdgeXform('right'),\r\n      diagonal: new EdgeXform('diagonal'),\r\n    };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const {color} = model;\r\n    xmlStream.openNode('border');\r\n    if (model.diagonal && model.diagonal.style) {\r\n      if (model.diagonal.up) {\r\n        xmlStream.addAttribute('diagonalUp', '1');\r\n      }\r\n      if (model.diagonal.down) {\r\n        xmlStream.addAttribute('diagonalDown', '1');\r\n      }\r\n    }\r\n    function add(edgeModel, edgeXform) {\r\n      if (edgeModel && !edgeModel.color && model.color) {\r\n        // don't mess with incoming models\r\n        edgeModel = {\r\n          ...edgeModel,\r\n          color: model.color,\r\n        };\r\n      }\r\n      edgeXform.render(xmlStream, edgeModel, color);\r\n    }\r\n    add(model.left, this.map.left);\r\n    add(model.right, this.map.right);\r\n    add(model.top, this.map.top);\r\n    add(model.bottom, this.map.bottom);\r\n    add(model.diagonal, this.map.diagonal);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'border':\r\n        this.reset();\r\n        this.diagonalUp = !!node.attributes.diagonalUp;\r\n        this.diagonalDown = !!node.attributes.diagonalDown;\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    if (name === 'border') {\r\n      const model = (this.model = {});\r\n      const add = function(key, edgeModel, extensions) {\r\n        if (edgeModel) {\r\n          if (extensions) {\r\n            Object.assign(edgeModel, extensions);\r\n          }\r\n          model[key] = edgeModel;\r\n        }\r\n      };\r\n      add('left', this.map.left.model);\r\n      add('right', this.map.right.model);\r\n      add('top', this.map.top.model);\r\n      add('bottom', this.map.bottom.model);\r\n      add('diagonal', this.map.diagonal.model, {up: this.diagonalUp, down: this.diagonalDown});\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = BorderXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst defaultNumFormats = require('../../defaultnumformats');\r\n\r\nconst BaseXform = require('../base-xform');\r\n\r\nfunction hashDefaultFormats() {\r\n  const hash = {};\r\n  _.each(defaultNumFormats, (dnf, id) => {\r\n    if (dnf.f) {\r\n      hash[dnf.f] = parseInt(id, 10);\r\n    }\r\n    // at some point, add the other cultures here...\r\n  });\r\n  return hash;\r\n}\r\nconst defaultFmtHash = hashDefaultFormats();\r\n\r\n// NumFmt encapsulates translation between number format and xlsx\r\nclass NumFmtXform extends BaseXform {\r\n  constructor(id, formatCode) {\r\n    super();\r\n\r\n    this.id = id;\r\n    this.formatCode = formatCode;\r\n  }\r\n\r\n  get tag() {\r\n    return 'numFmt';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('numFmt', {numFmtId: model.id, formatCode: model.formatCode});\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'numFmt':\r\n        this.model = {\r\n          id: parseInt(node.attributes.numFmtId, 10),\r\n          formatCode: node.attributes.formatCode.replace(/[\\\\](.)/g, '$1'),\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nNumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {\r\n  return defaultFmtHash[formatCode];\r\n};\r\n\r\nNumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {\r\n  return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;\r\n};\r\n\r\nmodule.exports = NumFmtXform;\r\n","module.exports = {\r\n  0: {f: 'General'},\r\n  1: {f: '0'},\r\n  2: {f: '0.00'},\r\n  3: {f: '#,##0'},\r\n  4: {f: '#,##0.00'},\r\n  9: {f: '0%'},\r\n  10: {f: '0.00%'},\r\n  11: {f: '0.00E+00'},\r\n  12: {f: '# ?/?'},\r\n  13: {f: '# ??/??'},\r\n  14: {f: 'mm-dd-yy'},\r\n  15: {f: 'd-mmm-yy'},\r\n  16: {f: 'd-mmm'},\r\n  17: {f: 'mmm-yy'},\r\n  18: {f: 'h:mm AM/PM'},\r\n  19: {f: 'h:mm:ss AM/PM'},\r\n  20: {f: 'h:mm'},\r\n  21: {f: 'h:mm:ss'},\r\n  22: {f: 'm/d/yy \"h\":mm'},\r\n\r\n  27: {\r\n    'zh-tw': '[$-404]e/m/d',\r\n    'zh-cn': 'yyyy\"\"m\"\"',\r\n    'ja-jp': '[$-411]ge.m.d',\r\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\r\n  },\r\n  28: {\r\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\r\n    'ko-kr': 'mm-dd',\r\n  },\r\n  29: {\r\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\r\n    'ko-kr': 'mm-dd',\r\n  },\r\n  30: {'zh-tw': 'm/d/yy ', 'zh-cn': 'm-d-yy', 'ja-jp': 'm/d/yy', 'ko-kr': 'mm-dd-yy'},\r\n  31: {\r\n    'zh-tw': 'yyyy\"\"m\"\"d\"\"',\r\n    'zh-cn': 'yyyy\"\"m\"\"d\"\"',\r\n    'ja-jp': 'yyyy\"\"m\"\"d\"\"',\r\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\r\n  },\r\n  32: {\r\n    'zh-tw': 'hh\"\"mm\"\"',\r\n    'zh-cn': 'h\"\"mm\"\"',\r\n    'ja-jp': 'h\"\"mm\"\"',\r\n    'ko-kr': 'h\"\" mm\"\"',\r\n  },\r\n  33: {\r\n    'zh-tw': 'hh\"\"mm\"\"ss\"\"',\r\n    'zh-cn': 'h\"\"mm\"\"ss\"\"',\r\n    'ja-jp': 'h\"\"mm\"\"ss\"\"',\r\n    'ko-kr': 'h\"\" mm\"\" ss\"\"',\r\n  },\r\n  34: {\r\n    'zh-tw': '/ hh\"\"mm\"\"',\r\n    'zh-cn': '/ h\"\"mm\"\"',\r\n    'ja-jp': 'yyyy\"\"m\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  35: {\r\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\r\n    'zh-cn': '/ h\"\"mm\"\"ss\"\"',\r\n    'ja-jp': 'm\"\"d\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  36: {\r\n    'zh-tw': '[$-404]e/m/d',\r\n    'zh-cn': 'yyyy\"\"m\"\"',\r\n    'ja-jp': '[$-411]ge.m.d',\r\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\r\n  },\r\n\r\n  37: {f: '#,##0 ;(#,##0)'},\r\n  38: {f: '#,##0 ;[Red](#,##0)'},\r\n  39: {f: '#,##0.00 ;(#,##0.00)'},\r\n  40: {f: '#,##0.00 ;[Red](#,##0.00)'},\r\n  45: {f: 'mm:ss'},\r\n  46: {f: '[h]:mm:ss'},\r\n  47: {f: 'mmss.0'},\r\n  48: {f: '##0.0E+0'},\r\n  49: {f: '@'},\r\n\r\n  50: {\r\n    'zh-tw': '[$-404]e/m/d',\r\n    'zh-cn': 'yyyy\"\"m\"\"',\r\n    'ja-jp': '[$-411]ge.m.d',\r\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\r\n  },\r\n  51: {\r\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\r\n    'ko-kr': 'mm-dd',\r\n  },\r\n  52: {\r\n    'zh-tw': '/ hh\"\"mm\"\"',\r\n    'zh-cn': 'yyyy\"\"m\"\"',\r\n    'ja-jp': 'yyyy\"\"m\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  53: {\r\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': 'm\"\"d\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  54: {\r\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\r\n    'ko-kr': 'mm-dd',\r\n  },\r\n  55: {\r\n    'zh-tw': '/ hh\"\"mm\"\"',\r\n    'zh-cn': '/ h\"\"mm\"\"',\r\n    'ja-jp': 'yyyy\"\"m\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  56: {\r\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\r\n    'zh-cn': '/ h\"\"mm\"\"ss\"\"',\r\n    'ja-jp': 'm\"\"d\"\"',\r\n    'ko-kr': 'yyyy-mm-dd',\r\n  },\r\n  57: {\r\n    'zh-tw': '[$-404]e/m/d',\r\n    'zh-cn': 'yyyy\"\"m\"\"',\r\n    'ja-jp': '[$-411]ge.m.d',\r\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\r\n  },\r\n  58: {\r\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\r\n    'zh-cn': 'm\"\"d\"\"',\r\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\r\n    'ko-kr': 'mm-dd',\r\n  },\r\n\r\n  59: {'th-th': 't0'},\r\n  60: {'th-th': 't0.00'},\r\n  61: {'th-th': 't#,##0'},\r\n  62: {'th-th': 't#,##0.00'},\r\n  67: {'th-th': 't0%'},\r\n  68: {'th-th': 't0.00%'},\r\n  69: {'th-th': 't# ?/?'},\r\n  70: {'th-th': 't# ??/??'},\r\n\r\n  81: {'th-th': 'd/m/bb'},\r\n};\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst AlignmentXform = require('./alignment-xform');\r\nconst ProtectionXform = require('./protection-xform');\r\n\r\n// <xf numFmtId=\"[numFmtId]\" fontId=\"[fontId]\" fillId=\"[fillId]\" borderId=\"[xf.borderId]\" xfId=\"[xfId]\">\r\n//   Optional <alignment>\r\n//   Optional <protection>\r\n// </xf>\r\n\r\n// Style assists translation from style model to/from xlsx\r\nclass StyleXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.xfId = !!(options && options.xfId);\r\n    this.map = {\r\n      alignment: new AlignmentXform(),\r\n      protection: new ProtectionXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xf';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('xf', {\r\n      numFmtId: model.numFmtId || 0,\r\n      fontId: model.fontId || 0,\r\n      fillId: model.fillId || 0,\r\n      borderId: model.borderId || 0,\r\n    });\r\n    if (this.xfId) {\r\n      xmlStream.addAttribute('xfId', model.xfId || 0);\r\n    }\r\n\r\n    if (model.numFmtId) {\r\n      xmlStream.addAttribute('applyNumberFormat', '1');\r\n    }\r\n    if (model.fontId) {\r\n      xmlStream.addAttribute('applyFont', '1');\r\n    }\r\n    if (model.fillId) {\r\n      xmlStream.addAttribute('applyFill', '1');\r\n    }\r\n    if (model.borderId) {\r\n      xmlStream.addAttribute('applyBorder', '1');\r\n    }\r\n    if (model.alignment) {\r\n      xmlStream.addAttribute('applyAlignment', '1');\r\n    }\r\n    if (model.protection) {\r\n      xmlStream.addAttribute('applyProtection', '1');\r\n    }\r\n\r\n    /**\r\n     * Rendering tags causes close of XML stream.\r\n     * Therefore adding attributes must be done before rendering tags.\r\n     */\r\n\r\n    if (model.alignment) {\r\n      this.map.alignment.render(xmlStream, model.alignment);\r\n    }\r\n    if (model.protection) {\r\n      this.map.protection.render(xmlStream, model.protection);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    // used during sax parsing of xml to build font object\r\n    switch (node.name) {\r\n      case 'xf':\r\n        this.model = {\r\n          numFmtId: parseInt(node.attributes.numFmtId, 10),\r\n          fontId: parseInt(node.attributes.fontId, 10),\r\n          fillId: parseInt(node.attributes.fillId, 10),\r\n          borderId: parseInt(node.attributes.borderId, 10),\r\n        };\r\n        if (this.xfId) {\r\n          this.model.xfId = parseInt(node.attributes.xfId, 10);\r\n        }\r\n        return true;\r\n      case 'alignment':\r\n        this.parser = this.map.alignment;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      case 'protection':\r\n        this.parser = this.map.protection;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        if (this.map.protection === this.parser) {\r\n          this.model.protection = this.parser.model;\r\n        } else {\r\n          this.model.alignment = this.parser.model;\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return name !== 'xf';\r\n  }\r\n}\r\n\r\nmodule.exports = StyleXform;\r\n","const Enums = require('../../../doc/enums');\r\n\r\nconst utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst validation = {\r\n  horizontalValues: [\r\n    'left',\r\n    'center',\r\n    'right',\r\n    'fill',\r\n    'centerContinuous',\r\n    'distributed',\r\n    'justify',\r\n  ].reduce((p, v) => {\r\n    p[v] = true;\r\n    return p;\r\n  }, {}),\r\n  horizontal(value) {\r\n    return this.horizontalValues[value] ? value : undefined;\r\n  },\r\n\r\n  verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce((p, v) => {\r\n    p[v] = true;\r\n    return p;\r\n  }, {}),\r\n  vertical(value) {\r\n    if (value === 'middle') return 'center';\r\n    return this.verticalValues[value] ? value : undefined;\r\n  },\r\n  wrapText(value) {\r\n    return value ? true : undefined;\r\n  },\r\n  shrinkToFit(value) {\r\n    return value ? true : undefined;\r\n  },\r\n  textRotation(value) {\r\n    switch (value) {\r\n      case 'vertical':\r\n        return value;\r\n      default:\r\n        value = utils.validInt(value);\r\n        return value >= -90 && value <= 90 ? value : undefined;\r\n    }\r\n  },\r\n  indent(value) {\r\n    value = utils.validInt(value);\r\n    return Math.max(0, value);\r\n  },\r\n  readingOrder(value) {\r\n    switch (value) {\r\n      case 'ltr':\r\n        return Enums.ReadingOrder.LeftToRight;\r\n      case 'rtl':\r\n        return Enums.ReadingOrder.RightToLeft;\r\n      default:\r\n        return undefined;\r\n    }\r\n  },\r\n};\r\n\r\nconst textRotationXform = {\r\n  toXml(textRotation) {\r\n    textRotation = validation.textRotation(textRotation);\r\n    if (textRotation) {\r\n      if (textRotation === 'vertical') {\r\n        return 255;\r\n      }\r\n\r\n      const tr = Math.round(textRotation);\r\n      if (tr >= 0 && tr <= 90) {\r\n        return tr;\r\n      }\r\n\r\n      if (tr < 0 && tr >= -90) {\r\n        return 90 - tr;\r\n      }\r\n    }\r\n    return undefined;\r\n  },\r\n  toModel(textRotation) {\r\n    const tr = utils.validInt(textRotation);\r\n    if (tr !== undefined) {\r\n      if (tr === 255) {\r\n        return 'vertical';\r\n      }\r\n      if (tr >= 0 && tr <= 90) {\r\n        return tr;\r\n      }\r\n      if (tr > 90 && tr <= 180) {\r\n        return 90 - tr;\r\n      }\r\n    }\r\n    return undefined;\r\n  },\r\n};\r\n\r\n// Alignment encapsulates translation from style.alignment model to/from xlsx\r\nclass AlignmentXform extends BaseXform {\r\n  get tag() {\r\n    return 'alignment';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.addRollback();\r\n    xmlStream.openNode('alignment');\r\n\r\n    let isValid = false;\r\n    function add(name, value) {\r\n      if (value) {\r\n        xmlStream.addAttribute(name, value);\r\n        isValid = true;\r\n      }\r\n    }\r\n    add('horizontal', validation.horizontal(model.horizontal));\r\n    add('vertical', validation.vertical(model.vertical));\r\n    add('wrapText', validation.wrapText(model.wrapText) ? '1' : false);\r\n    add('shrinkToFit', validation.shrinkToFit(model.shrinkToFit) ? '1' : false);\r\n    add('indent', validation.indent(model.indent));\r\n    add('textRotation', textRotationXform.toXml(model.textRotation));\r\n    add('readingOrder', validation.readingOrder(model.readingOrder));\r\n\r\n    xmlStream.closeNode();\r\n\r\n    if (isValid) {\r\n      xmlStream.commit();\r\n    } else {\r\n      xmlStream.rollback();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    const model = {};\r\n\r\n    let valid = false;\r\n    function add(truthy, name, value) {\r\n      if (truthy) {\r\n        model[name] = value;\r\n        valid = true;\r\n      }\r\n    }\r\n    add(node.attributes.horizontal, 'horizontal', node.attributes.horizontal);\r\n    add(\r\n      node.attributes.vertical,\r\n      'vertical',\r\n      node.attributes.vertical === 'center' ? 'middle' : node.attributes.vertical\r\n    );\r\n    add(node.attributes.wrapText, 'wrapText', !!node.attributes.wrapText);\r\n    add(node.attributes.shrinkToFit, 'shrinkToFit', !!node.attributes.shrinkToFit);\r\n    add(node.attributes.indent, 'indent', parseInt(node.attributes.indent, 10));\r\n    add(\r\n      node.attributes.textRotation,\r\n      'textRotation',\r\n      textRotationXform.toModel(node.attributes.textRotation)\r\n    );\r\n    add(\r\n      node.attributes.readingOrder,\r\n      'readingOrder',\r\n      node.attributes.readingOrder === '2' ? 'rtl' : 'ltr'\r\n    );\r\n\r\n    this.model = valid ? model : null;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = AlignmentXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst validation = {\r\n  boolean(value, dflt) {\r\n    if (value === undefined) {\r\n      return dflt;\r\n    }\r\n    return value;\r\n  },\r\n};\r\n\r\n// Protection encapsulates translation from style.protection model to/from xlsx\r\nclass ProtectionXform extends BaseXform {\r\n  get tag() {\r\n    return 'protection';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.addRollback();\r\n    xmlStream.openNode('protection');\r\n\r\n    let isValid = false;\r\n    function add(name, value) {\r\n      if (value !== undefined) {\r\n        xmlStream.addAttribute(name, value);\r\n        isValid = true;\r\n      }\r\n    }\r\n    add('locked', validation.boolean(model.locked, true) ? undefined : '0');\r\n    add('hidden', validation.boolean(model.hidden, false) ? '1' : undefined);\r\n\r\n    xmlStream.closeNode();\r\n\r\n    if (isValid) {\r\n      xmlStream.commit();\r\n    } else {\r\n      xmlStream.rollback();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    const model = {\r\n      locked: !(node.attributes.locked === '0'),\r\n      hidden: node.attributes.hidden === '1',\r\n    };\r\n\r\n    // only want to record models that differ from defaults\r\n    const isSignificant = !model.locked || model.hidden;\r\n\r\n    this.model = isSignificant ? model : null;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = ProtectionXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst AlignmentXform = require('./alignment-xform');\r\nconst BorderXform = require('./border-xform');\r\nconst FillXform = require('./fill-xform');\r\nconst FontXform = require('./font-xform');\r\nconst NumFmtXform = require('./numfmt-xform');\r\nconst ProtectionXform = require('./protection-xform');\r\n\r\n// <xf numFmtId=\"[numFmtId]\" fontId=\"[fontId]\" fillId=\"[fillId]\" borderId=\"[xf.borderId]\" xfId=\"[xfId]\">\r\n//   Optional <alignment>\r\n//   Optional <protection>\r\n// </xf>\r\n\r\n// Style assists translation from style model to/from xlsx\r\nclass DxfXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      alignment: new AlignmentXform(),\r\n      border: new BorderXform(),\r\n      fill: new FillXform(),\r\n      font: new FontXform(),\r\n      numFmt: new NumFmtXform(),\r\n      protection: new ProtectionXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'dxf';\r\n  }\r\n\r\n  // how do we generate dxfid?\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    if (model.font) {\r\n      this.map.font.render(xmlStream, model.font);\r\n    }\r\n    if (model.numFmt) {\r\n      this.map.numFmt.render(xmlStream, model.numFmt);\r\n    }\r\n    if (model.fill) {\r\n      this.map.fill.render(xmlStream, model.fill);\r\n    }\r\n    if (model.alignment) {\r\n      this.map.alignment.render(xmlStream, model.alignment);\r\n    }\r\n    if (model.border) {\r\n      this.map.border.render(xmlStream, model.border);\r\n    }\r\n    if (model.protection) {\r\n      this.map.protection.render(xmlStream, model.protection);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case this.tag:\r\n        // this node is often repeated. Need to reset children\r\n        this.reset();\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    if (name === this.tag) {\r\n      this.model = {\r\n        alignment: this.map.alignment.model,\r\n        border: this.map.border.model,\r\n        fill: this.map.fill.model,\r\n        font: this.map.font.model,\r\n        numFmt: this.map.numFmt.model,\r\n        protection: this.map.protection.model,\r\n      };\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nmodule.exports = DxfXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\nconst BaseXform = require('../base-xform');\r\nconst DateXform = require('../simple/date-xform');\r\nconst StringXform = require('../simple/string-xform');\r\nconst IntegerXform = require('../simple/integer-xform');\r\n\r\nclass CoreXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'dc:creator': new StringXform({tag: 'dc:creator'}),\r\n      'dc:title': new StringXform({tag: 'dc:title'}),\r\n      'dc:subject': new StringXform({tag: 'dc:subject'}),\r\n      'dc:description': new StringXform({tag: 'dc:description'}),\r\n      'dc:identifier': new StringXform({tag: 'dc:identifier'}),\r\n      'dc:language': new StringXform({tag: 'dc:language'}),\r\n      'cp:keywords': new StringXform({tag: 'cp:keywords'}),\r\n      'cp:category': new StringXform({tag: 'cp:category'}),\r\n      'cp:lastModifiedBy': new StringXform({tag: 'cp:lastModifiedBy'}),\r\n      'cp:lastPrinted': new DateXform({tag: 'cp:lastPrinted', format: CoreXform.DateFormat}),\r\n      'cp:revision': new IntegerXform({tag: 'cp:revision'}),\r\n      'cp:version': new StringXform({tag: 'cp:version'}),\r\n      'cp:contentStatus': new StringXform({tag: 'cp:contentStatus'}),\r\n      'cp:contentType': new StringXform({tag: 'cp:contentType'}),\r\n      'dcterms:created': new DateXform({\r\n        tag: 'dcterms:created',\r\n        attrs: CoreXform.DateAttrs,\r\n        format: CoreXform.DateFormat,\r\n      }),\r\n      'dcterms:modified': new DateXform({\r\n        tag: 'dcterms:modified',\r\n        attrs: CoreXform.DateAttrs,\r\n        format: CoreXform.DateFormat,\r\n      }),\r\n    };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n\r\n    xmlStream.openNode('cp:coreProperties', CoreXform.CORE_PROPERTY_ATTRIBUTES);\r\n\r\n    this.map['dc:creator'].render(xmlStream, model.creator);\r\n    this.map['dc:title'].render(xmlStream, model.title);\r\n    this.map['dc:subject'].render(xmlStream, model.subject);\r\n    this.map['dc:description'].render(xmlStream, model.description);\r\n    this.map['dc:identifier'].render(xmlStream, model.identifier);\r\n    this.map['dc:language'].render(xmlStream, model.language);\r\n    this.map['cp:keywords'].render(xmlStream, model.keywords);\r\n    this.map['cp:category'].render(xmlStream, model.category);\r\n    this.map['cp:lastModifiedBy'].render(xmlStream, model.lastModifiedBy);\r\n    this.map['cp:lastPrinted'].render(xmlStream, model.lastPrinted);\r\n    this.map['cp:revision'].render(xmlStream, model.revision);\r\n    this.map['cp:version'].render(xmlStream, model.version);\r\n    this.map['cp:contentStatus'].render(xmlStream, model.contentStatus);\r\n    this.map['cp:contentType'].render(xmlStream, model.contentType);\r\n    this.map['dcterms:created'].render(xmlStream, model.created);\r\n    this.map['dcterms:modified'].render(xmlStream, model.modified);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'cp:coreProperties':\r\n      case 'coreProperties':\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'cp:coreProperties':\r\n      case 'coreProperties':\r\n        this.model = {\r\n          creator: this.map['dc:creator'].model,\r\n          title: this.map['dc:title'].model,\r\n          subject: this.map['dc:subject'].model,\r\n          description: this.map['dc:description'].model,\r\n          identifier: this.map['dc:identifier'].model,\r\n          language: this.map['dc:language'].model,\r\n          keywords: this.map['cp:keywords'].model,\r\n          category: this.map['cp:category'].model,\r\n          lastModifiedBy: this.map['cp:lastModifiedBy'].model,\r\n          lastPrinted: this.map['cp:lastPrinted'].model,\r\n          revision: this.map['cp:revision'].model,\r\n          contentStatus: this.map['cp:contentStatus'].model,\r\n          contentType: this.map['cp:contentType'].model,\r\n          created: this.map['dcterms:created'].model,\r\n          modified: this.map['dcterms:modified'].model,\r\n        };\r\n        return false;\r\n      default:\r\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\r\n    }\r\n  }\r\n}\r\n\r\nCoreXform.DateFormat = function(dt) {\r\n  return dt.toISOString().replace(/[.]\\d{3}/, '');\r\n};\r\nCoreXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};\r\n\r\nCoreXform.CORE_PROPERTY_ATTRIBUTES = {\r\n  'xmlns:cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',\r\n  'xmlns:dc': 'http://purl.org/dc/elements/1.1/',\r\n  'xmlns:dcterms': 'http://purl.org/dc/terms/',\r\n  'xmlns:dcmitype': 'http://purl.org/dc/dcmitype/',\r\n  'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\r\n};\r\n\r\nmodule.exports = CoreXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass DateXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.attr = options.attr;\r\n    this.attrs = options.attrs;\r\n    this._format =\r\n      options.format ||\r\n      function(dt) {\r\n        try {\r\n          if (Number.isNaN(dt.getTime())) return '';\r\n          return dt.toISOString();\r\n        } catch (e) {\r\n          return '';\r\n        }\r\n      };\r\n    this._parse =\r\n      options.parse ||\r\n      function(str) {\r\n        return new Date(str);\r\n      };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.openNode(this.tag);\r\n      if (this.attrs) {\r\n        xmlStream.addAttributes(this.attrs);\r\n      }\r\n      if (this.attr) {\r\n        xmlStream.addAttribute(this.attr, this._format(model));\r\n      } else {\r\n        xmlStream.writeText(this._format(model));\r\n      }\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      if (this.attr) {\r\n        this.model = this._parse(node.attributes[this.attr]);\r\n      } else {\r\n        this.text = [];\r\n      }\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (!this.attr) {\r\n      this.text.push(text);\r\n    }\r\n  }\r\n\r\n  parseClose() {\r\n    if (!this.attr) {\r\n      this.model = this._parse(this.text.join(''));\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = DateXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\nconst BaseXform = require('../base-xform');\r\nconst SharedStringXform = require('./shared-string-xform');\r\n\r\nclass SharedStringsXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n\r\n    this.model = model || {\r\n      values: [],\r\n      count: 0,\r\n    };\r\n    this.hash = Object.create(null);\r\n    this.rich = Object.create(null);\r\n  }\r\n\r\n  get sharedStringXform() {\r\n    return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());\r\n  }\r\n\r\n  get values() {\r\n    return this.model.values;\r\n  }\r\n\r\n  get uniqueCount() {\r\n    return this.model.values.length;\r\n  }\r\n\r\n  get count() {\r\n    return this.model.count;\r\n  }\r\n\r\n  getString(index) {\r\n    return this.model.values[index];\r\n  }\r\n\r\n  add(value) {\r\n    return value.richText ? this.addRichText(value) : this.addText(value);\r\n  }\r\n\r\n  addText(value) {\r\n    let index = this.hash[value];\r\n    if (index === undefined) {\r\n      index = this.hash[value] = this.model.values.length;\r\n      this.model.values.push(value);\r\n    }\r\n    this.model.count++;\r\n    return index;\r\n  }\r\n\r\n  addRichText(value) {\r\n    // TODO: add WeakMap here\r\n    const xml = this.sharedStringXform.toXml(value);\r\n    let index = this.rich[xml];\r\n    if (index === undefined) {\r\n      index = this.rich[xml] = this.model.values.length;\r\n      this.model.values.push(value);\r\n    }\r\n    this.model.count++;\r\n    return index;\r\n  }\r\n\r\n  // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n  // <sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"<%=totalRefs%>\" uniqueCount=\"<%=count%>\">\r\n  //   <si><t><%=text%></t></si>\r\n  //   <si><r><rPr></rPr><t></t></r></si>\r\n  // </sst>\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this._values;\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n\r\n    xmlStream.openNode('sst', {\r\n      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n      count: model.count,\r\n      uniqueCount: model.values.length,\r\n    });\r\n\r\n    const sx = this.sharedStringXform;\r\n    model.values.forEach(sharedString => {\r\n      sx.render(xmlStream, sharedString);\r\n    });\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'sst':\r\n        return true;\r\n      case 'si':\r\n        this.parser = this.sharedStringXform;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.values.push(this.parser.model);\r\n        this.model.count++;\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'sst':\r\n        return false;\r\n      default:\r\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = SharedStringsXform;\r\n","const TextXform = require('./text-xform');\r\nconst RichTextXform = require('./rich-text-xform');\r\nconst PhoneticTextXform = require('./phonetic-text-xform');\r\n\r\nconst BaseXform = require('../base-xform');\r\n\r\n// <si>\r\n//   <r></r><r></r>...\r\n// </si>\r\n// <si>\r\n//   <t></t>\r\n// </si>\r\n\r\nclass SharedStringXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n\r\n    this.model = model;\r\n\r\n    this.map = {\r\n      r: new RichTextXform(),\r\n      t: new TextXform(),\r\n      rPh: new PhoneticTextXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'si';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n    if (model && model.hasOwnProperty('richText') && model.richText) {\r\n      if (model.richText.length) {\r\n        model.richText.forEach(text => {\r\n          this.map.r.render(xmlStream, text);\r\n        });\r\n      } else {\r\n        this.map.t.render(xmlStream, '');\r\n      }\r\n    } else if (model !== undefined && model !== null) {\r\n      this.map.t.render(xmlStream, model);\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    const {name} = node;\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (name === this.tag) {\r\n      this.model = {};\r\n      return true;\r\n    }\r\n    this.parser = this.map[name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        switch (name) {\r\n          case 'r': {\r\n            let rt = this.model.richText;\r\n            if (!rt) {\r\n              rt = this.model.richText = [];\r\n            }\r\n            rt.push(this.parser.model);\r\n            break;\r\n          }\r\n          case 't':\r\n            this.model = this.parser.model;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = SharedStringXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\n//   <t xml:space=\"preserve\"> is </t>\r\n\r\nclass TextXform extends BaseXform {\r\n  get tag() {\r\n    return 't';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('t');\r\n    if (/^\\s|\\n|\\s$/.test(model)) {\r\n      xmlStream.addAttribute('xml:space', 'preserve');\r\n    }\r\n    xmlStream.writeText(model);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  get model() {\r\n    return this._text\r\n      .join('')\r\n      .replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 't':\r\n        this._text = [];\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this._text.push(text);\r\n  }\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = TextXform;\r\n","const TextXform = require('./text-xform');\r\nconst FontXform = require('../style/font-xform');\r\n\r\nconst BaseXform = require('../base-xform');\r\n\r\n// <r>\r\n//   <rPr>\r\n//     <sz val=\"11\"/>\r\n//     <color theme=\"1\" tint=\"5\"/>\r\n//     <rFont val=\"Calibri\"/>\r\n//     <family val=\"2\"/>\r\n//     <scheme val=\"minor\"/>\r\n//   </rPr>\r\n//   <t xml:space=\"preserve\"> is </t>\r\n// </r>\r\n\r\nclass RichTextXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n\r\n    this.model = model;\r\n  }\r\n\r\n  get tag() {\r\n    return 'r';\r\n  }\r\n\r\n  get textXform() {\r\n    return this._textXform || (this._textXform = new TextXform());\r\n  }\r\n\r\n  get fontXform() {\r\n    return this._fontXform || (this._fontXform = new FontXform(RichTextXform.FONT_OPTIONS));\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this.model;\r\n\r\n    xmlStream.openNode('r');\r\n    if (model.font) {\r\n      this.fontXform.render(xmlStream, model.font);\r\n    }\r\n    this.textXform.render(xmlStream, model.text);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'r':\r\n        this.model = {};\r\n        return true;\r\n      case 't':\r\n        this.parser = this.textXform;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      case 'rPr':\r\n        this.parser = this.fontXform;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case 'r':\r\n        return false;\r\n      case 't':\r\n        this.model.text = this.parser.model;\r\n        this.parser = undefined;\r\n        return true;\r\n      case 'rPr':\r\n        this.model.font = this.parser.model;\r\n        this.parser = undefined;\r\n        return true;\r\n      default:\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n        }\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nRichTextXform.FONT_OPTIONS = {\r\n  tagName: 'rPr',\r\n  fontNameTag: 'rFont',\r\n};\r\n\r\nmodule.exports = RichTextXform;\r\n","const TextXform = require('./text-xform');\r\nconst RichTextXform = require('./rich-text-xform');\r\n\r\nconst BaseXform = require('../base-xform');\r\n\r\n// <rPh sb=\"0\" eb=\"1\">\r\n//   <t>(its pronounciation in KATAKANA)</t>\r\n// </rPh>\r\n\r\nclass PhoneticTextXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      r: new RichTextXform(),\r\n      t: new TextXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'rPh';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      sb: model.sb || 0,\r\n      eb: model.eb || 0,\r\n    });\r\n    if (model && model.hasOwnProperty('richText') && model.richText) {\r\n      const {r} = this.map;\r\n      model.richText.forEach(text => {\r\n        r.render(xmlStream, text);\r\n      });\r\n    } else if (model) {\r\n      this.map.t.render(xmlStream, model.text);\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    const {name} = node;\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (name === this.tag) {\r\n      this.model = {\r\n        sb: parseInt(node.attributes.sb, 10),\r\n        eb: parseInt(node.attributes.eb, 10),\r\n      };\r\n      return true;\r\n    }\r\n    this.parser = this.map[name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        switch (name) {\r\n          case 'r': {\r\n            let rt = this.model.richText;\r\n            if (!rt) {\r\n              rt = this.model.richText = [];\r\n            }\r\n            rt.push(this.parser.model);\r\n            break;\r\n          }\r\n          case 't':\r\n            this.model.text = this.parser.model;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = PhoneticTextXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst RelationshipXform = require('./relationship-xform');\r\n\r\nclass RelationshipsXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      Relationship: new RelationshipXform(),\r\n    };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this._values;\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode('Relationships', RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);\r\n\r\n    model.forEach(relationship => {\r\n      this.map.Relationship.render(xmlStream, relationship);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'Relationships':\r\n        this.model = [];\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'Relationships':\r\n        return false;\r\n      default:\r\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\r\n    }\r\n  }\r\n}\r\n\r\nRelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',\r\n};\r\n\r\nmodule.exports = RelationshipsXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass RelationshipXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('Relationship', model);\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'Relationship':\r\n        this.model = node.attributes;\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = RelationshipXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\n\r\n// used for rendering the [Content_Types].xml file\r\n// not used for parsing\r\nclass ContentTypesXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n\r\n    xmlStream.openNode('Types', ContentTypesXform.PROPERTY_ATTRIBUTES);\r\n\r\n    const mediaHash = {};\r\n    (model.media || []).forEach(medium => {\r\n      if (medium.type === 'image') {\r\n        const imageType = medium.extension;\r\n        if (!mediaHash[imageType]) {\r\n          mediaHash[imageType] = true;\r\n          xmlStream.leafNode('Default', {Extension: imageType, ContentType: `image/${imageType}`});\r\n        }\r\n      }\r\n    });\r\n\r\n    xmlStream.leafNode('Default', {\r\n      Extension: 'rels',\r\n      ContentType: 'application/vnd.openxmlformats-package.relationships+xml',\r\n    });\r\n    xmlStream.leafNode('Default', {Extension: 'xml', ContentType: 'application/xml'});\r\n\r\n    xmlStream.leafNode('Override', {\r\n      PartName: '/xl/workbook.xml',\r\n      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',\r\n    });\r\n\r\n    model.worksheets.forEach(worksheet => {\r\n      const name = `/xl/worksheets/sheet${worksheet.id}.xml`;\r\n      xmlStream.leafNode('Override', {\r\n        PartName: name,\r\n        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',\r\n      });\r\n    });\r\n\r\n    xmlStream.leafNode('Override', {\r\n      PartName: '/xl/theme/theme1.xml',\r\n      ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',\r\n    });\r\n    xmlStream.leafNode('Override', {\r\n      PartName: '/xl/styles.xml',\r\n      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',\r\n    });\r\n\r\n    const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;\r\n    if (hasSharedStrings) {\r\n      xmlStream.leafNode('Override', {\r\n        PartName: '/xl/sharedStrings.xml',\r\n        ContentType:\r\n          'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',\r\n      });\r\n    }\r\n\r\n    if (model.tables) {\r\n      model.tables.forEach(table => {\r\n        xmlStream.leafNode('Override', {\r\n          PartName: `/xl/tables/${table.target}`,\r\n          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',\r\n        });\r\n      });\r\n    }\r\n\r\n    if (model.drawings) {\r\n      model.drawings.forEach(drawing => {\r\n        xmlStream.leafNode('Override', {\r\n          PartName: `/xl/drawings/${drawing.name}.xml`,\r\n          ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',\r\n        });\r\n      });\r\n    }\r\n\r\n    if (model.commentRefs) {\r\n      xmlStream.leafNode('Default', {\r\n        Extension: 'vml',\r\n        ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',\r\n      });\r\n\r\n      model.commentRefs.forEach(({commentName}) => {\r\n        xmlStream.leafNode('Override', {\r\n          PartName: `/xl/${commentName}.xml`,\r\n          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',\r\n        });\r\n      });\r\n    }\r\n\r\n    xmlStream.leafNode('Override', {\r\n      PartName: '/docProps/core.xml',\r\n      ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',\r\n    });\r\n    xmlStream.leafNode('Override', {\r\n      PartName: '/docProps/app.xml',\r\n      ContentType: 'application/vnd.openxmlformats-officedocument.extended-properties+xml',\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen() {\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nContentTypesXform.PROPERTY_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',\r\n};\r\n\r\nmodule.exports = ContentTypesXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\nconst BaseXform = require('../base-xform');\r\nconst StringXform = require('../simple/string-xform');\r\n\r\nconst AppHeadingPairsXform = require('./app-heading-pairs-xform');\r\nconst AppTitleOfPartsXform = require('./app-titles-of-parts-xform');\r\n\r\nclass AppXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      Company: new StringXform({tag: 'Company'}),\r\n      Manager: new StringXform({tag: 'Manager'}),\r\n      HeadingPairs: new AppHeadingPairsXform(),\r\n      TitleOfParts: new AppTitleOfPartsXform(),\r\n    };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n\r\n    xmlStream.openNode('Properties', AppXform.PROPERTY_ATTRIBUTES);\r\n\r\n    xmlStream.leafNode('Application', undefined, 'Microsoft Excel');\r\n    xmlStream.leafNode('DocSecurity', undefined, '0');\r\n    xmlStream.leafNode('ScaleCrop', undefined, 'false');\r\n\r\n    this.map.HeadingPairs.render(xmlStream, model.worksheets);\r\n    this.map.TitleOfParts.render(xmlStream, model.worksheets);\r\n    this.map.Company.render(xmlStream, model.company || '');\r\n    this.map.Manager.render(xmlStream, model.manager);\r\n\r\n    xmlStream.leafNode('LinksUpToDate', undefined, 'false');\r\n    xmlStream.leafNode('SharedDoc', undefined, 'false');\r\n    xmlStream.leafNode('HyperlinksChanged', undefined, 'false');\r\n    xmlStream.leafNode('AppVersion', undefined, '16.0300');\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'Properties':\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n\r\n        // there's a lot we don't bother to parse\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'Properties':\r\n        this.model = {\r\n          worksheets: this.map.TitleOfParts.model,\r\n          company: this.map.Company.model,\r\n          manager: this.map.Manager.model,\r\n        };\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nAppXform.DateFormat = function(dt) {\r\n  return dt.toISOString().replace(/[.]\\d{3,6}/, '');\r\n};\r\n\r\nAppXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};\r\n\r\nAppXform.PROPERTY_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',\r\n  'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',\r\n};\r\n\r\nmodule.exports = AppXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass AppHeadingPairsXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('HeadingPairs');\r\n    xmlStream.openNode('vt:vector', {size: 2, baseType: 'variant'});\r\n\r\n    xmlStream.openNode('vt:variant');\r\n    xmlStream.leafNode('vt:lpstr', undefined, 'Worksheets');\r\n    xmlStream.closeNode();\r\n\r\n    xmlStream.openNode('vt:variant');\r\n    xmlStream.leafNode('vt:i4', undefined, model.length);\r\n    xmlStream.closeNode();\r\n\r\n    xmlStream.closeNode();\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    // no parsing\r\n    return node.name === 'HeadingPairs';\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    return name !== 'HeadingPairs';\r\n  }\r\n}\r\n\r\nmodule.exports = AppHeadingPairsXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass AppTitlesOfPartsXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('TitlesOfParts');\r\n    xmlStream.openNode('vt:vector', {size: model.length, baseType: 'lpstr'});\r\n\r\n    model.forEach(sheet => {\r\n      xmlStream.leafNode('vt:lpstr', undefined, sheet.name);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    // no parsing\r\n    return node.name === 'TitlesOfParts';\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    return name !== 'TitlesOfParts';\r\n  }\r\n}\r\n\r\nmodule.exports = AppTitlesOfPartsXform;\r\n","const _ = require('../../../utils/under-dash');\r\n\r\nconst colCache = require('../../../utils/col-cache');\r\nconst XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst StaticXform = require('../static-xform');\r\nconst ListXform = require('../list-xform');\r\nconst DefinedNameXform = require('./defined-name-xform');\r\nconst SheetXform = require('./sheet-xform');\r\nconst WorkbookViewXform = require('./workbook-view-xform');\r\nconst WorkbookPropertiesXform = require('./workbook-properties-xform');\r\nconst WorkbookCalcPropertiesXform = require('./workbook-calc-properties-xform');\r\n\r\nclass WorkbookXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,\r\n      workbookPr: new WorkbookPropertiesXform(),\r\n      bookViews: new ListXform({\r\n        tag: 'bookViews',\r\n        count: false,\r\n        childXform: new WorkbookViewXform(),\r\n      }),\r\n      sheets: new ListXform({tag: 'sheets', count: false, childXform: new SheetXform()}),\r\n      definedNames: new ListXform({\r\n        tag: 'definedNames',\r\n        count: false,\r\n        childXform: new DefinedNameXform(),\r\n      }),\r\n      calcPr: new WorkbookCalcPropertiesXform(),\r\n    };\r\n  }\r\n\r\n  prepare(model) {\r\n    model.sheets = model.worksheets;\r\n\r\n    // collate all the print areas from all of the sheets and add them to the defined names\r\n    const printAreas = [];\r\n    let index = 0; // sheets is sparse array - calc index manually\r\n    model.sheets.forEach(sheet => {\r\n      if (sheet.pageSetup && sheet.pageSetup.printArea) {\r\n        sheet.pageSetup.printArea.split('&&').forEach(printArea => {\r\n          const printAreaComponents = printArea.split(':');\r\n          const definedName = {\r\n            name: '_xlnm.Print_Area',\r\n            ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],\r\n            localSheetId: index,\r\n          };\r\n          printAreas.push(definedName);\r\n        });\r\n      }\r\n\r\n      if (\r\n        sheet.pageSetup &&\r\n        (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)\r\n      ) {\r\n        const ranges = [];\r\n\r\n        if (sheet.pageSetup.printTitlesColumn) {\r\n          const titlesColumns = sheet.pageSetup.printTitlesColumn.split(':');\r\n          ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);\r\n        }\r\n\r\n        if (sheet.pageSetup.printTitlesRow) {\r\n          const titlesRows = sheet.pageSetup.printTitlesRow.split(':');\r\n          ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);\r\n        }\r\n\r\n        const definedName = {\r\n          name: '_xlnm.Print_Titles',\r\n          ranges,\r\n          localSheetId: index,\r\n        };\r\n\r\n        printAreas.push(definedName);\r\n      }\r\n      index++;\r\n    });\r\n    if (printAreas.length) {\r\n      model.definedNames = model.definedNames.concat(printAreas);\r\n    }\r\n\r\n    (model.media || []).forEach((medium, i) => {\r\n      // assign name\r\n      medium.name = medium.type + (i + 1);\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode('workbook', WorkbookXform.WORKBOOK_ATTRIBUTES);\r\n\r\n    this.map.fileVersion.render(xmlStream);\r\n    this.map.workbookPr.render(xmlStream, model.properties);\r\n    this.map.bookViews.render(xmlStream, model.views);\r\n    this.map.sheets.render(xmlStream, model.sheets);\r\n    this.map.definedNames.render(xmlStream, model.definedNames);\r\n    this.map.calcPr.render(xmlStream, model.calcProperties);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'workbook':\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'workbook':\r\n        this.model = {\r\n          sheets: this.map.sheets.model,\r\n          properties: this.map.workbookPr.model || {},\r\n          views: this.map.bookViews.model,\r\n          calcProperties: {},\r\n        };\r\n        if (this.map.definedNames.model) {\r\n          this.model.definedNames = this.map.definedNames.model;\r\n        }\r\n\r\n        return false;\r\n      default:\r\n        // not quite sure how we get here!\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model) {\r\n    const rels = (model.workbookRels || []).reduce((map, rel) => {\r\n      map[rel.Id] = rel;\r\n      return map;\r\n    }, {});\r\n\r\n    // reconcile sheet ids, rIds and names\r\n    const worksheets = [];\r\n    let worksheet;\r\n    let index = 0;\r\n\r\n    (model.sheets || []).forEach(sheet => {\r\n      const rel = rels[sheet.rId];\r\n      if (!rel) {\r\n        return;\r\n      }\r\n      // if rel.Target start with `[space]/xl/` or `/xl/` , then it will be replaced with `''` and spliced behind `xl/`,\r\n      // otherwise it will be spliced directly behind `xl/`. i.g.\r\n      worksheet = model.worksheetHash[`xl/${rel.Target.replace(/^(\\s|\\/xl\\/)+/, '')}`];\r\n      // If there are \"chartsheets\" in the file, rel.Target will\r\n      // come out as chartsheets/sheet1.xml or similar here, and\r\n      // that won't be in model.worksheetHash.\r\n      // As we don't have the infrastructure to support chartsheets,\r\n      // we will ignore them for now:\r\n      if (worksheet) {\r\n        worksheet.name = sheet.name;\r\n        worksheet.id = sheet.id;\r\n        worksheet.state = sheet.state;\r\n        worksheets[index++] = worksheet;\r\n      }\r\n    });\r\n\r\n    // reconcile print areas\r\n    const definedNames = [];\r\n    _.each(model.definedNames, definedName => {\r\n      if (definedName.name === '_xlnm.Print_Area') {\r\n        worksheet = worksheets[definedName.localSheetId];\r\n        if (worksheet) {\r\n          if (!worksheet.pageSetup) {\r\n            worksheet.pageSetup = {};\r\n          }\r\n          const range = colCache.decodeEx(definedName.ranges[0]);\r\n          worksheet.pageSetup.printArea = worksheet.pageSetup.printArea\r\n            ? `${worksheet.pageSetup.printArea}&&${range.dimensions}`\r\n            : range.dimensions;\r\n        }\r\n      } else if (definedName.name === '_xlnm.Print_Titles') {\r\n        worksheet = worksheets[definedName.localSheetId];\r\n        if (worksheet) {\r\n          if (!worksheet.pageSetup) {\r\n            worksheet.pageSetup = {};\r\n          }\r\n\r\n          const rangeString = definedName.ranges.join(',');\r\n\r\n          const dollarRegex = /\\$/g;\r\n\r\n          const rowRangeRegex = /\\$\\d+:\\$\\d+/;\r\n          const rowRangeMatches = rangeString.match(rowRangeRegex);\r\n\r\n          if (rowRangeMatches && rowRangeMatches.length) {\r\n            const range = rowRangeMatches[0];\r\n            worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, '');\r\n          }\r\n\r\n          const columnRangeRegex = /\\$[A-Z]+:\\$[A-Z]+/;\r\n          const columnRangeMatches = rangeString.match(columnRangeRegex);\r\n\r\n          if (columnRangeMatches && columnRangeMatches.length) {\r\n            const range = columnRangeMatches[0];\r\n            worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, '');\r\n          }\r\n        }\r\n      } else {\r\n        definedNames.push(definedName);\r\n      }\r\n    });\r\n    model.definedNames = definedNames;\r\n\r\n    // used by sheets to build their image models\r\n    model.media.forEach((media, i) => {\r\n      media.index = i;\r\n    });\r\n  }\r\n}\r\n\r\nWorkbookXform.WORKBOOK_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\r\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\r\n  'mc:Ignorable': 'x15',\r\n  'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',\r\n};\r\nWorkbookXform.STATIC_XFORMS = {\r\n  fileVersion: new StaticXform({\r\n    tag: 'fileVersion',\r\n    $: {appName: 'xl', lastEdited: 5, lowestEdited: 5, rupBuild: 9303},\r\n  }),\r\n};\r\n\r\nmodule.exports = WorkbookXform;\r\n","const BaseXform = require('../base-xform');\r\nconst colCache = require('../../../utils/col-cache');\r\n\r\nclass DefinedNamesXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    // <definedNames>\r\n    //   <definedName name=\"name\">name.ranges.join(',')</definedName>\r\n    //   <definedName name=\"_xlnm.Print_Area\" localSheetId=\"0\">name.ranges.join(',')</definedName>\r\n    // </definedNames>\r\n    xmlStream.openNode('definedName', {\r\n      name: model.name,\r\n      localSheetId: model.localSheetId,\r\n    });\r\n    xmlStream.writeText(model.ranges.join(','));\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'definedName':\r\n        this._parsedName = node.attributes.name;\r\n        this._parsedLocalSheetId = node.attributes.localSheetId;\r\n        this._parsedText = [];\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this._parsedText.push(text);\r\n  }\r\n\r\n  parseClose() {\r\n    this.model = {\r\n      name: this._parsedName,\r\n      ranges: extractRanges(this._parsedText.join('')),\r\n    };\r\n    if (this._parsedLocalSheetId !== undefined) {\r\n      this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isValidRange(range) {\r\n  try {\r\n    colCache.decodeEx(range);\r\n    return true;\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction extractRanges(parsedText) {\r\n  const ranges = [];\r\n  let quotesOpened = false;\r\n  let last = '';\r\n  parsedText.split(',').forEach(item => {\r\n    if (!item) {\r\n      return;\r\n    }\r\n    const quotes = (item.match(/'/g) || []).length;\r\n\r\n    if (!quotes) {\r\n      if (quotesOpened) {\r\n        last += `${item},`;\r\n      } else if (isValidRange(item)) {\r\n        ranges.push(item);\r\n      }\r\n      return;\r\n    }\r\n    const quotesEven = quotes % 2 === 0;\r\n\r\n    if (!quotesOpened && quotesEven && isValidRange(item)) {\r\n      ranges.push(item);\r\n    } else if (quotesOpened && !quotesEven) {\r\n      quotesOpened = false;\r\n      if (isValidRange(last + item)) {\r\n        ranges.push(last + item);\r\n      }\r\n      last = '';\r\n    } else {\r\n      quotesOpened = true;\r\n      last += `${item},`;\r\n    }\r\n  });\r\n  return ranges;\r\n}\r\n\r\nmodule.exports = DefinedNamesXform;\r\n","const utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\n\r\nclass WorksheetXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('sheet', {\r\n      sheetId: model.id,\r\n      name: model.name,\r\n      state: model.state,\r\n      'r:id': model.rId,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'sheet') {\r\n      this.model = {\r\n        name: utils.xmlDecode(node.attributes.name),\r\n        id: parseInt(node.attributes.sheetId, 10),\r\n        state: node.attributes.state,\r\n        rId: node.attributes['r:id'],\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = WorksheetXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass WorkbookViewXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    const attributes = {\r\n      xWindow: model.x || 0,\r\n      yWindow: model.y || 0,\r\n      windowWidth: model.width || 12000,\r\n      windowHeight: model.height || 24000,\r\n      firstSheet: model.firstSheet,\r\n      activeTab: model.activeTab,\r\n    };\r\n    if (model.visibility && model.visibility !== 'visible') {\r\n      attributes.visibility = model.visibility;\r\n    }\r\n    xmlStream.leafNode('workbookView', attributes);\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'workbookView') {\r\n      const model = (this.model = {});\r\n      const addS = function(name, value, dflt) {\r\n        const s = value !== undefined ? (model[name] = value) : dflt;\r\n        if (s !== undefined) {\r\n          model[name] = s;\r\n        }\r\n      };\r\n      const addN = function(name, value, dflt) {\r\n        const n = value !== undefined ? (model[name] = parseInt(value, 10)) : dflt;\r\n        if (n !== undefined) {\r\n          model[name] = n;\r\n        }\r\n      };\r\n      addN('x', node.attributes.xWindow, 0);\r\n      addN('y', node.attributes.yWindow, 0);\r\n      addN('width', node.attributes.windowWidth, 25000);\r\n      addN('height', node.attributes.windowHeight, 10000);\r\n      addS('visibility', node.attributes.visibility, 'visible');\r\n      addN('activeTab', node.attributes.activeTab, undefined);\r\n      addN('firstSheet', node.attributes.firstSheet, undefined);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = WorkbookViewXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass WorksheetPropertiesXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('workbookPr', {\r\n      date1904: model.date1904 ? 1 : undefined,\r\n      defaultThemeVersion: 164011,\r\n      filterPrivacy: 1,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'workbookPr') {\r\n      this.model = {\r\n        date1904: node.attributes.date1904 === '1',\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = WorksheetPropertiesXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass WorkbookCalcPropertiesXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('calcPr', {\r\n      calcId: 171027,\r\n      fullCalcOnLoad: model.fullCalcOnLoad ? 1 : undefined,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'calcPr') {\r\n      this.model = {};\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = WorkbookCalcPropertiesXform;\r\n","const _ = require('../../../utils/under-dash');\r\n\r\nconst colCache = require('../../../utils/col-cache');\r\nconst XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst RelType = require('../../rel-type');\r\n\r\nconst Merges = require('./merges');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst ListXform = require('../list-xform');\r\nconst RowXform = require('./row-xform');\r\nconst ColXform = require('./col-xform');\r\nconst DimensionXform = require('./dimension-xform');\r\nconst HyperlinkXform = require('./hyperlink-xform');\r\nconst MergeCellXform = require('./merge-cell-xform');\r\nconst DataValidationsXform = require('./data-validations-xform');\r\nconst SheetPropertiesXform = require('./sheet-properties-xform');\r\nconst SheetFormatPropertiesXform = require('./sheet-format-properties-xform');\r\nconst SheetViewXform = require('./sheet-view-xform');\r\nconst SheetProtectionXform = require('./sheet-protection-xform');\r\nconst PageMarginsXform = require('./page-margins-xform');\r\nconst PageSetupXform = require('./page-setup-xform');\r\nconst PrintOptionsXform = require('./print-options-xform');\r\nconst AutoFilterXform = require('./auto-filter-xform');\r\nconst PictureXform = require('./picture-xform');\r\nconst DrawingXform = require('./drawing-xform');\r\nconst TablePartXform = require('./table-part-xform');\r\nconst RowBreaksXform = require('./row-breaks-xform');\r\nconst HeaderFooterXform = require('./header-footer-xform');\r\nconst ConditionalFormattingsXform = require('./cf/conditional-formattings-xform');\r\nconst ExtListXform = require('./ext-lst-xform');\r\n\r\nconst mergeRule = (rule, extRule) => {\r\n  Object.keys(extRule).forEach(key => {\r\n    const value = rule[key];\r\n    const extValue = extRule[key];\r\n    if (value === undefined && extValue !== undefined) {\r\n      rule[key] = extValue;\r\n    }\r\n  });\r\n};\r\n\r\nconst mergeConditionalFormattings = (model, extModel) => {\r\n  // conditional formattings are rendered in worksheet.conditionalFormatting and also in\r\n  // worksheet.extLst.ext.x14:conditionalFormattings\r\n  // some (e.g. dataBar) are even spread across both!\r\n  if (!extModel || !extModel.length) {\r\n    return model;\r\n  }\r\n  if (!model || !model.length) {\r\n    return extModel;\r\n  }\r\n\r\n  // index model rules by x14Id\r\n  const cfMap = {};\r\n  const ruleMap = {};\r\n  model.forEach(cf => {\r\n    cfMap[cf.ref] = cf;\r\n    cf.rules.forEach(rule => {\r\n      const {x14Id} = rule;\r\n      if (x14Id) {\r\n        ruleMap[x14Id] = rule;\r\n      }\r\n    });\r\n  });\r\n\r\n  extModel.forEach(extCf => {\r\n    extCf.rules.forEach(extRule => {\r\n      const rule = ruleMap[extRule.x14Id];\r\n      if (rule) {\r\n        // merge with matching rule\r\n        mergeRule(rule, extRule);\r\n      } else if (cfMap[extCf.ref]) {\r\n        // reuse existing cf ref\r\n        cfMap[extCf.ref].rules.push(extRule);\r\n      } else {\r\n        // create new cf\r\n        model.push({\r\n          ref: extCf.ref,\r\n          rules: [extRule],\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\n  // need to cope with rules in extModel that don't exist in model\r\n  return model;\r\n};\r\n\r\nclass WorkSheetXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    const {maxRows, maxCols} = options || {};\r\n    this.map = {\r\n      sheetPr: new SheetPropertiesXform(),\r\n      dimension: new DimensionXform(),\r\n      sheetViews: new ListXform({\r\n        tag: 'sheetViews',\r\n        count: false,\r\n        childXform: new SheetViewXform(),\r\n      }),\r\n      sheetFormatPr: new SheetFormatPropertiesXform(),\r\n      cols: new ListXform({tag: 'cols', count: false, childXform: new ColXform()}),\r\n      sheetData: new ListXform({\r\n        tag: 'sheetData',\r\n        count: false,\r\n        empty: true,\r\n        childXform: new RowXform({maxItems: maxCols}),\r\n        maxItems: maxRows,\r\n      }),\r\n      autoFilter: new AutoFilterXform(),\r\n      mergeCells: new ListXform({tag: 'mergeCells', count: true, childXform: new MergeCellXform()}),\r\n      rowBreaks: new RowBreaksXform(),\r\n      hyperlinks: new ListXform({\r\n        tag: 'hyperlinks',\r\n        count: false,\r\n        childXform: new HyperlinkXform(),\r\n      }),\r\n      pageMargins: new PageMarginsXform(),\r\n      dataValidations: new DataValidationsXform(),\r\n      pageSetup: new PageSetupXform(),\r\n      headerFooter: new HeaderFooterXform(),\r\n      printOptions: new PrintOptionsXform(),\r\n      picture: new PictureXform(),\r\n      drawing: new DrawingXform(),\r\n      sheetProtection: new SheetProtectionXform(),\r\n      tableParts: new ListXform({tag: 'tableParts', count: true, childXform: new TablePartXform()}),\r\n      conditionalFormatting: new ConditionalFormattingsXform(),\r\n      extLst: new ExtListXform(),\r\n    };\r\n  }\r\n\r\n  prepare(model, options) {\r\n    options.merges = new Merges();\r\n    model.hyperlinks = options.hyperlinks = [];\r\n    model.comments = options.comments = [];\r\n\r\n    options.formulae = {};\r\n    options.siFormulae = 0;\r\n    this.map.cols.prepare(model.cols, options);\r\n    this.map.sheetData.prepare(model.rows, options);\r\n    this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);\r\n\r\n    model.mergeCells = options.merges.mergeCells;\r\n\r\n    // prepare relationships\r\n    const rels = (model.rels = []);\r\n\r\n    function nextRid(r) {\r\n      return `rId${r.length + 1}`;\r\n    }\r\n\r\n    model.hyperlinks.forEach(hyperlink => {\r\n      const rId = nextRid(rels);\r\n      hyperlink.rId = rId;\r\n      rels.push({\r\n        Id: rId,\r\n        Type: RelType.Hyperlink,\r\n        Target: hyperlink.target,\r\n        TargetMode: 'External',\r\n      });\r\n    });\r\n\r\n    // prepare comment relationships\r\n    if (model.comments.length > 0) {\r\n      const comment = {\r\n        Id: nextRid(rels),\r\n        Type: RelType.Comments,\r\n        Target: `../comments${model.id}.xml`,\r\n      };\r\n      rels.push(comment);\r\n      const vmlDrawing = {\r\n        Id: nextRid(rels),\r\n        Type: RelType.VmlDrawing,\r\n        Target: `../drawings/vmlDrawing${model.id}.vml`,\r\n      };\r\n      rels.push(vmlDrawing);\r\n\r\n      model.comments.forEach(item => {\r\n        item.refAddress = colCache.decodeAddress(item.ref);\r\n      });\r\n\r\n      options.commentRefs.push({\r\n        commentName: `comments${model.id}`,\r\n        vmlDrawing: `vmlDrawing${model.id}`,\r\n      });\r\n    }\r\n\r\n    const drawingRelsHash = [];\r\n    let bookImage;\r\n    model.media.forEach(medium => {\r\n      if (medium.type === 'background') {\r\n        const rId = nextRid(rels);\r\n        bookImage = options.media[medium.imageId];\r\n        rels.push({\r\n          Id: rId,\r\n          Type: RelType.Image,\r\n          Target: `../media/${bookImage.name}.${bookImage.extension}`,\r\n        });\r\n        model.background = {\r\n          rId,\r\n        };\r\n        model.image = options.media[medium.imageId];\r\n      } else if (medium.type === 'image') {\r\n        let {drawing} = model;\r\n        bookImage = options.media[medium.imageId];\r\n        if (!drawing) {\r\n          drawing = model.drawing = {\r\n            rId: nextRid(rels),\r\n            name: `drawing${++options.drawingsCount}`,\r\n            anchors: [],\r\n            rels: [],\r\n          };\r\n          options.drawings.push(drawing);\r\n          rels.push({\r\n            Id: drawing.rId,\r\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',\r\n            Target: `../drawings/${drawing.name}.xml`,\r\n          });\r\n        }\r\n        let rIdImage =\r\n          this.preImageId === medium.imageId\r\n            ? drawingRelsHash[medium.imageId]\r\n            : drawingRelsHash[drawing.rels.length];\r\n        if (!rIdImage) {\r\n          rIdImage = nextRid(drawing.rels);\r\n          drawingRelsHash[drawing.rels.length] = rIdImage;\r\n          drawing.rels.push({\r\n            Id: rIdImage,\r\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',\r\n            Target: `../media/${bookImage.name}.${bookImage.extension}`,\r\n          });\r\n        }\r\n\r\n        const anchor = {\r\n          picture: {\r\n            rId: rIdImage,\r\n          },\r\n          range: medium.range,\r\n        };\r\n        if (medium.hyperlinks && medium.hyperlinks.hyperlink) {\r\n          const rIdHyperLink = nextRid(drawing.rels);\r\n          drawingRelsHash[drawing.rels.length] = rIdHyperLink;\r\n          anchor.picture.hyperlinks = {\r\n            tooltip: medium.hyperlinks.tooltip,\r\n            rId: rIdHyperLink,\r\n          };\r\n          drawing.rels.push({\r\n            Id: rIdHyperLink,\r\n            Type: RelType.Hyperlink,\r\n            Target: medium.hyperlinks.hyperlink,\r\n            TargetMode: 'External',\r\n          });\r\n        }\r\n        this.preImageId = medium.imageId;\r\n        drawing.anchors.push(anchor);\r\n      }\r\n    });\r\n\r\n    // prepare tables\r\n    model.tables.forEach(table => {\r\n      // relationships\r\n      const rId = nextRid(rels);\r\n      table.rId = rId;\r\n      rels.push({\r\n        Id: rId,\r\n        Type: RelType.Table,\r\n        Target: `../tables/${table.target}`,\r\n      });\r\n\r\n      // dynamic styles\r\n      table.columns.forEach(column => {\r\n        const {style} = column;\r\n        if (style) {\r\n          column.dxfId = options.styles.addDxfStyle(style);\r\n        }\r\n      });\r\n    });\r\n\r\n    // prepare ext items\r\n    this.map.extLst.prepare(model, options);\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode('worksheet', WorkSheetXform.WORKSHEET_ATTRIBUTES);\r\n\r\n    const sheetFormatPropertiesModel = model.properties\r\n      ? {\r\n          defaultRowHeight: model.properties.defaultRowHeight,\r\n          dyDescent: model.properties.dyDescent,\r\n          outlineLevelCol: model.properties.outlineLevelCol,\r\n          outlineLevelRow: model.properties.outlineLevelRow,\r\n        }\r\n      : undefined;\r\n    if (model.properties && model.properties.defaultColWidth) {\r\n      sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;\r\n    }\r\n    const sheetPropertiesModel = {\r\n      outlineProperties: model.properties && model.properties.outlineProperties,\r\n      tabColor: model.properties && model.properties.tabColor,\r\n      pageSetup:\r\n        model.pageSetup && model.pageSetup.fitToPage\r\n          ? {\r\n              fitToPage: model.pageSetup.fitToPage,\r\n            }\r\n          : undefined,\r\n    };\r\n    const pageMarginsModel = model.pageSetup && model.pageSetup.margins;\r\n    const printOptionsModel = {\r\n      showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,\r\n      showGridLines: model.pageSetup && model.pageSetup.showGridLines,\r\n      horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,\r\n      verticalCentered: model.pageSetup && model.pageSetup.verticalCentered,\r\n    };\r\n    const sheetProtectionModel = model.sheetProtection;\r\n\r\n    this.map.sheetPr.render(xmlStream, sheetPropertiesModel);\r\n    this.map.dimension.render(xmlStream, model.dimensions);\r\n    this.map.sheetViews.render(xmlStream, model.views);\r\n    this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);\r\n    this.map.cols.render(xmlStream, model.cols);\r\n    this.map.sheetData.render(xmlStream, model.rows);\r\n    this.map.sheetProtection.render(xmlStream, sheetProtectionModel); // Note: must be after sheetData and before autoFilter\r\n    this.map.autoFilter.render(xmlStream, model.autoFilter);\r\n    this.map.mergeCells.render(xmlStream, model.mergeCells);\r\n    this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings); // Note: must be before dataValidations\r\n    this.map.dataValidations.render(xmlStream, model.dataValidations);\r\n\r\n    // For some reason hyperlinks have to be after the data validations\r\n    this.map.hyperlinks.render(xmlStream, model.hyperlinks);\r\n\r\n    this.map.printOptions.render(xmlStream, printOptionsModel); // Note: must be before pageMargins\r\n    this.map.pageMargins.render(xmlStream, pageMarginsModel);\r\n    this.map.pageSetup.render(xmlStream, model.pageSetup);\r\n    this.map.headerFooter.render(xmlStream, model.headerFooter);\r\n    this.map.rowBreaks.render(xmlStream, model.rowBreaks);\r\n    this.map.drawing.render(xmlStream, model.drawing); // Note: must be after rowBreaks\r\n    this.map.picture.render(xmlStream, model.background); // Note: must be after drawing\r\n    this.map.tableParts.render(xmlStream, model.tables);\r\n\r\n    this.map.extLst.render(xmlStream, model);\r\n\r\n    if (model.rels) {\r\n      // add a <legacyDrawing /> node for each comment\r\n      model.rels.forEach(rel => {\r\n        if (rel.Type === RelType.VmlDrawing) {\r\n          xmlStream.leafNode('legacyDrawing', {'r:id': rel.Id});\r\n        }\r\n      });\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    if (node.name === 'worksheet') {\r\n      _.each(this.map, xform => {\r\n        xform.reset();\r\n      });\r\n      return true;\r\n    }\r\n\r\n    this.parser = this.map[node.name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case 'worksheet': {\r\n        const properties = this.map.sheetFormatPr.model || {};\r\n        if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {\r\n          properties.tabColor = this.map.sheetPr.model.tabColor;\r\n        }\r\n        if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {\r\n          properties.outlineProperties = this.map.sheetPr.model.outlineProperties;\r\n        }\r\n        const sheetProperties = {\r\n          fitToPage:\r\n            (this.map.sheetPr.model &&\r\n              this.map.sheetPr.model.pageSetup &&\r\n              this.map.sheetPr.model.pageSetup.fitToPage) ||\r\n            false,\r\n          margins: this.map.pageMargins.model,\r\n        };\r\n        const pageSetup = Object.assign(\r\n          sheetProperties,\r\n          this.map.pageSetup.model,\r\n          this.map.printOptions.model\r\n        );\r\n        const conditionalFormattings = mergeConditionalFormattings(\r\n          this.map.conditionalFormatting.model,\r\n          this.map.extLst.model && this.map.extLst.model['x14:conditionalFormattings']\r\n        );\r\n        this.model = {\r\n          dimensions: this.map.dimension.model,\r\n          cols: this.map.cols.model,\r\n          rows: this.map.sheetData.model,\r\n          mergeCells: this.map.mergeCells.model,\r\n          hyperlinks: this.map.hyperlinks.model,\r\n          dataValidations: this.map.dataValidations.model,\r\n          properties,\r\n          views: this.map.sheetViews.model,\r\n          pageSetup,\r\n          headerFooter: this.map.headerFooter.model,\r\n          background: this.map.picture.model,\r\n          drawing: this.map.drawing.model,\r\n          tables: this.map.tableParts.model,\r\n          conditionalFormattings,\r\n        };\r\n\r\n        if (this.map.autoFilter.model) {\r\n          this.model.autoFilter = this.map.autoFilter.model;\r\n        }\r\n        if (this.map.sheetProtection.model) {\r\n          this.model.sheetProtection = this.map.sheetProtection.model;\r\n        }\r\n\r\n        return false;\r\n      }\r\n\r\n      default:\r\n        // not quite sure how we get here!\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    // options.merges = new Merges();\r\n    // options.merges.reconcile(model.mergeCells, model.rows);\r\n    const rels = (model.relationships || []).reduce((h, rel) => {\r\n      h[rel.Id] = rel;\r\n      if (rel.Type === RelType.Comments) {\r\n        model.comments = options.comments[rel.Target].comments;\r\n      }\r\n      if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {\r\n        const vmlComment = options.vmlDrawings[rel.Target].comments;\r\n        model.comments.forEach((comment, index) => {\r\n          comment.note = Object.assign({}, comment.note, vmlComment[index]);\r\n        });\r\n      }\r\n      return h;\r\n    }, {});\r\n    options.commentsMap = (model.comments || []).reduce((h, comment) => {\r\n      if (comment.ref) {\r\n        h[comment.ref] = comment;\r\n      }\r\n      return h;\r\n    }, {});\r\n    options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {\r\n      if (hyperlink.rId) {\r\n        h[hyperlink.address] = rels[hyperlink.rId].Target;\r\n      }\r\n      return h;\r\n    }, {});\r\n    options.formulae = {};\r\n\r\n    // compact the rows and cells\r\n    model.rows = (model.rows && model.rows.filter(Boolean)) || [];\r\n    model.rows.forEach(row => {\r\n      row.cells = (row.cells && row.cells.filter(Boolean)) || [];\r\n    });\r\n\r\n    this.map.cols.reconcile(model.cols, options);\r\n    this.map.sheetData.reconcile(model.rows, options);\r\n    this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);\r\n\r\n    model.media = [];\r\n    if (model.drawing) {\r\n      const drawingRel = rels[model.drawing.rId];\r\n      const match = drawingRel.Target.match(/\\/drawings\\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);\r\n      if (match) {\r\n        const drawingName = match[1];\r\n        const drawing = options.drawings[drawingName];\r\n        drawing.anchors.forEach(anchor => {\r\n          if (anchor.medium) {\r\n            const image = {\r\n              type: 'image',\r\n              imageId: anchor.medium.index,\r\n              range: anchor.range,\r\n              hyperlinks: anchor.picture.hyperlinks,\r\n            };\r\n            model.media.push(image);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    const backgroundRel = model.background && rels[model.background.rId];\r\n    if (backgroundRel) {\r\n      const target = backgroundRel.Target.split('/media/')[1];\r\n      const imageId = options.mediaIndex && options.mediaIndex[target];\r\n      if (imageId !== undefined) {\r\n        model.media.push({\r\n          type: 'background',\r\n          imageId,\r\n        });\r\n      }\r\n    }\r\n\r\n    model.tables = (model.tables || []).map(tablePart => {\r\n      const rel = rels[tablePart.rId];\r\n      return options.tables[rel.Target];\r\n    });\r\n\r\n    delete model.relationships;\r\n    delete model.hyperlinks;\r\n    delete model.comments;\r\n  }\r\n}\r\n\r\nWorkSheetXform.WORKSHEET_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\r\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\r\n  'mc:Ignorable': 'x14ac',\r\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',\r\n};\r\n\r\nmodule.exports = WorkSheetXform;\r\n","\r\n\r\nmodule.exports = {\r\n  OfficeDocument:\r\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',\r\n  Worksheet: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',\r\n  CalcChain: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',\r\n  SharedStrings:\r\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',\r\n  Styles: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',\r\n  Theme: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',\r\n  Hyperlink: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',\r\n  Image: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',\r\n  CoreProperties:\r\n    'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',\r\n  ExtenderProperties:\r\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',\r\n  Comments: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',\r\n  VmlDrawing: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',\r\n  Table: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',\r\n};\r\n","const _ = require('../../../utils/under-dash');\r\n\r\nconst Range = require('../../../doc/range');\r\nconst colCache = require('../../../utils/col-cache');\r\nconst Enums = require('../../../doc/enums');\r\n\r\nclass Merges {\r\n  constructor() {\r\n    // optional mergeCells is array of ranges (like the xml)\r\n    this.merges = {};\r\n  }\r\n\r\n  add(merge) {\r\n    // merge is {address, master}\r\n    if (this.merges[merge.master]) {\r\n      this.merges[merge.master].expandToAddress(merge.address);\r\n    } else {\r\n      const range = `${merge.master}:${merge.address}`;\r\n      this.merges[merge.master] = new Range(range);\r\n    }\r\n  }\r\n\r\n  get mergeCells() {\r\n    return _.map(this.merges, merge => merge.range);\r\n  }\r\n\r\n  reconcile(mergeCells, rows) {\r\n    // reconcile merge list with merge cells\r\n    _.each(mergeCells, merge => {\r\n      const dimensions = colCache.decode(merge);\r\n      for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n        const row = rows[i - 1];\r\n        for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n          const cell = row.cells[j - 1];\r\n          if (!cell) {\r\n            // nulls are not included in document - so if master cell has no value - add a null one here\r\n            row.cells[j] = {\r\n              type: Enums.ValueType.Null,\r\n              address: colCache.encodeAddress(i, j),\r\n            };\r\n          } else if (cell.type === Enums.ValueType.Merge) {\r\n            cell.master = dimensions.tl;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  getMasterAddress(address) {\r\n    // if address has been merged, return its master's address. Assumes reconcile has been called\r\n    const range = this.hash[address];\r\n    return range && range.tl;\r\n  }\r\n}\r\n\r\nmodule.exports = Merges;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst CellXform = require('./cell-xform');\r\n\r\nclass RowXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.maxItems = options && options.maxItems;\r\n    this.map = {\r\n      c: new CellXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'row';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const styleId = options.styles.addStyleModel(model.style);\r\n    if (styleId) {\r\n      model.styleId = styleId;\r\n    }\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.prepare(cellModel, options);\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model, options) {\r\n    xmlStream.openNode('row');\r\n    xmlStream.addAttribute('r', model.number);\r\n    if (model.height) {\r\n      xmlStream.addAttribute('ht', model.height);\r\n      xmlStream.addAttribute('customHeight', '1');\r\n    }\r\n    if (model.hidden) {\r\n      xmlStream.addAttribute('hidden', '1');\r\n    }\r\n    if (model.min > 0 && model.max > 0 && model.min <= model.max) {\r\n      xmlStream.addAttribute('spans', `${model.min}:${model.max}`);\r\n    }\r\n    if (model.styleId) {\r\n      xmlStream.addAttribute('s', model.styleId);\r\n      xmlStream.addAttribute('customFormat', '1');\r\n    }\r\n    xmlStream.addAttribute('x14ac:dyDescent', '0.25');\r\n    if (model.outlineLevel) {\r\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\r\n    }\r\n    if (model.collapsed) {\r\n      xmlStream.addAttribute('collapsed', '1');\r\n    }\r\n\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.render(xmlStream, cellModel, options);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (node.name === 'row') {\r\n      this.numRowsSeen += 1;\r\n      const spans = node.attributes.spans\r\n        ? node.attributes.spans.split(':').map(span => parseInt(span, 10))\r\n        : [undefined, undefined];\r\n      const model = (this.model = {\r\n        number: parseInt(node.attributes.r, 10),\r\n        min: spans[0],\r\n        max: spans[1],\r\n        cells: [],\r\n      });\r\n      if (node.attributes.s) {\r\n        model.styleId = parseInt(node.attributes.s, 10);\r\n      }\r\n      if (\r\n        node.attributes.hidden === true ||\r\n        node.attributes.hidden === 'true' ||\r\n        node.attributes.hidden === 1 ||\r\n        node.attributes.hidden === '1'\r\n      ) {\r\n        model.hidden = true;\r\n      }\r\n      if (node.attributes.bestFit) {\r\n        model.bestFit = true;\r\n      }\r\n      if (node.attributes.ht) {\r\n        model.height = parseFloat(node.attributes.ht);\r\n      }\r\n      if (node.attributes.outlineLevel) {\r\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\r\n      }\r\n      if (node.attributes.collapsed) {\r\n        model.collapsed = true;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    this.parser = this.map[node.name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.cells.push(this.parser.model);\r\n        if (this.maxItems && this.model.cells.length > this.maxItems) {\r\n          throw new Error(`Max column count (${this.maxItems}) exceeded`);\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};\r\n    if (model.styleId !== undefined) {\r\n      model.styleId = undefined;\r\n    }\r\n\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.reconcile(cellModel, options);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = RowXform;\r\n","const utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\nconst Range = require('../../../doc/range');\r\nconst Enums = require('../../../doc/enums');\r\n\r\nconst RichTextXform = require('../strings/rich-text-xform');\r\n\r\nfunction getValueType(v) {\r\n  if (v === null || v === undefined) {\r\n    return Enums.ValueType.Null;\r\n  }\r\n  if (v instanceof String || typeof v === 'string') {\r\n    return Enums.ValueType.String;\r\n  }\r\n  if (typeof v === 'number') {\r\n    return Enums.ValueType.Number;\r\n  }\r\n  if (typeof v === 'boolean') {\r\n    return Enums.ValueType.Boolean;\r\n  }\r\n  if (v instanceof Date) {\r\n    return Enums.ValueType.Date;\r\n  }\r\n  if (v.text && v.hyperlink) {\r\n    return Enums.ValueType.Hyperlink;\r\n  }\r\n  if (v.formula) {\r\n    return Enums.ValueType.Formula;\r\n  }\r\n  if (v.error) {\r\n    return Enums.ValueType.Error;\r\n  }\r\n  throw new Error('I could not understand type of value');\r\n}\r\n\r\nfunction getEffectiveCellType(cell) {\r\n  switch (cell.type) {\r\n    case Enums.ValueType.Formula:\r\n      return getValueType(cell.result);\r\n    default:\r\n      return cell.type;\r\n  }\r\n}\r\n\r\nclass CellXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.richTextXForm = new RichTextXform();\r\n  }\r\n\r\n  get tag() {\r\n    return 'c';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));\r\n    if (styleId) {\r\n      model.styleId = styleId;\r\n    }\r\n\r\n    if (model.comment) {\r\n      options.comments.push({...model.comment, ref: model.address});\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.String:\r\n      case Enums.ValueType.RichText:\r\n        if (options.sharedStrings) {\r\n          model.ssId = options.sharedStrings.add(model.value);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        if (options.date1904) {\r\n          model.date1904 = true;\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Hyperlink:\r\n        if (options.sharedStrings && model.text !== undefined && model.text !== null) {\r\n          model.ssId = options.sharedStrings.add(model.text);\r\n        }\r\n        options.hyperlinks.push({\r\n          address: model.address,\r\n          target: model.hyperlink,\r\n          tooltip: model.tooltip,\r\n        });\r\n        break;\r\n\r\n      case Enums.ValueType.Merge:\r\n        options.merges.add(model);\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        if (options.date1904) {\r\n          // in case valueType is date\r\n          model.date1904 = true;\r\n        }\r\n\r\n        if (model.shareType === 'shared') {\r\n          model.si = options.siFormulae++;\r\n        }\r\n\r\n        if (model.formula) {\r\n          options.formulae[model.address] = model;\r\n        } else if (model.sharedFormula) {\r\n          const master = options.formulae[model.sharedFormula];\r\n          if (!master) {\r\n            throw new Error(\r\n              `Shared Formula master must exist above and or left of clone for cell ${model.address}`\r\n            );\r\n          }\r\n          if (master.si === undefined) {\r\n            master.shareType = 'shared';\r\n            master.si = options.siFormulae++;\r\n            master.range = new Range(master.address, model.address);\r\n          } else if (master.range) {\r\n            master.range.expandToAddress(model.address);\r\n          }\r\n          model.si = master.si;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  renderFormula(xmlStream, model) {\r\n    let attrs = null;\r\n    switch (model.shareType) {\r\n      case 'shared':\r\n        attrs = {\r\n          t: 'shared',\r\n          ref: model.ref || model.range.range,\r\n          si: model.si,\r\n        };\r\n        break;\r\n\r\n      case 'array':\r\n        attrs = {\r\n          t: 'array',\r\n          ref: model.ref,\r\n        };\r\n        break;\r\n\r\n      default:\r\n        if (model.si !== undefined) {\r\n          attrs = {\r\n            t: 'shared',\r\n            si: model.si,\r\n          };\r\n        }\r\n        break;\r\n    }\r\n\r\n    switch (getValueType(model.result)) {\r\n      case Enums.ValueType.Null: // ?\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        break;\r\n\r\n      case Enums.ValueType.String:\r\n        // oddly, formula results don't ever use shared strings\r\n        xmlStream.addAttribute('t', 'str');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result);\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result);\r\n        break;\r\n\r\n      case Enums.ValueType.Boolean:\r\n        xmlStream.addAttribute('t', 'b');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result ? 1 : 0);\r\n        break;\r\n\r\n      case Enums.ValueType.Error:\r\n        xmlStream.addAttribute('t', 'e');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result.error);\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.result, model.date1904));\r\n        break;\r\n\r\n      // case Enums.ValueType.Hyperlink: // ??\r\n      // case Enums.ValueType.Formula:\r\n      default:\r\n        throw new Error('I could not understand type of value');\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model.type === Enums.ValueType.Null && !model.styleId) {\r\n      // if null and no style, exit\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode('c');\r\n    xmlStream.addAttribute('r', model.address);\r\n\r\n    if (model.styleId) {\r\n      xmlStream.addAttribute('s', model.styleId);\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.Null:\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        xmlStream.leafNode('v', null, model.value);\r\n        break;\r\n\r\n      case Enums.ValueType.Boolean:\r\n        xmlStream.addAttribute('t', 'b');\r\n        xmlStream.leafNode('v', null, model.value ? '1' : '0');\r\n        break;\r\n\r\n      case Enums.ValueType.Error:\r\n        xmlStream.addAttribute('t', 'e');\r\n        xmlStream.leafNode('v', null, model.value.error);\r\n        break;\r\n\r\n      case Enums.ValueType.String:\r\n      case Enums.ValueType.RichText:\r\n        if (model.ssId !== undefined) {\r\n          xmlStream.addAttribute('t', 's');\r\n          xmlStream.leafNode('v', null, model.ssId);\r\n        } else if (model.value && model.value.richText) {\r\n          xmlStream.addAttribute('t', 'inlineStr');\r\n          xmlStream.openNode('is');\r\n          model.value.richText.forEach(text => {\r\n            this.richTextXForm.render(xmlStream, text);\r\n          });\r\n          xmlStream.closeNode('is');\r\n        } else {\r\n          xmlStream.addAttribute('t', 'str');\r\n          xmlStream.leafNode('v', null, model.value);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.value, model.date1904));\r\n        break;\r\n\r\n      case Enums.ValueType.Hyperlink:\r\n        if (model.ssId !== undefined) {\r\n          xmlStream.addAttribute('t', 's');\r\n          xmlStream.leafNode('v', null, model.ssId);\r\n        } else {\r\n          xmlStream.addAttribute('t', 'str');\r\n          xmlStream.leafNode('v', null, model.text);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        this.renderFormula(xmlStream, model);\r\n        break;\r\n\r\n      case Enums.ValueType.Merge:\r\n        // nothing to add\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    xmlStream.closeNode(); // </c>\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'c':\r\n        // const address = colCache.decodeAddress(node.attributes.r);\r\n        this.model = {\r\n          address: node.attributes.r,\r\n        };\r\n        this.t = node.attributes.t;\r\n        if (node.attributes.s) {\r\n          this.model.styleId = parseInt(node.attributes.s, 10);\r\n        }\r\n        return true;\r\n\r\n      case 'f':\r\n        this.currentNode = 'f';\r\n        this.model.si = node.attributes.si;\r\n        this.model.shareType = node.attributes.t;\r\n        this.model.ref = node.attributes.ref;\r\n        return true;\r\n\r\n      case 'v':\r\n        this.currentNode = 'v';\r\n        return true;\r\n\r\n      case 't':\r\n        this.currentNode = 't';\r\n        return true;\r\n\r\n      case 'r':\r\n        this.parser = this.richTextXForm;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n      return;\r\n    }\r\n    switch (this.currentNode) {\r\n      case 'f':\r\n        this.model.formula = this.model.formula ? this.model.formula + text : text;\r\n        break;\r\n      case 'v':\r\n      case 't':\r\n        if (this.model.value && this.model.value.richText) {\r\n          this.model.value.richText.text = this.model.value.richText.text\r\n            ? this.model.value.richText.text + text\r\n            : text;\r\n        } else {\r\n          this.model.value = this.model.value ? this.model.value + text : text;\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case 'c': {\r\n        const {model} = this;\r\n\r\n        // first guess on cell type\r\n        if (model.formula || model.shareType) {\r\n          model.type = Enums.ValueType.Formula;\r\n          if (model.value) {\r\n            if (this.t === 'str') {\r\n              model.result = utils.xmlDecode(model.value);\r\n            } else if (this.t === 'b') {\r\n              model.result = parseInt(model.value, 10) !== 0;\r\n            } else if (this.t === 'e') {\r\n              model.result = {error: model.value};\r\n            } else {\r\n              model.result = parseFloat(model.value);\r\n            }\r\n            model.value = undefined;\r\n          }\r\n        } else if (model.value !== undefined) {\r\n          switch (this.t) {\r\n            case 's':\r\n              model.type = Enums.ValueType.String;\r\n              model.value = parseInt(model.value, 10);\r\n              break;\r\n            case 'str':\r\n              model.type = Enums.ValueType.String;\r\n              model.value = utils.xmlDecode(model.value);\r\n              break;\r\n            case 'inlineStr':\r\n              model.type = Enums.ValueType.String;\r\n              break;\r\n            case 'b':\r\n              model.type = Enums.ValueType.Boolean;\r\n              model.value = parseInt(model.value, 10) !== 0;\r\n              break;\r\n            case 'e':\r\n              model.type = Enums.ValueType.Error;\r\n              model.value = {error: model.value};\r\n              break;\r\n            default:\r\n              model.type = Enums.ValueType.Number;\r\n              model.value = parseFloat(model.value);\r\n              break;\r\n          }\r\n        } else if (model.styleId) {\r\n          model.type = Enums.ValueType.Null;\r\n        } else {\r\n          model.type = Enums.ValueType.Merge;\r\n        }\r\n        return false;\r\n      }\r\n\r\n      case 'f':\r\n      case 'v':\r\n      case 'is':\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      case 't':\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n          return true;\r\n        }\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      case 'r':\r\n        this.model.value = this.model.value || {};\r\n        this.model.value.richText = this.model.value.richText || [];\r\n        this.model.value.richText.push(this.parser.model);\r\n        this.parser = undefined;\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      default:\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);\r\n    if (style) {\r\n      model.style = style;\r\n    }\r\n    if (model.styleId !== undefined) {\r\n      model.styleId = undefined;\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.String:\r\n        if (typeof model.value === 'number') {\r\n          if (options.sharedStrings) {\r\n            model.value = options.sharedStrings.getString(model.value);\r\n          }\r\n        }\r\n        if (model.value.richText) {\r\n          model.type = Enums.ValueType.RichText;\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        if (style && utils.isDateFmt(style.numFmt)) {\r\n          model.type = Enums.ValueType.Date;\r\n          model.value = utils.excelToDate(model.value, options.date1904);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {\r\n          model.result = utils.excelToDate(model.result, options.date1904);\r\n        }\r\n        if (model.shareType === 'shared') {\r\n          if (model.ref) {\r\n            // master\r\n            options.formulae[model.si] = model.address;\r\n          } else {\r\n            // slave\r\n            model.sharedFormula = options.formulae[model.si];\r\n            delete model.shareType;\r\n          }\r\n          delete model.si;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // look for hyperlink\r\n    const hyperlink = options.hyperlinkMap[model.address];\r\n    if (hyperlink) {\r\n      if (model.type === Enums.ValueType.Formula) {\r\n        model.text = model.result;\r\n        model.result = undefined;\r\n      } else {\r\n        model.text = model.value;\r\n        model.value = undefined;\r\n      }\r\n      model.type = Enums.ValueType.Hyperlink;\r\n      model.hyperlink = hyperlink;\r\n    }\r\n\r\n    const comment = options.commentsMap && options.commentsMap[model.address];\r\n    if (comment) {\r\n      model.comment = comment;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CellXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass ColXform extends BaseXform {\r\n  get tag() {\r\n    return 'col';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const styleId = options.styles.addStyleModel(model.style || {});\r\n    if (styleId) {\r\n      model.styleId = styleId;\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('col');\r\n    xmlStream.addAttribute('min', model.min);\r\n    xmlStream.addAttribute('max', model.max);\r\n    if (model.width) {\r\n      xmlStream.addAttribute('width', model.width);\r\n    }\r\n    if (model.styleId) {\r\n      xmlStream.addAttribute('style', model.styleId);\r\n    }\r\n    if (model.hidden) {\r\n      xmlStream.addAttribute('hidden', '1');\r\n    }\r\n    if (model.bestFit) {\r\n      xmlStream.addAttribute('bestFit', '1');\r\n    }\r\n    if (model.outlineLevel) {\r\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\r\n    }\r\n    if (model.collapsed) {\r\n      xmlStream.addAttribute('collapsed', '1');\r\n    }\r\n    xmlStream.addAttribute('customWidth', '1');\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'col') {\r\n      const model = (this.model = {\r\n        min: parseInt(node.attributes.min || '0', 10),\r\n        max: parseInt(node.attributes.max || '0', 10),\r\n        width:\r\n          node.attributes.width === undefined\r\n            ? undefined\r\n            : parseFloat(node.attributes.width || '0'),\r\n      });\r\n      if (node.attributes.style) {\r\n        model.styleId = parseInt(node.attributes.style, 10);\r\n      }\r\n      if (\r\n        node.attributes.hidden === true ||\r\n        node.attributes.hidden === 'true' ||\r\n        node.attributes.hidden === 1 ||\r\n        node.attributes.hidden === '1'\r\n      ) {\r\n        model.hidden = true;\r\n      }\r\n      if (node.attributes.bestFit) {\r\n        model.bestFit = true;\r\n      }\r\n      if (node.attributes.outlineLevel) {\r\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\r\n      }\r\n      if (node.attributes.collapsed) {\r\n        model.collapsed = true;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    // reconcile column styles\r\n    if (model.styleId) {\r\n      model.style = options.styles.getStyleModel(model.styleId);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = ColXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass DimensionXform extends BaseXform {\r\n  get tag() {\r\n    return 'dimension';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.leafNode('dimension', {ref: model});\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'dimension') {\r\n      this.model = node.attributes.ref;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = DimensionXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass HyperlinkXform extends BaseXform {\r\n  get tag() {\r\n    return 'hyperlink';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('hyperlink', {\r\n      ref: model.address,\r\n      'r:id': model.rId,\r\n      tooltip: model.tooltip,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'hyperlink') {\r\n      this.model = {\r\n        address: node.attributes.ref,\r\n        rId: node.attributes['r:id'],\r\n        tooltip: node.attributes.tooltip,\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = HyperlinkXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass MergeCellXform extends BaseXform {\r\n  get tag() {\r\n    return 'mergeCell';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('mergeCell', {ref: model});\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'mergeCell') {\r\n      this.model = node.attributes.ref;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = MergeCellXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst utils = require('../../../utils/utils');\r\nconst colCache = require('../../../utils/col-cache');\r\nconst BaseXform = require('../base-xform');\r\nconst Range = require('../../../doc/range');\r\n\r\nfunction assign(definedName, attributes, name, defaultValue) {\r\n  const value = attributes[name];\r\n  if (value !== undefined) {\r\n    definedName[name] = value;\r\n  } else if (defaultValue !== undefined) {\r\n    definedName[name] = defaultValue;\r\n  }\r\n}\r\nfunction parseBool(value) {\r\n  switch (value) {\r\n    case '1':\r\n    case 'true':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\nfunction assignBool(definedName, attributes, name, defaultValue) {\r\n  const value = attributes[name];\r\n  if (value !== undefined) {\r\n    definedName[name] = parseBool(value);\r\n  } else if (defaultValue !== undefined) {\r\n    definedName[name] = defaultValue;\r\n  }\r\n}\r\n\r\nfunction optimiseDataValidations(model) {\r\n  // Squeeze alike data validations together into rectangular ranges\r\n  // to reduce file size and speed up Excel load time\r\n  const dvList = _.map(model, (dataValidation, address) => ({\r\n    address,\r\n    dataValidation,\r\n    marked: false,\r\n  })).sort((a, b) => _.strcmp(a.address, b.address));\r\n  const dvMap = _.keyBy(dvList, 'address');\r\n  const matchCol = (addr, height, col) => {\r\n    for (let i = 0; i < height; i++) {\r\n      const otherAddress = colCache.encodeAddress(addr.row + i, col);\r\n      if (!model[otherAddress] || !_.isEqual(model[addr.address], model[otherAddress])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  return dvList\r\n    .map(dv => {\r\n      if (!dv.marked) {\r\n        const addr = colCache.decodeEx(dv.address);\r\n        if (addr.dimensions) {\r\n          dvMap[addr.dimensions].marked = true;\r\n          return {\r\n            ...dv.dataValidation,\r\n            sqref: dv.address,\r\n          };\r\n        }\r\n\r\n        // iterate downwards - finding matching cells\r\n        let height = 1;\r\n        let otherAddress = colCache.encodeAddress(addr.row + height, addr.col);\r\n        while (model[otherAddress] && _.isEqual(dv.dataValidation, model[otherAddress])) {\r\n          height++;\r\n          otherAddress = colCache.encodeAddress(addr.row + height, addr.col);\r\n        }\r\n\r\n        // iterate rightwards...\r\n\r\n        let width = 1;\r\n        while (matchCol(addr, height, addr.col + width)) {\r\n          width++;\r\n        }\r\n\r\n        // mark all included addresses\r\n        for (let i = 0; i < height; i++) {\r\n          for (let j = 0; j < width; j++) {\r\n            otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);\r\n            dvMap[otherAddress].marked = true;\r\n          }\r\n        }\r\n\r\n        if (height > 1 || width > 1) {\r\n          const bottom = addr.row + (height - 1);\r\n          const right = addr.col + (width - 1);\r\n          return {\r\n            ...dv.dataValidation,\r\n            sqref: `${dv.address}:${colCache.encodeAddress(bottom, right)}`,\r\n          };\r\n        }\r\n        return {\r\n          ...dv.dataValidation,\r\n          sqref: dv.address,\r\n        };\r\n      }\r\n      return null;\r\n    })\r\n    .filter(Boolean);\r\n}\r\n\r\nclass DataValidationsXform extends BaseXform {\r\n  get tag() {\r\n    return 'dataValidations';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const optimizedModel = optimiseDataValidations(model);\r\n    if (optimizedModel.length) {\r\n      xmlStream.openNode('dataValidations', {count: optimizedModel.length});\r\n\r\n      optimizedModel.forEach(value => {\r\n        xmlStream.openNode('dataValidation');\r\n\r\n        if (value.type !== 'any') {\r\n          xmlStream.addAttribute('type', value.type);\r\n\r\n          if (value.operator && value.type !== 'list' && value.operator !== 'between') {\r\n            xmlStream.addAttribute('operator', value.operator);\r\n          }\r\n          if (value.allowBlank) {\r\n            xmlStream.addAttribute('allowBlank', '1');\r\n          }\r\n        }\r\n        if (value.showInputMessage) {\r\n          xmlStream.addAttribute('showInputMessage', '1');\r\n        }\r\n        if (value.promptTitle) {\r\n          xmlStream.addAttribute('promptTitle', value.promptTitle);\r\n        }\r\n        if (value.prompt) {\r\n          xmlStream.addAttribute('prompt', value.prompt);\r\n        }\r\n        if (value.showErrorMessage) {\r\n          xmlStream.addAttribute('showErrorMessage', '1');\r\n        }\r\n        if (value.errorStyle) {\r\n          xmlStream.addAttribute('errorStyle', value.errorStyle);\r\n        }\r\n        if (value.errorTitle) {\r\n          xmlStream.addAttribute('errorTitle', value.errorTitle);\r\n        }\r\n        if (value.error) {\r\n          xmlStream.addAttribute('error', value.error);\r\n        }\r\n        xmlStream.addAttribute('sqref', value.sqref);\r\n        (value.formulae || []).forEach((formula, index) => {\r\n          xmlStream.openNode(`formula${index + 1}`);\r\n          if (value.type === 'date') {\r\n            xmlStream.writeText(utils.dateToExcel(new Date(formula)));\r\n          } else {\r\n            xmlStream.writeText(formula);\r\n          }\r\n          xmlStream.closeNode();\r\n        });\r\n        xmlStream.closeNode();\r\n      });\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'dataValidations':\r\n        this.model = {};\r\n        return true;\r\n\r\n      case 'dataValidation': {\r\n        this._address = node.attributes.sqref;\r\n        const dataValidation = {type: node.attributes.type || 'any', formulae: []};\r\n\r\n        if (node.attributes.type) {\r\n          assignBool(dataValidation, node.attributes, 'allowBlank');\r\n        }\r\n        assignBool(dataValidation, node.attributes, 'showInputMessage');\r\n        assignBool(dataValidation, node.attributes, 'showErrorMessage');\r\n\r\n        switch (dataValidation.type) {\r\n          case 'any':\r\n          case 'list':\r\n          case 'custom':\r\n            break;\r\n          default:\r\n            assign(dataValidation, node.attributes, 'operator', 'between');\r\n            break;\r\n        }\r\n        assign(dataValidation, node.attributes, 'promptTitle');\r\n        assign(dataValidation, node.attributes, 'prompt');\r\n        assign(dataValidation, node.attributes, 'errorStyle');\r\n        assign(dataValidation, node.attributes, 'errorTitle');\r\n        assign(dataValidation, node.attributes, 'error');\r\n\r\n        this._dataValidation = dataValidation;\r\n        return true;\r\n      }\r\n\r\n      case 'formula1':\r\n      case 'formula2':\r\n        this._formula = [];\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this._formula) {\r\n      this._formula.push(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case 'dataValidations':\r\n        return false;\r\n      case 'dataValidation': {\r\n        if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {\r\n          delete this._dataValidation.formulae;\r\n          delete this._dataValidation.operator;\r\n        }\r\n        // The four known cases: 1. E4:L9 N4:U9  2.E4 L9  3. N4:U9  4. E4\r\n        const list = this._address.split(/\\s+/g) || [];\r\n        list.forEach(addr => {\r\n          if (addr.includes(':')) {\r\n            const range = new Range(addr);\r\n            range.forEachAddress(address => {\r\n              this.model[address] = this._dataValidation;\r\n            });\r\n          } else {\r\n            this.model[addr] = this._dataValidation;\r\n          }\r\n        });\r\n        return true;\r\n      }\r\n      case 'formula1':\r\n      case 'formula2': {\r\n        let formula = this._formula.join('');\r\n        switch (this._dataValidation.type) {\r\n          case 'whole':\r\n          case 'textLength':\r\n            formula = parseInt(formula, 10);\r\n            break;\r\n          case 'decimal':\r\n            formula = parseFloat(formula);\r\n            break;\r\n          case 'date':\r\n            formula = utils.excelToDate(parseFloat(formula));\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        this._dataValidation.formulae.push(formula);\r\n        this._formula = undefined;\r\n        return true;\r\n      }\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = DataValidationsXform;\r\n","const BaseXform = require('../base-xform');\r\nconst ColorXform = require('../style/color-xform');\r\nconst PageSetupPropertiesXform = require('./page-setup-properties-xform');\r\nconst OutlinePropertiesXform = require('./outline-properties-xform');\r\n\r\nclass SheetPropertiesXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      tabColor: new ColorXform('tabColor'),\r\n      pageSetUpPr: new PageSetupPropertiesXform(),\r\n      outlinePr: new OutlinePropertiesXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'sheetPr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.addRollback();\r\n      xmlStream.openNode('sheetPr');\r\n\r\n      let inner = false;\r\n      inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;\r\n      inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;\r\n      inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;\r\n\r\n      if (inner) {\r\n        xmlStream.closeNode();\r\n        xmlStream.commit();\r\n      } else {\r\n        xmlStream.rollback();\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (node.name === this.tag) {\r\n      this.reset();\r\n      return true;\r\n    }\r\n    if (this.map[node.name]) {\r\n      this.parser = this.map[node.name];\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {\r\n      this.model = {};\r\n      if (this.map.tabColor.model) {\r\n        this.model.tabColor = this.map.tabColor.model;\r\n      }\r\n      if (this.map.pageSetUpPr.model) {\r\n        this.model.pageSetup = this.map.pageSetUpPr.model;\r\n      }\r\n      if (this.map.outlinePr.model) {\r\n        this.model.outlineProperties = this.map.outlinePr.model;\r\n      }\r\n    } else {\r\n      this.model = null;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = SheetPropertiesXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass PageSetupPropertiesXform extends BaseXform {\r\n  get tag() {\r\n    return 'pageSetUpPr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model && model.fitToPage) {\r\n      xmlStream.leafNode(this.tag, {\r\n        fitToPage: model.fitToPage ? '1' : undefined,\r\n      });\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      this.model = {\r\n        fitToPage: node.attributes.fitToPage === '1',\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PageSetupPropertiesXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst isDefined = attr => typeof attr !== 'undefined';\r\n\r\nclass OutlinePropertiesXform extends BaseXform {\r\n  get tag() {\r\n    return 'outlinePr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {\r\n      xmlStream.leafNode(this.tag, {\r\n        summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : undefined,\r\n        summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : undefined,\r\n      });\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      this.model = {\r\n        summaryBelow: isDefined(node.attributes.summaryBelow)\r\n          ? Boolean(Number(node.attributes.summaryBelow))\r\n          : undefined,\r\n        summaryRight: isDefined(node.attributes.summaryRight)\r\n          ? Boolean(Number(node.attributes.summaryRight))\r\n          : undefined,\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = OutlinePropertiesXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\nclass SheetFormatPropertiesXform extends BaseXform {\r\n  get tag() {\r\n    return 'sheetFormatPr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      const attributes = {\r\n        defaultRowHeight: model.defaultRowHeight,\r\n        outlineLevelRow: model.outlineLevelRow,\r\n        outlineLevelCol: model.outlineLevelCol,\r\n        'x14ac:dyDescent': model.dyDescent,\r\n      };\r\n      if (model.defaultColWidth) {\r\n        attributes.defaultColWidth = model.defaultColWidth;\r\n      }\r\n\r\n      // default value for 'defaultRowHeight' is 15, this should not be 'custom'\r\n      if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {\r\n        attributes.customHeight = '1';\r\n      }\r\n\r\n      if (_.some(attributes, value => value !== undefined)) {\r\n        xmlStream.leafNode('sheetFormatPr', attributes);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'sheetFormatPr') {\r\n      this.model = {\r\n        defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || '0'),\r\n        dyDescent: parseFloat(node.attributes['x14ac:dyDescent'] || '0'),\r\n        outlineLevelRow: parseInt(node.attributes.outlineLevelRow || '0', 10),\r\n        outlineLevelCol: parseInt(node.attributes.outlineLevelCol || '0', 10),\r\n      };\r\n      if (node.attributes.defaultColWidth) {\r\n        this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = SheetFormatPropertiesXform;\r\n","const colCache = require('../../../utils/col-cache');\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst VIEW_STATES = {\r\n  frozen: 'frozen',\r\n  frozenSplit: 'frozen',\r\n  split: 'split',\r\n};\r\n\r\nclass SheetViewXform extends BaseXform {\r\n  get tag() {\r\n    return 'sheetView';\r\n  }\r\n\r\n  prepare(model) {\r\n    switch (model.state) {\r\n      case 'frozen':\r\n      case 'split':\r\n        break;\r\n      default:\r\n        model.state = 'normal';\r\n        break;\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('sheetView', {\r\n      workbookViewId: model.workbookViewId || 0,\r\n    });\r\n    const add = function(name, value, included) {\r\n      if (included) {\r\n        xmlStream.addAttribute(name, value);\r\n      }\r\n    };\r\n    add('rightToLeft', '1', model.rightToLeft === true);\r\n    add('tabSelected', '1', model.tabSelected);\r\n    add('showRuler', '0', model.showRuler === false);\r\n    add('showRowColHeaders', '0', model.showRowColHeaders === false);\r\n    add('showGridLines', '0', model.showGridLines === false);\r\n    add('zoomScale', model.zoomScale, model.zoomScale);\r\n    add('zoomScaleNormal', model.zoomScaleNormal, model.zoomScaleNormal);\r\n    add('view', model.style, model.style);\r\n\r\n    let topLeftCell;\r\n    let xSplit;\r\n    let ySplit;\r\n    let activePane;\r\n    switch (model.state) {\r\n      case 'frozen':\r\n        xSplit = model.xSplit || 0;\r\n        ySplit = model.ySplit || 0;\r\n        topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;\r\n        activePane =\r\n          (model.xSplit && model.ySplit && 'bottomRight') ||\r\n          (model.xSplit && 'topRight') ||\r\n          'bottomLeft';\r\n\r\n        xmlStream.leafNode('pane', {\r\n          xSplit: model.xSplit || undefined,\r\n          ySplit: model.ySplit || undefined,\r\n          topLeftCell,\r\n          activePane,\r\n          state: 'frozen',\r\n        });\r\n        xmlStream.leafNode('selection', {\r\n          pane: activePane,\r\n          activeCell: model.activeCell,\r\n          sqref: model.activeCell,\r\n        });\r\n        break;\r\n      case 'split':\r\n        if (model.activePane === 'topLeft') {\r\n          model.activePane = undefined;\r\n        }\r\n        xmlStream.leafNode('pane', {\r\n          xSplit: model.xSplit || undefined,\r\n          ySplit: model.ySplit || undefined,\r\n          topLeftCell: model.topLeftCell,\r\n          activePane: model.activePane,\r\n        });\r\n        xmlStream.leafNode('selection', {\r\n          pane: model.activePane,\r\n          activeCell: model.activeCell,\r\n          sqref: model.activeCell,\r\n        });\r\n        break;\r\n      case 'normal':\r\n        if (model.activeCell) {\r\n          xmlStream.leafNode('selection', {\r\n            activeCell: model.activeCell,\r\n            sqref: model.activeCell,\r\n          });\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'sheetView':\r\n        this.sheetView = {\r\n          workbookViewId: parseInt(node.attributes.workbookViewId, 10),\r\n          rightToLeft: node.attributes.rightToLeft === '1',\r\n          tabSelected: node.attributes.tabSelected === '1',\r\n          showRuler: !(node.attributes.showRuler === '0'),\r\n          showRowColHeaders: !(node.attributes.showRowColHeaders === '0'),\r\n          showGridLines: !(node.attributes.showGridLines === '0'),\r\n          zoomScale: parseInt(node.attributes.zoomScale || '100', 10),\r\n          zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || '100', 10),\r\n          style: node.attributes.view,\r\n        };\r\n        this.pane = undefined;\r\n        this.selections = {};\r\n        return true;\r\n\r\n      case 'pane':\r\n        this.pane = {\r\n          xSplit: parseInt(node.attributes.xSplit || '0', 10),\r\n          ySplit: parseInt(node.attributes.ySplit || '0', 10),\r\n          topLeftCell: node.attributes.topLeftCell,\r\n          activePane: node.attributes.activePane || 'topLeft',\r\n          state: node.attributes.state,\r\n        };\r\n        return true;\r\n\r\n      case 'selection': {\r\n        const name = node.attributes.pane || 'topLeft';\r\n        this.selections[name] = {\r\n          pane: name,\r\n          activeCell: node.attributes.activeCell,\r\n        };\r\n        return true;\r\n      }\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    let model;\r\n    let selection;\r\n    switch (name) {\r\n      case 'sheetView':\r\n        if (this.sheetView && this.pane) {\r\n          model = this.model = {\r\n            workbookViewId: this.sheetView.workbookViewId,\r\n            rightToLeft: this.sheetView.rightToLeft,\r\n            state: VIEW_STATES[this.pane.state] || 'split', // split is default\r\n            xSplit: this.pane.xSplit,\r\n            ySplit: this.pane.ySplit,\r\n            topLeftCell: this.pane.topLeftCell,\r\n            showRuler: this.sheetView.showRuler,\r\n            showRowColHeaders: this.sheetView.showRowColHeaders,\r\n            showGridLines: this.sheetView.showGridLines,\r\n            zoomScale: this.sheetView.zoomScale,\r\n            zoomScaleNormal: this.sheetView.zoomScaleNormal,\r\n          };\r\n          if (this.model.state === 'split') {\r\n            model.activePane = this.pane.activePane;\r\n          }\r\n          selection = this.selections[this.pane.activePane];\r\n          if (selection && selection.activeCell) {\r\n            model.activeCell = selection.activeCell;\r\n          }\r\n          if (this.sheetView.style) {\r\n            model.style = this.sheetView.style;\r\n          }\r\n        } else {\r\n          model = this.model = {\r\n            workbookViewId: this.sheetView.workbookViewId,\r\n            rightToLeft: this.sheetView.rightToLeft,\r\n            state: 'normal',\r\n            showRuler: this.sheetView.showRuler,\r\n            showRowColHeaders: this.sheetView.showRowColHeaders,\r\n            showGridLines: this.sheetView.showGridLines,\r\n            zoomScale: this.sheetView.zoomScale,\r\n            zoomScaleNormal: this.sheetView.zoomScaleNormal,\r\n          };\r\n          selection = this.selections.topLeft;\r\n          if (selection && selection.activeCell) {\r\n            model.activeCell = selection.activeCell;\r\n          }\r\n          if (this.sheetView.style) {\r\n            model.style = this.sheetView.style;\r\n          }\r\n        }\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile() {}\r\n}\r\n\r\nmodule.exports = SheetViewXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\nfunction booleanToXml(model, value) {\r\n  return model ? value : undefined;\r\n}\r\n\r\nfunction xmlToBoolean(value, equals) {\r\n  return value === equals ? true : undefined;\r\n}\r\n\r\nclass SheetProtectionXform extends BaseXform {\r\n  get tag() {\r\n    return 'sheetProtection';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      const attributes = {\r\n        sheet: booleanToXml(model.sheet, '1'),\r\n        selectLockedCells: model.selectLockedCells === false ? '1' : undefined,\r\n        selectUnlockedCells: model.selectUnlockedCells === false ? '1' : undefined,\r\n        formatCells: booleanToXml(model.formatCells, '0'),\r\n        formatColumns: booleanToXml(model.formatColumns, '0'),\r\n        formatRows: booleanToXml(model.formatRows, '0'),\r\n        insertColumns: booleanToXml(model.insertColumns, '0'),\r\n        insertRows: booleanToXml(model.insertRows, '0'),\r\n        insertHyperlinks: booleanToXml(model.insertHyperlinks, '0'),\r\n        deleteColumns: booleanToXml(model.deleteColumns, '0'),\r\n        deleteRows: booleanToXml(model.deleteRows, '0'),\r\n        sort: booleanToXml(model.sort, '0'),\r\n        autoFilter: booleanToXml(model.autoFilter, '0'),\r\n        pivotTables: booleanToXml(model.pivotTables, '0'),\r\n      };\r\n      if (model.sheet) {\r\n        attributes.algorithmName = model.algorithmName;\r\n        attributes.hashValue = model.hashValue;\r\n        attributes.saltValue = model.saltValue;\r\n        attributes.spinCount = model.spinCount;\r\n        attributes.objects = booleanToXml(model.objects === false, '1');\r\n        attributes.scenarios = booleanToXml(model.scenarios === false, '1');\r\n      }\r\n      if (_.some(attributes, value => value !== undefined)) {\r\n        xmlStream.leafNode(this.tag, attributes);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          sheet: xmlToBoolean(node.attributes.sheet, '1'),\r\n          objects: node.attributes.objects === '1' ? false : undefined,\r\n          scenarios: node.attributes.scenarios === '1' ? false : undefined,\r\n          selectLockedCells: node.attributes.selectLockedCells === '1' ? false : undefined,\r\n          selectUnlockedCells: node.attributes.selectUnlockedCells === '1' ? false : undefined,\r\n          formatCells: xmlToBoolean(node.attributes.formatCells, '0'),\r\n          formatColumns: xmlToBoolean(node.attributes.formatColumns, '0'),\r\n          formatRows: xmlToBoolean(node.attributes.formatRows, '0'),\r\n          insertColumns: xmlToBoolean(node.attributes.insertColumns, '0'),\r\n          insertRows: xmlToBoolean(node.attributes.insertRows, '0'),\r\n          insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, '0'),\r\n          deleteColumns: xmlToBoolean(node.attributes.deleteColumns, '0'),\r\n          deleteRows: xmlToBoolean(node.attributes.deleteRows, '0'),\r\n          sort: xmlToBoolean(node.attributes.sort, '0'),\r\n          autoFilter: xmlToBoolean(node.attributes.autoFilter, '0'),\r\n          pivotTables: xmlToBoolean(node.attributes.pivotTables, '0'),\r\n        };\r\n        if (node.attributes.algorithmName) {\r\n          this.model.algorithmName = node.attributes.algorithmName;\r\n          this.model.hashValue = node.attributes.hashValue;\r\n          this.model.saltValue = node.attributes.saltValue;\r\n          this.model.spinCount = parseInt(node.attributes.spinCount, 10);\r\n        }\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = SheetProtectionXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\nclass PageMarginsXform extends BaseXform {\r\n  get tag() {\r\n    return 'pageMargins';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      const attributes = {\r\n        left: model.left,\r\n        right: model.right,\r\n        top: model.top,\r\n        bottom: model.bottom,\r\n        header: model.header,\r\n        footer: model.footer,\r\n      };\r\n      if (_.some(attributes, value => value !== undefined)) {\r\n        xmlStream.leafNode(this.tag, attributes);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          left: parseFloat(node.attributes.left || 0.7),\r\n          right: parseFloat(node.attributes.right || 0.7),\r\n          top: parseFloat(node.attributes.top || 0.75),\r\n          bottom: parseFloat(node.attributes.bottom || 0.75),\r\n          header: parseFloat(node.attributes.header || 0.3),\r\n          footer: parseFloat(node.attributes.footer || 0.3),\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PageMarginsXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\nfunction booleanToXml(model) {\r\n  return model ? '1' : undefined;\r\n}\r\nfunction pageOrderToXml(model) {\r\n  switch (model) {\r\n    case 'overThenDown':\r\n      return model;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\nfunction cellCommentsToXml(model) {\r\n  switch (model) {\r\n    case 'atEnd':\r\n    case 'asDisplyed':\r\n      return model;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\nfunction errorsToXml(model) {\r\n  switch (model) {\r\n    case 'dash':\r\n    case 'blank':\r\n    case 'NA':\r\n      return model;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\nfunction pageSizeToModel(value) {\r\n  return value !== undefined ? parseInt(value, 10) : undefined;\r\n}\r\n\r\nclass PageSetupXform extends BaseXform {\r\n  get tag() {\r\n    return 'pageSetup';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      const attributes = {\r\n        paperSize: model.paperSize,\r\n        orientation: model.orientation,\r\n        horizontalDpi: model.horizontalDpi,\r\n        verticalDpi: model.verticalDpi,\r\n        pageOrder: pageOrderToXml(model.pageOrder),\r\n        blackAndWhite: booleanToXml(model.blackAndWhite),\r\n        draft: booleanToXml(model.draft),\r\n        cellComments: cellCommentsToXml(model.cellComments),\r\n        errors: errorsToXml(model.errors),\r\n        scale: model.scale,\r\n        fitToWidth: model.fitToWidth,\r\n        fitToHeight: model.fitToHeight,\r\n        firstPageNumber: model.firstPageNumber,\r\n        useFirstPageNumber: booleanToXml(model.firstPageNumber),\r\n        usePrinterDefaults: booleanToXml(model.usePrinterDefaults),\r\n        copies: model.copies,\r\n      };\r\n      if (_.some(attributes, value => value !== undefined)) {\r\n        xmlStream.leafNode(this.tag, attributes);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          paperSize: pageSizeToModel(node.attributes.paperSize),\r\n          orientation: node.attributes.orientation || 'portrait',\r\n          horizontalDpi: parseInt(node.attributes.horizontalDpi || '4294967295', 10),\r\n          verticalDpi: parseInt(node.attributes.verticalDpi || '4294967295', 10),\r\n          pageOrder: node.attributes.pageOrder || 'downThenOver',\r\n          blackAndWhite: node.attributes.blackAndWhite === '1',\r\n          draft: node.attributes.draft === '1',\r\n          cellComments: node.attributes.cellComments || 'None',\r\n          errors: node.attributes.errors || 'displayed',\r\n          scale: parseInt(node.attributes.scale || '100', 10),\r\n          fitToWidth: parseInt(node.attributes.fitToWidth || '1', 10),\r\n          fitToHeight: parseInt(node.attributes.fitToHeight || '1', 10),\r\n          firstPageNumber: parseInt(node.attributes.firstPageNumber || '1', 10),\r\n          useFirstPageNumber: node.attributes.useFirstPageNumber === '1',\r\n          usePrinterDefaults: node.attributes.usePrinterDefaults === '1',\r\n          copies: parseInt(node.attributes.copies || '1', 10),\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PageSetupXform;\r\n","const _ = require('../../../utils/under-dash');\r\nconst BaseXform = require('../base-xform');\r\n\r\nfunction booleanToXml(model) {\r\n  return model ? '1' : undefined;\r\n}\r\n\r\nclass PrintOptionsXform extends BaseXform {\r\n  get tag() {\r\n    return 'printOptions';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      const attributes = {\r\n        headings: booleanToXml(model.showRowColHeaders),\r\n        gridLines: booleanToXml(model.showGridLines),\r\n        horizontalCentered: booleanToXml(model.horizontalCentered),\r\n        verticalCentered: booleanToXml(model.verticalCentered),\r\n      };\r\n      if (_.some(attributes, value => value !== undefined)) {\r\n        xmlStream.leafNode(this.tag, attributes);\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          showRowColHeaders: node.attributes.headings === '1',\r\n          showGridLines: node.attributes.gridLines === '1',\r\n          horizontalCentered: node.attributes.horizontalCentered === '1',\r\n          verticalCentered: node.attributes.verticalCentered === '1',\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PrintOptionsXform;\r\n","const colCache = require('../../../utils/col-cache');\r\nconst BaseXform = require('../base-xform');\r\n\r\nclass AutoFilterXform extends BaseXform {\r\n  get tag() {\r\n    return 'autoFilter';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      if (typeof model === 'string') {\r\n        // assume range\r\n        xmlStream.leafNode('autoFilter', {ref: model});\r\n      } else {\r\n        const getAddress = function(addr) {\r\n          if (typeof addr === 'string') {\r\n            return addr;\r\n          }\r\n          return colCache.getAddress(addr.row, addr.column).address;\r\n        };\r\n\r\n        const firstAddress = getAddress(model.from);\r\n        const secondAddress = getAddress(model.to);\r\n        if (firstAddress && secondAddress) {\r\n          xmlStream.leafNode('autoFilter', {ref: `${firstAddress}:${secondAddress}`});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'autoFilter') {\r\n      this.model = node.attributes.ref;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = AutoFilterXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass PictureXform extends BaseXform {\r\n  get tag() {\r\n    return 'picture';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          rId: node.attributes['r:id'],\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PictureXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass DrawingXform extends BaseXform {\r\n  get tag() {\r\n    return 'drawing';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          rId: node.attributes['r:id'],\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = DrawingXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass TablePartXform extends BaseXform {\r\n  get tag() {\r\n    return 'tablePart';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          rId: node.attributes['r:id'],\r\n        };\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = TablePartXform;\r\n","\r\n\r\nconst PageBreaksXform = require('./page-breaks-xform');\r\n\r\nconst ListXform = require('../list-xform');\r\n\r\nclass RowBreaksXform extends ListXform {\r\n  constructor() {\r\n    const options = {\r\n      tag: 'rowBreaks',\r\n      count: true,\r\n      childXform: new PageBreaksXform(),\r\n    };\r\n    super(options);\r\n  }\r\n\r\n  // get tag() { return 'rowBreaks'; }\r\n\r\n  render(xmlStream, model) {\r\n    if (model && model.length) {\r\n      xmlStream.openNode(this.tag, this.$);\r\n      if (this.count) {\r\n        xmlStream.addAttribute(this.$count, model.length);\r\n        xmlStream.addAttribute('manualBreakCount', model.length);\r\n      }\r\n\r\n      const {childXform} = this;\r\n      model.forEach(childModel => {\r\n        childXform.render(xmlStream, childModel);\r\n      });\r\n\r\n      xmlStream.closeNode();\r\n    } else if (this.empty) {\r\n      xmlStream.leafNode(this.tag);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = RowBreaksXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass PageBreaksXform extends BaseXform {\r\n  get tag() {\r\n    return 'brk';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode('brk', model);\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === 'brk') {\r\n      this.model = node.attributes.ref;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = PageBreaksXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass HeaderFooterXform extends BaseXform {\r\n  get tag() {\r\n    return 'headerFooter';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model) {\r\n      xmlStream.addRollback();\r\n\r\n      let createTag = false;\r\n\r\n      xmlStream.openNode('headerFooter');\r\n      if (model.differentFirst) {\r\n        xmlStream.addAttribute('differentFirst', '1');\r\n        createTag = true;\r\n      }\r\n      if (model.differentOddEven) {\r\n        xmlStream.addAttribute('differentOddEven', '1');\r\n        createTag = true;\r\n      }\r\n      if (model.oddHeader && typeof model.oddHeader === 'string') {\r\n        xmlStream.leafNode('oddHeader', null, model.oddHeader);\r\n        createTag = true;\r\n      }\r\n      if (model.oddFooter && typeof model.oddFooter === 'string') {\r\n        xmlStream.leafNode('oddFooter', null, model.oddFooter);\r\n        createTag = true;\r\n      }\r\n      if (model.evenHeader && typeof model.evenHeader === 'string') {\r\n        xmlStream.leafNode('evenHeader', null, model.evenHeader);\r\n        createTag = true;\r\n      }\r\n      if (model.evenFooter && typeof model.evenFooter === 'string') {\r\n        xmlStream.leafNode('evenFooter', null, model.evenFooter);\r\n        createTag = true;\r\n      }\r\n      if (model.firstHeader && typeof model.firstHeader === 'string') {\r\n        xmlStream.leafNode('firstHeader', null, model.firstHeader);\r\n        createTag = true;\r\n      }\r\n      if (model.firstFooter && typeof model.firstFooter === 'string') {\r\n        xmlStream.leafNode('firstFooter', null, model.firstFooter);\r\n        createTag = true;\r\n      }\r\n\r\n      if (createTag) {\r\n        xmlStream.closeNode();\r\n        xmlStream.commit();\r\n      } else {\r\n        xmlStream.rollback();\r\n      }\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'headerFooter':\r\n        this.model = {};\r\n        if (node.attributes.differentFirst) {\r\n          this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;\r\n        }\r\n        if (node.attributes.differentOddEven) {\r\n          this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;\r\n        }\r\n        return true;\r\n\r\n      case 'oddHeader':\r\n        this.currentNode = 'oddHeader';\r\n        return true;\r\n\r\n      case 'oddFooter':\r\n        this.currentNode = 'oddFooter';\r\n        return true;\r\n\r\n      case 'evenHeader':\r\n        this.currentNode = 'evenHeader';\r\n        return true;\r\n\r\n      case 'evenFooter':\r\n        this.currentNode = 'evenFooter';\r\n        return true;\r\n\r\n      case 'firstHeader':\r\n        this.currentNode = 'firstHeader';\r\n        return true;\r\n\r\n      case 'firstFooter':\r\n        this.currentNode = 'firstFooter';\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    switch (this.currentNode) {\r\n      case 'oddHeader':\r\n        this.model.oddHeader = text;\r\n        break;\r\n\r\n      case 'oddFooter':\r\n        this.model.oddFooter = text;\r\n        break;\r\n\r\n      case 'evenHeader':\r\n        this.model.evenHeader = text;\r\n        break;\r\n\r\n      case 'evenFooter':\r\n        this.model.evenFooter = text;\r\n        break;\r\n\r\n      case 'firstHeader':\r\n        this.model.firstHeader = text;\r\n        break;\r\n\r\n      case 'firstFooter':\r\n        this.model.firstFooter = text;\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  parseClose() {\r\n    switch (this.currentNode) {\r\n      case 'oddHeader':\r\n      case 'oddFooter':\r\n      case 'evenHeader':\r\n      case 'evenFooter':\r\n      case 'firstHeader':\r\n      case 'firstFooter':\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = HeaderFooterXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nconst ConditionalFormattingXform = require('./conditional-formatting-xform');\r\n\r\nclass ConditionalFormattingsXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.cfXform = new ConditionalFormattingXform();\r\n  }\r\n\r\n  get tag() {\r\n    return 'conditionalFormatting';\r\n  }\r\n\r\n  reset() {\r\n    this.model = [];\r\n  }\r\n\r\n  prepare(model, options) {\r\n    // ensure each rule has a priority value\r\n    let nextPriority = model.reduce(\r\n      (p, cf) => Math.max(p, ...cf.rules.map(rule => rule.priority || 0)),\r\n      1\r\n    );\r\n    model.forEach(cf => {\r\n      cf.rules.forEach(rule => {\r\n        if (!rule.priority) {\r\n          rule.priority = nextPriority++;\r\n        }\r\n\r\n        if (rule.style) {\r\n          rule.dxfId = options.styles.addDxfStyle(rule.style);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    model.forEach(cf => {\r\n      this.cfXform.render(xmlStream, cf);\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case 'conditionalFormatting':\r\n        this.parser = this.cfXform;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.push(this.parser.model);\r\n        this.parser = undefined;\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.forEach(cf => {\r\n      cf.rules.forEach(rule => {\r\n        if (rule.dxfId !== undefined) {\r\n          rule.style = options.styles.getDxfStyle(rule.dxfId);\r\n          delete rule.dxfId;\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = ConditionalFormattingsXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst CfRuleXform = require('./cf-rule-xform');\r\n\r\nclass ConditionalFormattingXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      cfRule: new CfRuleXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'conditionalFormatting';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    // if there are no primitive rules, exit now\r\n    if (!model.rules.some(CfRuleXform.isPrimitive)) {\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode(this.tag, {sqref: model.ref});\r\n\r\n    model.rules.forEach(rule => {\r\n      if (CfRuleXform.isPrimitive(rule)) {\r\n        rule.ref = model.ref;\r\n        this.map.cfRule.render(xmlStream, rule);\r\n      }\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      ref: attributes.sqref,\r\n      rules: [],\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    this.model.rules.push(parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = ConditionalFormattingXform;\r\n","const BaseXform = require('./base-xform');\r\n\r\n/* 'virtual' methods used as a form of documentation */\r\n/* eslint-disable class-methods-use-this */\r\n\r\n// base class for xforms that are composed of other xforms\r\n// offers some default implementations\r\nclass CompositeXform extends BaseXform {\r\n  createNewModel(node) {\r\n    return {};\r\n  }\r\n\r\n  parseOpen(node) {\r\n    // Typical pattern for composite xform\r\n    this.parser = this.parser || this.map[node.name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    if (node.name === this.tag) {\r\n      this.model = this.createNewModel(node);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    // Default implementation. Send text to child parser\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    // parseClose has seen a child parser close\r\n    // now need to incorporate into this.model somehow\r\n    this.model[name] = parser.model;\r\n  }\r\n\r\n  parseClose(name) {\r\n    // Default implementation\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.onParserClose(name, this.parser);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = CompositeXform;\r\n","const BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst Range = require('../../../../doc/range');\r\n\r\nconst DatabarXform = require('./databar-xform');\r\nconst ExtLstRefXform = require('./ext-lst-ref-xform');\r\nconst FormulaXform = require('./formula-xform');\r\nconst ColorScaleXform = require('./color-scale-xform');\r\nconst IconSetXform = require('./icon-set-xform');\r\n\r\nconst extIcons = {\r\n  '3Triangles': true,\r\n  '3Stars': true,\r\n  '5Boxes': true,\r\n};\r\n\r\nconst getTextFormula = model => {\r\n  if (model.formulae && model.formulae[0]) {\r\n    return model.formulae[0];\r\n  }\r\n\r\n  const range = new Range(model.ref);\r\n  const {tl} = range;\r\n  switch (model.operator) {\r\n    case 'containsText':\r\n      return `NOT(ISERROR(SEARCH(\"${model.text}\",${tl})))`;\r\n    case 'containsBlanks':\r\n      return `LEN(TRIM(${tl}))=0`;\r\n    case 'notContainsBlanks':\r\n      return `LEN(TRIM(${tl}))>0`;\r\n    case 'containsErrors':\r\n      return `ISERROR(${tl})`;\r\n    case 'notContainsErrors':\r\n      return `NOT(ISERROR(${tl}))`;\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\nconst getTimePeriodFormula = model => {\r\n  if (model.formulae && model.formulae[0]) {\r\n    return model.formulae[0];\r\n  }\r\n\r\n  const range = new Range(model.ref);\r\n  const {tl} = range;\r\n  switch (model.timePeriod) {\r\n    case 'thisWeek':\r\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;\r\n    case 'lastWeek':\r\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;\r\n    case 'nextWeek':\r\n      return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;\r\n    case 'yesterday':\r\n      return `FLOOR(${tl},1)=TODAY()-1`;\r\n    case 'today':\r\n      return `FLOOR(${tl},1)=TODAY()`;\r\n    case 'tomorrow':\r\n      return `FLOOR(${tl},1)=TODAY()+1`;\r\n    case 'last7Days':\r\n      return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;\r\n    case 'lastMonth':\r\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;\r\n    case 'thisMonth':\r\n      return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;\r\n    case 'nextMonth':\r\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\nconst opType = attributes => {\r\n  const {type, operator} = attributes;\r\n  switch (type) {\r\n    case 'containsText':\r\n    case 'containsBlanks':\r\n    case 'notContainsBlanks':\r\n    case 'containsErrors':\r\n    case 'notContainsErrors':\r\n      return {\r\n        type: 'containsText',\r\n        operator: type,\r\n      };\r\n\r\n    default:\r\n      return {type, operator};\r\n  }\r\n};\r\n\r\nclass CfRuleXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      dataBar: (this.databarXform = new DatabarXform()),\r\n      extLst: (this.extLstRefXform = new ExtLstRefXform()),\r\n      formula: (this.formulaXform = new FormulaXform()),\r\n      colorScale: (this.colorScaleXform = new ColorScaleXform()),\r\n      iconSet: (this.iconSetXform = new IconSetXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'cfRule';\r\n  }\r\n\r\n  static isPrimitive(rule) {\r\n    // is this rule primitive?\r\n    if (rule.type === 'iconSet') {\r\n      if (rule.custom || extIcons[rule.iconSet]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    switch (model.type) {\r\n      case 'expression':\r\n        this.renderExpression(xmlStream, model);\r\n        break;\r\n      case 'cellIs':\r\n        this.renderCellIs(xmlStream, model);\r\n        break;\r\n      case 'top10':\r\n        this.renderTop10(xmlStream, model);\r\n        break;\r\n      case 'aboveAverage':\r\n        this.renderAboveAverage(xmlStream, model);\r\n        break;\r\n      case 'dataBar':\r\n        this.renderDataBar(xmlStream, model);\r\n        break;\r\n      case 'colorScale':\r\n        this.renderColorScale(xmlStream, model);\r\n        break;\r\n      case 'iconSet':\r\n        this.renderIconSet(xmlStream, model);\r\n        break;\r\n      case 'containsText':\r\n        this.renderText(xmlStream, model);\r\n        break;\r\n      case 'timePeriod':\r\n        this.renderTimePeriod(xmlStream, model);\r\n        break;\r\n    }\r\n  }\r\n\r\n  renderExpression(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'expression',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.formulaXform.render(xmlStream, model.formulae[0]);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderCellIs(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'cellIs',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      operator: model.operator,\r\n    });\r\n\r\n    model.formulae.forEach(formula => {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderTop10(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      type: 'top10',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      percent: BaseXform.toBoolAttribute(model.percent, false),\r\n      bottom: BaseXform.toBoolAttribute(model.bottom, false),\r\n      rank: BaseXform.toIntValue(model.rank, 10, true),\r\n    });\r\n  }\r\n\r\n  renderAboveAverage(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      type: 'aboveAverage',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true),\r\n    });\r\n  }\r\n\r\n  renderDataBar(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'dataBar',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.databarXform.render(xmlStream, model);\r\n    this.extLstRefXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderColorScale(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'colorScale',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.colorScaleXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderIconSet(xmlStream, model) {\r\n    // iconset is all primitive or all extLst\r\n    if (!CfRuleXform.isPrimitive(model)) {\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'iconSet',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.iconSetXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderText(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: model.operator,\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      operator: BaseXform.toStringAttribute(model.operator, 'containsText'),\r\n    });\r\n\r\n    const formula = getTextFormula(model);\r\n    if (formula) {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderTimePeriod(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'timePeriod',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      timePeriod: model.timePeriod,\r\n    });\r\n\r\n    const formula = getTimePeriodFormula(model);\r\n    if (formula) {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      ...opType(attributes),\r\n      dxfId: BaseXform.toIntValue(attributes.dxfId),\r\n      priority: BaseXform.toIntValue(attributes.priority),\r\n      timePeriod: attributes.timePeriod,\r\n      percent: BaseXform.toBoolValue(attributes.percent),\r\n      bottom: BaseXform.toBoolValue(attributes.bottom),\r\n      rank: BaseXform.toIntValue(attributes.rank),\r\n      aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage),\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    switch (name) {\r\n      case 'dataBar':\r\n      case 'extLst':\r\n      case 'colorScale':\r\n      case 'iconSet':\r\n        // merge parser model with ours\r\n        Object.assign(this.model, parser.model);\r\n        break;\r\n\r\n      case 'formula':\r\n        // except - formula is a string and appends to formulae\r\n        this.model.formulae = this.model.formulae || [];\r\n        this.model.formulae.push(parser.model);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CfRuleXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst ColorXform = require('../../style/color-xform');\r\nconst CfvoXform = require('./cfvo-xform');\r\n\r\nclass DatabarXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      cfvo: (this.cfvoXform = new CfvoXform()),\r\n      color: (this.colorXform = new ColorXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'dataBar';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    model.cfvo.forEach(cfvo => {\r\n      this.cfvoXform.render(xmlStream, cfvo);\r\n    });\r\n    this.colorXform.render(xmlStream, model.color);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {\r\n      cfvo: [],\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    switch (name) {\r\n      case 'cfvo':\r\n        this.model.cfvo.push(parser.model);\r\n        break;\r\n      case 'color':\r\n        this.model.color = parser.model;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = DatabarXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass CfvoXform extends BaseXform {\r\n  get tag() {\r\n    return 'cfvo';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      type: model.type,\r\n      val: model.value,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    this.model = {\r\n      type: node.attributes.type,\r\n      value: BaseXform.toFloatValue(node.attributes.val),\r\n    };\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = CfvoXform;\r\n","/* eslint-disable max-classes-per-file */\r\nconst BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nclass X14IdXform extends BaseXform {\r\n  get tag() {\r\n    return 'x14:id';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, null, model);\r\n  }\r\n\r\n  parseOpen() {\r\n    this.model = '';\r\n  }\r\n\r\n  parseText(text) {\r\n    this.model += text;\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nclass ExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'x14:id': (this.idXform = new X14IdXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'ext';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      uri: '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}',\r\n      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\r\n    });\r\n\r\n    this.idXform.render(xmlStream, model.x14Id);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {};\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    this.model.x14Id = parser.model;\r\n  }\r\n}\r\n\r\nclass ExtLstRefXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n    this.map = {\r\n      ext: new ExtXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'extLst';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n    this.map.ext.render(xmlStream, model);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {};\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    Object.assign(this.model, parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = ExtLstRefXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass FormulaXform extends BaseXform {\r\n  get tag() {\r\n    return 'formula';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, null, model);\r\n  }\r\n\r\n  parseOpen() {\r\n    this.model = '';\r\n  }\r\n\r\n  parseText(text) {\r\n    this.model += text;\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = FormulaXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst ColorXform = require('../../style/color-xform');\r\nconst CfvoXform = require('./cfvo-xform');\r\n\r\nclass ColorScaleXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      cfvo: (this.cfvoXform = new CfvoXform()),\r\n      color: (this.colorXform = new ColorXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'colorScale';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    model.cfvo.forEach(cfvo => {\r\n      this.cfvoXform.render(xmlStream, cfvo);\r\n    });\r\n    model.color.forEach(color => {\r\n      this.colorXform.render(xmlStream, color);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel(node) {\r\n    return {\r\n      cfvo: [],\r\n      color: [],\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    this.model[name].push(parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = ColorScaleXform;\r\n","const BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst CfvoXform = require('./cfvo-xform');\r\n\r\nclass IconSetXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      cfvo: (this.cfvoXform = new CfvoXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'iconSet';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      iconSet: BaseXform.toStringAttribute(model.iconSet, '3TrafficLights'),\r\n      reverse: BaseXform.toBoolAttribute(model.reverse, false),\r\n      showValue: BaseXform.toBoolAttribute(model.showValue, true),\r\n    });\r\n\r\n    model.cfvo.forEach(cfvo => {\r\n      this.cfvoXform.render(xmlStream, cfvo);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      iconSet: BaseXform.toStringValue(attributes.iconSet, '3TrafficLights'),\r\n      reverse: BaseXform.toBoolValue(attributes.reverse),\r\n      showValue: BaseXform.toBoolValue(attributes.showValue),\r\n      cfvo: [],\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    this.model[name].push(parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = IconSetXform;\r\n","/* eslint-disable max-classes-per-file */\r\nconst CompositeXform = require('../composite-xform');\r\n\r\nconst ConditionalFormattingsExt = require('./cf-ext/conditional-formattings-ext-xform');\r\n\r\nclass ExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n    this.map = {\r\n      'x14:conditionalFormattings': (this.conditionalFormattings = new ConditionalFormattingsExt()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'ext';\r\n  }\r\n\r\n  hasContent(model) {\r\n    return this.conditionalFormattings.hasContent(model.conditionalFormattings);\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.conditionalFormattings.prepare(model.conditionalFormattings, options);\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('ext', {\r\n      uri: '{78C0D931-6437-407d-A8EE-F0AAD7539E65}',\r\n      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\r\n    });\r\n\r\n    this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {};\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    this.model[name] = parser.model;\r\n  }\r\n}\r\n\r\nclass ExtLstXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      ext: (this.ext = new ExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'extLst';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.ext.prepare(model, options);\r\n  }\r\n\r\n  hasContent(model) {\r\n    return this.ext.hasContent(model);\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (!this.hasContent(model)) {\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode('extLst');\r\n    this.ext.render(xmlStream, model);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {};\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    Object.assign(this.model, parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = ExtLstXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst CfRuleExtXform = require('./cf-rule-ext-xform');\r\nconst ConditionalFormattingExtXform = require('./conditional-formatting-ext-xform');\r\n\r\nclass ConditionalFormattingsExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'x14:conditionalFormatting': (this.cfXform = new ConditionalFormattingExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:conditionalFormattings';\r\n  }\r\n\r\n  hasContent(model) {\r\n    if (model.hasExtContent === undefined) {\r\n      model.hasExtContent = model.some(cf => cf.rules.some(CfRuleExtXform.isExt));\r\n    }\r\n    return model.hasExtContent;\r\n  }\r\n\r\n  prepare(model, options) {\r\n    model.forEach(cf => {\r\n      this.cfXform.prepare(cf, options);\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (this.hasContent(model)) {\r\n      xmlStream.openNode(this.tag);\r\n      model.forEach(cf => this.cfXform.render(xmlStream, cf));\r\n      xmlStream.closeNode();\r\n    }\r\n  }\r\n\r\n  createNewModel() {\r\n    return [];\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    // model is array of conditional formatting objects\r\n    this.model.push(parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = ConditionalFormattingsExtXform;\r\n","const {v4: uuidv4} = require('uuid');\r\nconst BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst DatabarExtXform = require('./databar-ext-xform');\r\nconst IconSetExtXform = require('./icon-set-ext-xform');\r\n\r\nconst extIcons = {\r\n  '3Triangles': true,\r\n  '3Stars': true,\r\n  '5Boxes': true,\r\n};\r\n\r\nclass CfRuleExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'x14:dataBar': (this.databarXform = new DatabarExtXform()),\r\n      'x14:iconSet': (this.iconSetXform = new IconSetExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:cfRule';\r\n  }\r\n\r\n  static isExt(rule) {\r\n    // is this rule primitive?\r\n    if (rule.type === 'dataBar') {\r\n      return DatabarExtXform.isExt(rule);\r\n    }\r\n    if (rule.type === 'iconSet') {\r\n      if (rule.custom || extIcons[rule.iconSet]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  prepare(model) {\r\n    if (CfRuleExtXform.isExt(model)) {\r\n      model.x14Id = `{${uuidv4()}}`.toUpperCase();\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (!CfRuleExtXform.isExt(model)) {\r\n      return;\r\n    }\r\n\r\n    switch (model.type) {\r\n      case 'dataBar':\r\n        this.renderDataBar(xmlStream, model);\r\n        break;\r\n      case 'iconSet':\r\n        this.renderIconSet(xmlStream, model);\r\n        break;\r\n    }\r\n  }\r\n\r\n  renderDataBar(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'dataBar',\r\n      id: model.x14Id,\r\n    });\r\n\r\n    this.databarXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderIconSet(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'iconSet',\r\n      priority: model.priority,\r\n      id: model.x14Id || `{${uuidv4()}}`,\r\n    });\r\n\r\n    this.iconSetXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      type: attributes.type,\r\n      x14Id: attributes.id,\r\n      priority: BaseXform.toIntValue(attributes.priority),\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    Object.assign(this.model, parser.model);\r\n  }\r\n}\r\n\r\nmodule.exports = CfRuleExtXform;\r\n","const BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst ColorXform = require('../../style/color-xform');\r\nconst CfvoExtXform = require('./cfvo-ext-xform');\r\n\r\nclass DatabarExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'x14:cfvo': (this.cfvoXform = new CfvoExtXform()),\r\n      'x14:borderColor': (this.borderColorXform = new ColorXform('x14:borderColor')),\r\n      'x14:negativeBorderColor': (this.negativeBorderColorXform = new ColorXform(\r\n        'x14:negativeBorderColor'\r\n      )),\r\n      'x14:negativeFillColor': (this.negativeFillColorXform = new ColorXform(\r\n        'x14:negativeFillColor'\r\n      )),\r\n      'x14:axisColor': (this.axisColorXform = new ColorXform('x14:axisColor')),\r\n    };\r\n  }\r\n\r\n  static isExt(rule) {\r\n    // not all databars need ext\r\n    // TODO: refine this\r\n    return !rule.gradient;\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:dataBar';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      minLength: BaseXform.toIntAttribute(model.minLength, 0, true),\r\n      maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true),\r\n      border: BaseXform.toBoolAttribute(model.border, false),\r\n      gradient: BaseXform.toBoolAttribute(model.gradient, true),\r\n      negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(\r\n        model.negativeBarColorSameAsPositive,\r\n        true\r\n      ),\r\n      negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(\r\n        model.negativeBarBorderColorSameAsPositive,\r\n        true\r\n      ),\r\n      axisPosition: BaseXform.toAttribute(model.axisPosition, 'auto'),\r\n      direction: BaseXform.toAttribute(model.direction, 'leftToRight'),\r\n    });\r\n\r\n    model.cfvo.forEach(cfvo => {\r\n      this.cfvoXform.render(xmlStream, cfvo);\r\n    });\r\n\r\n    this.borderColorXform.render(xmlStream, model.borderColor);\r\n    this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);\r\n    this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);\r\n    this.axisColorXform.render(xmlStream, model.axisColor);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      cfvo: [],\r\n      minLength: BaseXform.toIntValue(attributes.minLength, 0),\r\n      maxLength: BaseXform.toIntValue(attributes.maxLength, 100),\r\n      border: BaseXform.toBoolValue(attributes.border, false),\r\n      gradient: BaseXform.toBoolValue(attributes.gradient, true),\r\n      negativeBarColorSameAsPositive: BaseXform.toBoolValue(\r\n        attributes.negativeBarColorSameAsPositive,\r\n        true\r\n      ),\r\n      negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(\r\n        attributes.negativeBarBorderColorSameAsPositive,\r\n        true\r\n      ),\r\n      axisPosition: BaseXform.toStringValue(attributes.axisPosition, 'auto'),\r\n      direction: BaseXform.toStringValue(attributes.direction, 'leftToRight'),\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    const [, prop] = name.split(':');\r\n    switch (prop) {\r\n      case 'cfvo':\r\n        this.model.cfvo.push(parser.model);\r\n        break;\r\n\r\n      default:\r\n        this.model[prop] = parser.model;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = DatabarExtXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst FExtXform = require('./f-ext-xform');\r\n\r\nclass CfvoExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xm:f': (this.fExtXform = new FExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:cfvo';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: model.type,\r\n    });\r\n    if (model.value !== undefined) {\r\n      this.fExtXform.render(xmlStream, model.value);\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel(node) {\r\n    return {\r\n      type: node.attributes.type,\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    switch (name) {\r\n      case 'xm:f':\r\n        this.model.value = parser.model ? parseFloat(parser.model) : 0;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CfvoExtXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass FExtXform extends BaseXform {\r\n  get tag() {\r\n    return 'xm:f';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, null, model);\r\n  }\r\n\r\n  parseOpen() {\r\n    this.model = '';\r\n  }\r\n\r\n  parseText(text) {\r\n    this.model += text;\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = FExtXform;\r\n","const BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst CfvoExtXform = require('./cfvo-ext-xform');\r\nconst CfIconExtXform = require('./cf-icon-ext-xform');\r\n\r\nclass IconSetExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'x14:cfvo': (this.cfvoXform = new CfvoExtXform()),\r\n      'x14:cfIcon': (this.cfIconXform = new CfIconExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:iconSet';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      iconSet: BaseXform.toStringAttribute(model.iconSet),\r\n      reverse: BaseXform.toBoolAttribute(model.reverse, false),\r\n      showValue: BaseXform.toBoolAttribute(model.showValue, true),\r\n      custom: BaseXform.toBoolAttribute(model.icons, false),\r\n    });\r\n\r\n    model.cfvo.forEach(cfvo => {\r\n      this.cfvoXform.render(xmlStream, cfvo);\r\n    });\r\n\r\n    if (model.icons) {\r\n      model.icons.forEach((icon, i) => {\r\n        icon.iconId = i;\r\n        this.cfIconXform.render(xmlStream, icon);\r\n      });\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      cfvo: [],\r\n      iconSet: BaseXform.toStringValue(attributes.iconSet, '3TrafficLights'),\r\n      reverse: BaseXform.toBoolValue(attributes.reverse, false),\r\n      showValue: BaseXform.toBoolValue(attributes.showValue, true),\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    const [, prop] = name.split(':');\r\n    switch (prop) {\r\n      case 'cfvo':\r\n        this.model.cfvo.push(parser.model);\r\n        break;\r\n\r\n      case 'cfIcon':\r\n        if (!this.model.icons) {\r\n          this.model.icons = [];\r\n        }\r\n        this.model.icons.push(parser.model);\r\n        break;\r\n\r\n      default:\r\n        this.model[prop] = parser.model;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = IconSetExtXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass CfIconExtXform extends BaseXform {\r\n  get tag() {\r\n    return 'x14:cfIcon';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      iconSet: model.iconSet,\r\n      iconId: model.iconId,\r\n    });\r\n  }\r\n\r\n  parseOpen({attributes}) {\r\n    this.model = {\r\n      iconSet: attributes.iconSet,\r\n      iconId: BaseXform.toIntValue(attributes.iconId),\r\n    };\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = CfIconExtXform;\r\n","const CompositeXform = require('../../composite-xform');\r\n\r\nconst SqRefExtXform = require('./sqref-ext-xform');\r\nconst CfRuleExtXform = require('./cf-rule-ext-xform');\r\n\r\nclass ConditionalFormattingExtXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xm:sqref': (this.sqRef = new SqRefExtXform()),\r\n      'x14:cfRule': (this.cfRule = new CfRuleExtXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x14:conditionalFormatting';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    model.rules.forEach(rule => {\r\n      this.cfRule.prepare(rule, options);\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (!model.rules.some(CfRuleExtXform.isExt)) {\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode(this.tag, {\r\n      'xmlns:xm': 'http://schemas.microsoft.com/office/excel/2006/main',\r\n    });\r\n\r\n    model.rules.filter(CfRuleExtXform.isExt).forEach(rule => this.cfRule.render(xmlStream, rule));\r\n\r\n    // for some odd reason, Excel needs the <xm:sqref> node to be after the rules\r\n    this.sqRef.render(xmlStream, model.ref);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel() {\r\n    return {\r\n      rules: [],\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    switch (name) {\r\n      case 'xm:sqref':\r\n        this.model.ref = parser.model;\r\n        break;\r\n\r\n      case 'x14:cfRule':\r\n        this.model.rules.push(parser.model);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = ConditionalFormattingExtXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass SqrefExtXform extends BaseXform {\r\n  get tag() {\r\n    return 'xm:sqref';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, null, model);\r\n  }\r\n\r\n  parseOpen() {\r\n    this.model = '';\r\n  }\r\n\r\n  parseText(text) {\r\n    this.model += text;\r\n  }\r\n\r\n  parseClose(name) {\r\n    return name !== this.tag;\r\n  }\r\n}\r\n\r\nmodule.exports = SqrefExtXform;\r\n","const colCache = require('../../../utils/col-cache');\r\nconst XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst TwoCellAnchorXform = require('./two-cell-anchor-xform');\r\nconst OneCellAnchorXform = require('./one-cell-anchor-xform');\r\n\r\nfunction getAnchorType(model) {\r\n  const range = typeof model.range === 'string' ? colCache.decode(model.range) : model.range;\r\n\r\n  return range.br ? 'xdr:twoCellAnchor' : 'xdr:oneCellAnchor';\r\n}\r\n\r\nclass DrawingXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xdr:twoCellAnchor': new TwoCellAnchorXform(),\r\n      'xdr:oneCellAnchor': new OneCellAnchorXform(),\r\n    };\r\n  }\r\n\r\n  prepare(model) {\r\n    model.anchors.forEach((item, index) => {\r\n      item.anchorType = getAnchorType(item);\r\n      const anchor = this.map[item.anchorType];\r\n      anchor.prepare(item, {index});\r\n    });\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:wsDr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode(this.tag, DrawingXform.DRAWING_ATTRIBUTES);\r\n\r\n    model.anchors.forEach(item => {\r\n      const anchor = this.map[item.anchorType];\r\n      anchor.render(xmlStream, item);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          anchors: [],\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.anchors.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.anchors.forEach(anchor => {\r\n      if (anchor.br) {\r\n        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);\r\n      } else {\r\n        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nDrawingXform.DRAWING_ATTRIBUTES = {\r\n  'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',\r\n  'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',\r\n};\r\n\r\nmodule.exports = DrawingXform;\r\n","const BaseCellAnchorXform = require('./base-cell-anchor-xform');\r\nconst StaticXform = require('../static-xform');\r\n\r\nconst CellPositionXform = require('./cell-position-xform');\r\nconst PicXform = require('./pic-xform');\r\n\r\nclass TwoCellAnchorXform extends BaseCellAnchorXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xdr:from': new CellPositionXform({tag: 'xdr:from'}),\r\n      'xdr:to': new CellPositionXform({tag: 'xdr:to'}),\r\n      'xdr:pic': new PicXform(),\r\n      'xdr:clientData': new StaticXform({tag: 'xdr:clientData'}),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:twoCellAnchor';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.map['xdr:pic'].prepare(model.picture, options);\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});\r\n\r\n    this.map['xdr:from'].render(xmlStream, model.range.tl);\r\n    this.map['xdr:to'].render(xmlStream, model.range.br);\r\n    this.map['xdr:pic'].render(xmlStream, model.picture);\r\n    this.map['xdr:clientData'].render(xmlStream, {});\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model.range.tl = this.map['xdr:from'].model;\r\n        this.model.range.br = this.map['xdr:to'].model;\r\n        this.model.picture = this.map['xdr:pic'].model;\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.medium = this.reconcilePicture(model.picture, options);\r\n  }\r\n}\r\n\r\nmodule.exports = TwoCellAnchorXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass BaseCellAnchorXform extends BaseXform {\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          range: {\r\n            editAs: node.attributes.editAs || 'oneCell',\r\n          },\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  reconcilePicture(model, options) {\r\n    if (model && model.rId) {\r\n      const rel = options.rels[model.rId];\r\n      const match = rel.Target.match(/.*\\/media\\/(.+[.][a-zA-Z]{3,4})/);\r\n      if (match) {\r\n        const name = match[1];\r\n        const mediaId = options.mediaIndex[name];\r\n        return options.media[mediaId];\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\nmodule.exports = BaseCellAnchorXform;\r\n","const BaseXform = require('../base-xform');\r\nconst IntegerXform = require('../simple/integer-xform');\r\n\r\nclass CellPositionXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.map = {\r\n      'xdr:col': new IntegerXform({tag: 'xdr:col', zero: true}),\r\n      'xdr:colOff': new IntegerXform({tag: 'xdr:colOff', zero: true}),\r\n      'xdr:row': new IntegerXform({tag: 'xdr:row', zero: true}),\r\n      'xdr:rowOff': new IntegerXform({tag: 'xdr:rowOff', zero: true}),\r\n    };\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    this.map['xdr:col'].render(xmlStream, model.nativeCol);\r\n    this.map['xdr:colOff'].render(xmlStream, model.nativeColOff);\r\n\r\n    this.map['xdr:row'].render(xmlStream, model.nativeRow);\r\n    this.map['xdr:rowOff'].render(xmlStream, model.nativeRowOff);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model = {\r\n          nativeCol: this.map['xdr:col'].model,\r\n          nativeColOff: this.map['xdr:colOff'].model,\r\n          nativeRow: this.map['xdr:row'].model,\r\n          nativeRowOff: this.map['xdr:rowOff'].model,\r\n        };\r\n        return false;\r\n      default:\r\n        // not quite sure how we get here!\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CellPositionXform;\r\n","const BaseXform = require('../base-xform');\r\nconst StaticXform = require('../static-xform');\r\n\r\nconst BlipFillXform = require('./blip-fill-xform');\r\nconst NvPicPrXform = require('./nv-pic-pr-xform');\r\n\r\nconst spPrJSON = require('./sp-pr');\r\n\r\nclass PicXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xdr:nvPicPr': new NvPicPrXform(),\r\n      'xdr:blipFill': new BlipFillXform(),\r\n      'xdr:spPr': new StaticXform(spPrJSON),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:pic';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    model.index = options.index + 1;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    this.map['xdr:nvPicPr'].render(xmlStream, model);\r\n    this.map['xdr:blipFill'].render(xmlStream, model);\r\n    this.map['xdr:spPr'].render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.mergeModel(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // not quite sure how we get here!\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = PicXform;\r\n","const BaseXform = require('../base-xform');\r\nconst BlipXform = require('./blip-xform');\r\n\r\nclass BlipFillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'a:blip': new BlipXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:blipFill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    this.map['a:blip'].render(xmlStream, model);\r\n\r\n    // TODO: options for this + parsing\r\n    xmlStream.openNode('a:stretch');\r\n    xmlStream.leafNode('a:fillRect');\r\n    xmlStream.closeNode();\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        break;\r\n\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model = this.map['a:blip'].model;\r\n        return false;\r\n\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = BlipFillXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass BlipXform extends BaseXform {\r\n  get tag() {\r\n    return 'a:blip';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\r\n      'r:embed': model.rId,\r\n      cstate: 'print',\r\n    });\r\n    // TODO: handle children (e.g. a:extLst=>a:ext=>a14:useLocalDpi\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          rId: node.attributes['r:embed'],\r\n        };\r\n        return true;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // unprocessed internal nodes\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = BlipXform;\r\n","const BaseXform = require('../base-xform');\r\nconst CNvPrXform = require('./c-nv-pr-xform');\r\nconst CNvPicPrXform = require('./c-nv-pic-pr-xform');\r\n\r\nclass NvPicPrXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xdr:cNvPr': new CNvPrXform(),\r\n      'xdr:cNvPicPr': new CNvPicPrXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:nvPicPr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n    this.map['xdr:cNvPr'].render(xmlStream, model);\r\n    this.map['xdr:cNvPicPr'].render(xmlStream, model);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model = this.map['xdr:cNvPr'].model;\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = NvPicPrXform;\r\n","const BaseXform = require('../base-xform');\r\nconst HlickClickXform = require('./hlink-click-xform');\r\nconst ExtLstXform = require('./ext-lst-xform');\r\n\r\nclass CNvPrXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'a:hlinkClick': new HlickClickXform(),\r\n      'a:extLst': new ExtLstXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:cNvPr';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      id: model.index,\r\n      name: `Picture ${model.index}`,\r\n    });\r\n    this.map['a:hlinkClick'].render(xmlStream, model);\r\n    this.map['a:extLst'].render(xmlStream, model);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model = this.map['a:hlinkClick'].model;\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CNvPrXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass HLinkClickXform extends BaseXform {\r\n  get tag() {\r\n    return 'a:hlinkClick';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (!(model.hyperlinks && model.hyperlinks.rId)) {\r\n      return;\r\n    }\r\n    xmlStream.leafNode(this.tag, {\r\n      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\r\n      'r:id': model.hyperlinks.rId,\r\n      tooltip: model.hyperlinks.tooltip,\r\n    });\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          hyperlinks: {\r\n            rId: node.attributes['r:id'],\r\n            tooltip: node.attributes.tooltip,\r\n          },\r\n        };\r\n        return true;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = HLinkClickXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass ExtLstXform extends BaseXform {\r\n  get tag() {\r\n    return 'a:extLst';\r\n  }\r\n\r\n  render(xmlStream) {\r\n    xmlStream.openNode(this.tag);\r\n    xmlStream.openNode('a:ext', {\r\n      uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}',\r\n    });\r\n    xmlStream.leafNode('a16:creationId', {\r\n      'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',\r\n      id: '{00000000-0008-0000-0000-000002000000}',\r\n    });\r\n    xmlStream.closeNode();\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        return true;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // unprocessed internal nodes\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = ExtLstXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass CNvPicPrXform extends BaseXform {\r\n  get tag() {\r\n    return 'xdr:cNvPicPr';\r\n  }\r\n\r\n  render(xmlStream) {\r\n    xmlStream.openNode(this.tag);\r\n    xmlStream.leafNode('a:picLocks', {\r\n      noChangeAspect: '1',\r\n    });\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        return true;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // unprocessed internal nodes\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CNvPicPrXform;\r\n","module.exports = {\r\n  tag: 'xdr:spPr',\r\n  c: [\r\n    {\r\n      tag: 'a:xfrm',\r\n      c: [\r\n        {tag: 'a:off', $: {x: '0', y: '0'}},\r\n        {tag: 'a:ext', $: {cx: '0', cy: '0'}},\r\n      ],\r\n    },\r\n    {\r\n      tag: 'a:prstGeom',\r\n      $: {prst: 'rect'},\r\n      c: [{tag: 'a:avLst'}],\r\n    },\r\n  ],\r\n};\r\n","const BaseCellAnchorXform = require('./base-cell-anchor-xform');\r\nconst StaticXform = require('../static-xform');\r\n\r\nconst CellPositionXform = require('./cell-position-xform');\r\nconst ExtXform = require('./ext-xform');\r\nconst PicXform = require('./pic-xform');\r\n\r\nclass OneCellAnchorXform extends BaseCellAnchorXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      'xdr:from': new CellPositionXform({tag: 'xdr:from'}),\r\n      'xdr:ext': new ExtXform({tag: 'xdr:ext'}),\r\n      'xdr:pic': new PicXform(),\r\n      'xdr:clientData': new StaticXform({tag: 'xdr:clientData'}),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xdr:oneCellAnchor';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.map['xdr:pic'].prepare(model.picture, options);\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});\r\n\r\n    this.map['xdr:from'].render(xmlStream, model.range.tl);\r\n    this.map['xdr:ext'].render(xmlStream, model.range.ext);\r\n    this.map['xdr:pic'].render(xmlStream, model.picture);\r\n    this.map['xdr:clientData'].render(xmlStream, {});\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model.range.tl = this.map['xdr:from'].model;\r\n        this.model.range.ext = this.map['xdr:ext'].model;\r\n        this.model.picture = this.map['xdr:pic'].model;\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.medium = this.reconcilePicture(model.picture, options);\r\n  }\r\n}\r\n\r\nmodule.exports = OneCellAnchorXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\n/** https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML */\r\nconst EMU_PER_PIXEL_AT_96_DPI = 9525;\r\n\r\nclass ExtXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.tag = options.tag;\r\n    this.map = {};\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag);\r\n\r\n    const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);\r\n    const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);\r\n\r\n    xmlStream.addAttribute('cx', width);\r\n    xmlStream.addAttribute('cy', height);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      this.model = {\r\n        width: parseInt(node.attributes.cx || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,\r\n        height: parseInt(node.attributes.cy || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(/* text */) {}\r\n\r\n  parseClose(/* name */) {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = ExtXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst ListXform = require('../list-xform');\r\n\r\nconst AutoFilterXform = require('./auto-filter-xform');\r\nconst TableColumnXform = require('./table-column-xform');\r\nconst TableStyleInfoXform = require('./table-style-info-xform');\r\n\r\nclass TableXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      autoFilter: new AutoFilterXform(),\r\n      tableColumns: new ListXform({\r\n        tag: 'tableColumns',\r\n        count: true,\r\n        empty: true,\r\n        childXform: new TableColumnXform(),\r\n      }),\r\n      tableStyleInfo: new TableStyleInfoXform(),\r\n    };\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.map.autoFilter.prepare(model);\r\n    this.map.tableColumns.prepare(model.columns, options);\r\n  }\r\n\r\n  get tag() {\r\n    return 'table';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode(this.tag, {\r\n      ...TableXform.TABLE_ATTRIBUTES,\r\n      id: model.id,\r\n      name: model.name,\r\n      displayName: model.displayName || model.name,\r\n      ref: model.tableRef,\r\n      totalsRowCount: model.totalsRow ? '1' : undefined,\r\n      totalsRowShown: model.totalsRow ? undefined : '1',\r\n      headerRowCount: model.headerRow ? '1' : '0',\r\n    });\r\n\r\n    this.map.autoFilter.render(xmlStream, model);\r\n    this.map.tableColumns.render(xmlStream, model.columns);\r\n    this.map.tableStyleInfo.render(xmlStream, model.style);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    const {name, attributes} = node;\r\n    switch (name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          name: attributes.name,\r\n          displayName: attributes.displayName || attributes.name,\r\n          tableRef: attributes.ref,\r\n          totalsRow: attributes.totalsRowCount === '1',\r\n          headerRow: attributes.headerRowCount === '1',\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model.columns = this.map.tableColumns.model;\r\n        if (this.map.autoFilter.model) {\r\n          this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;\r\n          this.map.autoFilter.model.columns.forEach((column, index) => {\r\n            this.model.columns[index].filterButton = column.filterButton;\r\n          });\r\n        }\r\n        this.model.style = this.map.tableStyleInfo.model;\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    // fetch the dfxs from styles\r\n    model.columns.forEach(column => {\r\n      if (column.dxfId !== undefined) {\r\n        column.style = options.styles.getDxfStyle(column.dxfId);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nTableXform.TABLE_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\r\n  'mc:Ignorable': 'xr xr3',\r\n  'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',\r\n  'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',\r\n  // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',\r\n};\r\n\r\nmodule.exports = TableXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst FilterColumnXform = require('./filter-column-xform');\r\n\r\nclass AutoFilterXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      filterColumn: new FilterColumnXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'autoFilter';\r\n  }\r\n\r\n  prepare(model) {\r\n    model.columns.forEach((column, index) => {\r\n      this.map.filterColumn.prepare(column, {index});\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {ref: model.autoFilterRef});\r\n\r\n    model.columns.forEach(column => {\r\n      this.map.filterColumn.render(xmlStream, column);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n    return true;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          autoFilterRef: node.attributes.ref,\r\n          columns: [],\r\n        };\r\n        return true;\r\n\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parseOpen(node);\r\n          return true;\r\n        }\r\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.columns.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = AutoFilterXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass FilterColumnXform extends BaseXform {\r\n  get tag() {\r\n    return 'filterColumn';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    model.colId = options.index.toString();\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      colId: model.colId,\r\n      hiddenButton: model.filterButton ? '0' : '1',\r\n    });\r\n    return true;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      const {attributes} = node;\r\n      this.model = {\r\n        filterButton: attributes.hiddenButton === '0',\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = FilterColumnXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass TableColumnXform extends BaseXform {\r\n  get tag() {\r\n    return 'tableColumn';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    model.id = options.index + 1;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      id: model.id.toString(),\r\n      name: model.name,\r\n      totalsRowLabel: model.totalsRowLabel,\r\n      totalsRowFunction: model.totalsRowFunction,\r\n      dxfId: model.dxfId,\r\n    });\r\n    return true;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      const {attributes} = node;\r\n      this.model = {\r\n        name: attributes.name,\r\n        totalsRowLabel: attributes.totalsRowLabel,\r\n        totalsRowFunction: attributes.totalsRowFunction,\r\n        dxfId: attributes.dxfId,\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = TableColumnXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass TableStyleInfoXform extends BaseXform {\r\n  get tag() {\r\n    return 'tableStyleInfo';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      name: model.theme ? model.theme : undefined,\r\n      showFirstColumn: model.showFirstColumn ? '1' : '0',\r\n      showLastColumn: model.showLastColumn ? '1' : '0',\r\n      showRowStripes: model.showRowStripes ? '1' : '0',\r\n      showColumnStripes: model.showColumnStripes ? '1' : '0',\r\n    });\r\n    return true;\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (node.name === this.tag) {\r\n      const {attributes} = node;\r\n      this.model = {\r\n        theme: attributes.name ? attributes.name : null,\r\n        showFirstColumn: attributes.showFirstColumn === '1',\r\n        showLastColumn: attributes.showLastColumn === '1',\r\n        showRowStripes: attributes.showRowStripes === '1',\r\n        showColumnStripes: attributes.showColumnStripes === '1',\r\n      };\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = TableStyleInfoXform;\r\n","const XmlStream = require('../../../utils/xml-stream');\r\nconst utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst CommentXform = require('./comment-xform');\r\n\r\nconst CommentsXform = (module.exports = function() {\r\n  this.map = {\r\n    comment: new CommentXform(),\r\n  };\r\n});\r\n\r\nutils.inherits(\r\n  CommentsXform,\r\n  BaseXform,\r\n  {\r\n    COMMENTS_ATTRIBUTES: {\r\n      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n    },\r\n  },\r\n  {\r\n    render(xmlStream, model) {\r\n      model = model || this.model;\r\n      xmlStream.openXml(XmlStream.StdDocAttributes);\r\n      xmlStream.openNode('comments', CommentsXform.COMMENTS_ATTRIBUTES);\r\n\r\n      // authors\r\n      // TODO: support authors properly\r\n      xmlStream.openNode('authors');\r\n      xmlStream.leafNode('author', null, 'Author');\r\n      xmlStream.closeNode();\r\n\r\n      // comments\r\n      xmlStream.openNode('commentList');\r\n      model.comments.forEach(comment => {\r\n        this.map.comment.render(xmlStream, comment);\r\n      });\r\n      xmlStream.closeNode();\r\n      xmlStream.closeNode();\r\n    },\r\n\r\n    parseOpen(node) {\r\n      if (this.parser) {\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      }\r\n      switch (node.name) {\r\n        case 'commentList':\r\n          this.model = {\r\n            comments: [],\r\n          };\r\n          return true;\r\n        case 'comment':\r\n          this.parser = this.map.comment;\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        default:\r\n          return false;\r\n      }\r\n    },\r\n    parseText(text) {\r\n      if (this.parser) {\r\n        this.parser.parseText(text);\r\n      }\r\n    },\r\n    parseClose(name) {\r\n      switch (name) {\r\n        case 'commentList':\r\n          return false;\r\n        case 'comment':\r\n          this.model.comments.push(this.parser.model);\r\n          this.parser = undefined;\r\n          return true;\r\n        default:\r\n          if (this.parser) {\r\n            this.parser.parseClose(name);\r\n          }\r\n          return true;\r\n      }\r\n    },\r\n  }\r\n);\r\n","const RichTextXform = require('../strings/rich-text-xform');\r\nconst utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\n\r\n/**\r\n  <comment ref=\"B1\" authorId=\"0\">\r\n    <text>\r\n      <r>\r\n        <rPr>\r\n          <b/>\r\n          <sz val=\"9\"/>\r\n          <rFont val=\"\"/>\r\n          <charset val=\"134\"/>\r\n        </rPr>\r\n        <t>51422:</t>\r\n      </r>\r\n      <r>\r\n        <rPr>\r\n          <sz val=\"9\"/>\r\n          <rFont val=\"\"/>\r\n          <charset val=\"134\"/>\r\n        </rPr>\r\n        <t xml:space=\"preserve\">&#10;test</t>\r\n      </r>\r\n    </text>\r\n  </comment>\r\n */\r\n\r\nconst CommentXform = (module.exports = function(model) {\r\n  this.model = model;\r\n});\r\n\r\nutils.inherits(CommentXform, BaseXform, {\r\n  get tag() {\r\n    return 'r';\r\n  },\r\n\r\n  get richTextXform() {\r\n    if (!this._richTextXform) {\r\n      this._richTextXform = new RichTextXform();\r\n    }\r\n    return this._richTextXform;\r\n  },\r\n\r\n  render(xmlStream, model) {\r\n    model = model || this.model;\r\n\r\n    xmlStream.openNode('comment', {\r\n      ref: model.ref,\r\n      authorId: 0,\r\n    });\r\n    xmlStream.openNode('text');\r\n    if (model && model.note && model.note.texts) {\r\n      model.note.texts.forEach(text => {\r\n        this.richTextXform.render(xmlStream, text);\r\n      });\r\n    }\r\n    xmlStream.closeNode();\r\n    xmlStream.closeNode();\r\n  },\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'comment':\r\n        this.model = {\r\n          type: 'note',\r\n          note: {\r\n            texts: [],\r\n          },\r\n          ...node.attributes,\r\n        };\r\n        return true;\r\n      case 'r':\r\n        this.parser = this.richTextXform;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  },\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  },\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case 'comment':\r\n        return false;\r\n      case 'r':\r\n        this.model.note.texts.push(this.parser.model);\r\n        this.parser = undefined;\r\n        return true;\r\n      default:\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n        }\r\n        return true;\r\n    }\r\n  },\r\n});\r\n","const XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst VmlShapeXform = require('./vml-shape-xform');\r\n\r\n// This class is (currently) single purposed to insert the triangle\r\n// drawing icons on commented cells\r\nclass VmlNotesXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n    this.map = {\r\n      'v:shape': new VmlShapeXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'xml';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);\r\n\r\n    xmlStream.openNode('o:shapelayout', {'v:ext': 'edit'});\r\n    xmlStream.leafNode('o:idmap', {'v:ext': 'edit', data: 1});\r\n    xmlStream.closeNode();\r\n\r\n    xmlStream.openNode('v:shapetype', {\r\n      id: '_x0000_t202',\r\n      coordsize: '21600,21600',\r\n      'o:spt': 202,\r\n      path: 'm,l,21600r21600,l21600,xe',\r\n    });\r\n    xmlStream.leafNode('v:stroke', {joinstyle: 'miter'});\r\n    xmlStream.leafNode('v:path', {gradientshapeok: 't', 'o:connecttype': 'rect'});\r\n    xmlStream.closeNode();\r\n\r\n    model.comments.forEach((item, index) => {\r\n      this.map['v:shape'].render(xmlStream, item, index);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          comments: [],\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.comments.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.anchors.forEach(anchor => {\r\n      if (anchor.br) {\r\n        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);\r\n      } else {\r\n        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nVmlNotesXform.DRAWING_ATTRIBUTES = {\r\n  'xmlns:v': 'urn:schemas-microsoft-com:vml',\r\n  'xmlns:o': 'urn:schemas-microsoft-com:office:office',\r\n  'xmlns:x': 'urn:schemas-microsoft-com:office:excel',\r\n};\r\n\r\nmodule.exports = VmlNotesXform;\r\n","const BaseXform = require('../base-xform');\r\nconst VmlTextboxXform = require('./vml-textbox-xform');\r\nconst VmlClientDataXform = require('./vml-client-data-xform');\r\n\r\nclass VmlShapeXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n    this.map = {\r\n      'v:textbox': new VmlTextboxXform(),\r\n      'x:ClientData': new VmlClientDataXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'v:shape';\r\n  }\r\n\r\n  render(xmlStream, model, index) {\r\n    xmlStream.openNode('v:shape', VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index));\r\n\r\n    xmlStream.leafNode('v:fill', {color2: 'infoBackground [80]'});\r\n    xmlStream.leafNode('v:shadow', {color: 'none [81]', obscured: 't'});\r\n    xmlStream.leafNode('v:path', {'o:connecttype': 'none'});\r\n    this.map['v:textbox'].render(xmlStream, model);\r\n    this.map['x:ClientData'].render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          margins: {\r\n            insetmode: node.attributes['o:insetmode'],\r\n          },\r\n          anchor: '',\r\n          editAs: '',\r\n          protection: {},\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model.margins.inset = this.map['v:textbox'].model && this.map['v:textbox'].model.inset;\r\n        this.model.protection =\r\n          this.map['x:ClientData'].model && this.map['x:ClientData'].model.protection;\r\n        this.model.anchor = this.map['x:ClientData'].model && this.map['x:ClientData'].model.anchor;\r\n        this.model.editAs = this.map['x:ClientData'].model && this.map['x:ClientData'].model.editAs;\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nVmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index) => ({\r\n  id: `_x0000_s${1025 + index}`,\r\n  type: '#_x0000_t202',\r\n  style:\r\n    'position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden',\r\n  fillcolor: 'infoBackground [80]',\r\n  strokecolor: 'none [81]',\r\n  'o:insetmode': model.note.margins && model.note.margins.insetmode,\r\n});\r\n\r\nmodule.exports = VmlShapeXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nclass VmlTextboxXform extends BaseXform {\r\n  get tag() {\r\n    return 'v:textbox';\r\n  }\r\n\r\n  conversionUnit(value, multiple, unit) {\r\n    return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;\r\n  }\r\n\r\n  reverseConversionUnit(inset) {\r\n    return (inset || '').split(',').map(margin => {\r\n      return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, '')).toFixed(2));\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const attributes = {\r\n      style: 'mso-direction-alt:auto',\r\n    };\r\n    if (model && model.note) {\r\n      let {inset} = model.note && model.note.margins;\r\n      if (Array.isArray(inset)) {\r\n        inset = inset\r\n          .map(margin => {\r\n            return this.conversionUnit(margin, 10, 'mm');\r\n          })\r\n          .join(',');\r\n      }\r\n      if (inset) {\r\n        attributes.inset = inset;\r\n      }\r\n    }\r\n    xmlStream.openNode('v:textbox', attributes);\r\n    xmlStream.leafNode('div', {style: 'text-align:left'});\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {\r\n          inset: this.reverseConversionUnit(node.attributes.inset),\r\n        };\r\n        return true;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case this.tag:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = VmlTextboxXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\nconst VmlAnchorXform = require('./vml-anchor-xform');\r\nconst VmlProtectionXform = require('./style/vml-protection-xform');\r\nconst VmlPositionXform = require('./style/vml-position-xform');\r\n\r\nconst POSITION_TYPE = ['twoCells', 'oneCells', 'absolute'];\r\n\r\nclass VmlClientDataXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n    this.map = {\r\n      'x:Anchor': new VmlAnchorXform(),\r\n      'x:Locked': new VmlProtectionXform({tag: 'x:Locked'}),\r\n      'x:LockText': new VmlProtectionXform({tag: 'x:LockText'}),\r\n      'x:SizeWithCells': new VmlPositionXform({tag: 'x:SizeWithCells'}),\r\n      'x:MoveWithCells': new VmlPositionXform({tag: 'x:MoveWithCells'}),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'x:ClientData';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const {protection, editAs} = model.note;\r\n    xmlStream.openNode(this.tag, {ObjectType: 'Note'});\r\n    this.map['x:MoveWithCells'].render(xmlStream, editAs, POSITION_TYPE);\r\n    this.map['x:SizeWithCells'].render(xmlStream, editAs, POSITION_TYPE);\r\n    this.map['x:Anchor'].render(xmlStream, model);\r\n    this.map['x:Locked'].render(xmlStream, protection.locked);\r\n    xmlStream.leafNode('x:AutoFill', null, 'False');\r\n    this.map['x:LockText'].render(xmlStream, protection.lockText);\r\n    xmlStream.leafNode('x:Row', null, model.refAddress.row - 1);\r\n    xmlStream.leafNode('x:Column', null, model.refAddress.col - 1);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          anchor: [],\r\n          protection: {},\r\n          editAs: '',\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.normalizeModel();\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  normalizeModel() {\r\n    const position = Object.assign(\r\n      {},\r\n      this.map['x:MoveWithCells'].model,\r\n      this.map['x:SizeWithCells'].model\r\n    );\r\n    const len = Object.keys(position).length;\r\n    this.model.editAs = POSITION_TYPE[len];\r\n    this.model.anchor = this.map['x:Anchor'].text;\r\n    this.model.protection.locked = this.map['x:Locked'].text;\r\n    this.model.protection.lockText = this.map['x:LockText'].text;\r\n  }\r\n}\r\n\r\nmodule.exports = VmlClientDataXform;\r\n","const BaseXform = require('../base-xform');\r\n\r\n// render the triangle in the cell for the comment\r\nclass VmlAnchorXform extends BaseXform {\r\n  get tag() {\r\n    return 'x:Anchor';\r\n  }\r\n\r\n  getAnchorRect(anchor) {\r\n    const l = Math.floor(anchor.left);\r\n    const lf = Math.floor((anchor.left - l) * 68);\r\n    const t = Math.floor(anchor.top);\r\n    const tf = Math.floor((anchor.top - t) * 18);\r\n    const r = Math.floor(anchor.right);\r\n    const rf = Math.floor((anchor.right - r) * 68);\r\n    const b = Math.floor(anchor.bottom);\r\n    const bf = Math.floor((anchor.bottom - b) * 18);\r\n    return [l, lf, t, tf, r, rf, b, bf];\r\n  }\r\n\r\n  getDefaultRect(ref) {\r\n    const l = ref.col;\r\n    const lf = 6;\r\n    const t = Math.max(ref.row - 2, 0);\r\n    const tf = 14;\r\n    const r = l + 2;\r\n    const rf = 2;\r\n    const b = t + 4;\r\n    const bf = 16;\r\n    return [l, lf, t, tf, r, rf, b, bf];\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const rect = model.anchor\r\n      ? this.getAnchorRect(model.anchor)\r\n      : this.getDefaultRect(model.refAddress);\r\n\r\n    xmlStream.leafNode('x:Anchor', null, rect.join(', '));\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.text = '';\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this.text = text;\r\n  }\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = VmlAnchorXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass VmlProtectionXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n    this._model = model;\r\n  }\r\n\r\n  get tag() {\r\n    return this._model && this._model.tag;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, null, model);\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.text = '';\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this.text = text;\r\n  }\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = VmlProtectionXform;\r\n","const BaseXform = require('../../base-xform');\r\n\r\nclass VmlPositionXform extends BaseXform {\r\n  constructor(model) {\r\n    super();\r\n    this._model = model;\r\n  }\r\n\r\n  get tag() {\r\n    return this._model && this._model.tag;\r\n  }\r\n\r\n  render(xmlStream, model, type) {\r\n    if (model === type[2]) {\r\n      xmlStream.leafNode(this.tag);\r\n    } else if (this.tag === 'x:SizeWithCells' && model === type[1]) {\r\n      xmlStream.leafNode(this.tag);\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.model = {};\r\n        this.model[this.tag] = true;\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = VmlPositionXform;\r\n","/* eslint-disable */\r\nmodule.exports =\r\n  '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"> <a:themeElements> <a:clrScheme name=\"Office\"> <a:dk1> <a:sysClr val=\"windowText\" lastClr=\"000000\"/> </a:dk1> <a:lt1> <a:sysClr val=\"window\" lastClr=\"FFFFFF\"/> </a:lt1> <a:dk2> <a:srgbClr val=\"1F497D\"/> </a:dk2> <a:lt2> <a:srgbClr val=\"EEECE1\"/> </a:lt2> <a:accent1> <a:srgbClr val=\"4F81BD\"/> </a:accent1> <a:accent2> <a:srgbClr val=\"C0504D\"/> </a:accent2> <a:accent3> <a:srgbClr val=\"9BBB59\"/> </a:accent3> <a:accent4> <a:srgbClr val=\"8064A2\"/> </a:accent4> <a:accent5> <a:srgbClr val=\"4BACC6\"/> </a:accent5> <a:accent6> <a:srgbClr val=\"F79646\"/> </a:accent6> <a:hlink> <a:srgbClr val=\"0000FF\"/> </a:hlink> <a:folHlink> <a:srgbClr val=\"800080\"/> </a:folHlink> </a:clrScheme> <a:fontScheme name=\"Office\"> <a:majorFont> <a:latin typeface=\"Cambria\"/> <a:ea typeface=\"\"/> <a:cs typeface=\"\"/> <a:font script=\"Jpan\" typeface=\" \"/> <a:font script=\"Hang\" typeface=\" \"/> <a:font script=\"Hans\" typeface=\"\"/> <a:font script=\"Hant\" typeface=\"\"/> <a:font script=\"Arab\" typeface=\"Times New Roman\"/> <a:font script=\"Hebr\" typeface=\"Times New Roman\"/> <a:font script=\"Thai\" typeface=\"Tahoma\"/> <a:font script=\"Ethi\" typeface=\"Nyala\"/> <a:font script=\"Beng\" typeface=\"Vrinda\"/> <a:font script=\"Gujr\" typeface=\"Shruti\"/> <a:font script=\"Khmr\" typeface=\"MoolBoran\"/> <a:font script=\"Knda\" typeface=\"Tunga\"/> <a:font script=\"Guru\" typeface=\"Raavi\"/> <a:font script=\"Cans\" typeface=\"Euphemia\"/> <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/> <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/> <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/> <a:font script=\"Thaa\" typeface=\"MV Boli\"/> <a:font script=\"Deva\" typeface=\"Mangal\"/> <a:font script=\"Telu\" typeface=\"Gautami\"/> <a:font script=\"Taml\" typeface=\"Latha\"/> <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/> <a:font script=\"Orya\" typeface=\"Kalinga\"/> <a:font script=\"Mlym\" typeface=\"Kartika\"/> <a:font script=\"Laoo\" typeface=\"DokChampa\"/> <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/> <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/> <a:font script=\"Viet\" typeface=\"Times New Roman\"/> <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/> <a:font script=\"Geor\" typeface=\"Sylfaen\"/> </a:majorFont> <a:minorFont> <a:latin typeface=\"Calibri\"/> <a:ea typeface=\"\"/> <a:cs typeface=\"\"/> <a:font script=\"Jpan\" typeface=\" \"/> <a:font script=\"Hang\" typeface=\" \"/> <a:font script=\"Hans\" typeface=\"\"/> <a:font script=\"Hant\" typeface=\"\"/> <a:font script=\"Arab\" typeface=\"Arial\"/> <a:font script=\"Hebr\" typeface=\"Arial\"/> <a:font script=\"Thai\" typeface=\"Tahoma\"/> <a:font script=\"Ethi\" typeface=\"Nyala\"/> <a:font script=\"Beng\" typeface=\"Vrinda\"/> <a:font script=\"Gujr\" typeface=\"Shruti\"/> <a:font script=\"Khmr\" typeface=\"DaunPenh\"/> <a:font script=\"Knda\" typeface=\"Tunga\"/> <a:font script=\"Guru\" typeface=\"Raavi\"/> <a:font script=\"Cans\" typeface=\"Euphemia\"/> <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/> <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/> <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/> <a:font script=\"Thaa\" typeface=\"MV Boli\"/> <a:font script=\"Deva\" typeface=\"Mangal\"/> <a:font script=\"Telu\" typeface=\"Gautami\"/> <a:font script=\"Taml\" typeface=\"Latha\"/> <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/> <a:font script=\"Orya\" typeface=\"Kalinga\"/> <a:font script=\"Mlym\" typeface=\"Kartika\"/> <a:font script=\"Laoo\" typeface=\"DokChampa\"/> <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/> <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/> <a:font script=\"Viet\" typeface=\"Arial\"/> <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/> <a:font script=\"Geor\" typeface=\"Sylfaen\"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name=\"Office\"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"50000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"35000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"37000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"15000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang=\"16200000\" scaled=\"1\"/> </a:gradFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"100000\"/> <a:shade val=\"100000\"/> <a:satMod val=\"130000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"50000\"/> <a:shade val=\"100000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang=\"16200000\" scaled=\"0\"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"> <a:shade val=\"95000\"/> <a:satMod val=\"105000\"/> </a:schemeClr> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> <a:ln w=\"25400\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> <a:ln w=\"38100\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"20000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"38000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"35000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"35000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst=\"orthographicFront\"> <a:rot lat=\"0\" lon=\"0\" rev=\"0\"/> </a:camera> <a:lightRig rig=\"threePt\" dir=\"t\"> <a:rot lat=\"0\" lon=\"0\" rev=\"1200000\"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w=\"63500\" h=\"25400\"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"40000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"40000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"45000\"/> <a:shade val=\"99000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:shade val=\"20000\"/> <a:satMod val=\"255000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path=\"circle\"> <a:fillToRect l=\"50000\" t=\"-80000\" r=\"50000\" b=\"180000\"/> </a:path> </a:gradFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"80000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:shade val=\"30000\"/> <a:satMod val=\"200000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path=\"circle\"> <a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx=\"1\"> <a:schemeClr val=\"accent1\"/> </a:lnRef> <a:fillRef idx=\"3\"> <a:schemeClr val=\"accent1\"/> </a:fillRef> <a:effectRef idx=\"2\"> <a:schemeClr val=\"accent1\"/> </a:effectRef> <a:fontRef idx=\"minor\"> <a:schemeClr val=\"lt1\"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx=\"2\"> <a:schemeClr val=\"accent1\"/> </a:lnRef> <a:fillRef idx=\"0\"> <a:schemeClr val=\"accent1\"/> </a:fillRef> <a:effectRef idx=\"1\"> <a:schemeClr val=\"accent1\"/> </a:effectRef> <a:fontRef idx=\"minor\"> <a:schemeClr val=\"tx1\"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';\r\n","const fs = require('fs');\r\nconst fastCsv = require('fast-csv');\r\nconst customParseFormat = require('dayjs/plugin/customParseFormat');\r\nconst utc = require('dayjs/plugin/utc');\r\nconst dayjs = require('dayjs').extend(customParseFormat).extend(utc);\r\nconst StreamBuf = require('../utils/stream-buf');\r\n\r\nconst {\r\n  fs: {exists},\r\n} = require('../utils/utils');\r\n\r\n/* eslint-disable quote-props */\r\nconst SpecialValues = {\r\n  true: true,\r\n  false: false,\r\n  '#N/A': {error: '#N/A'},\r\n  '#REF!': {error: '#REF!'},\r\n  '#NAME?': {error: '#NAME?'},\r\n  '#DIV/0!': {error: '#DIV/0!'},\r\n  '#NULL!': {error: '#NULL!'},\r\n  '#VALUE!': {error: '#VALUE!'},\r\n  '#NUM!': {error: '#NUM!'},\r\n};\r\n/* eslint-ensable quote-props */\r\n\r\nclass CSV {\r\n  constructor(workbook) {\r\n    this.workbook = workbook;\r\n    this.worksheet = null;\r\n  }\r\n\r\n  async readFile(filename, options) {\r\n    options = options || {};\r\n    if (!(await exists(filename))) {\r\n      throw new Error(`File not found: ${filename}`);\r\n    }\r\n    const stream = fs.createReadStream(filename);\r\n    const worksheet = await this.read(stream, options);\r\n    stream.close();\r\n    return worksheet;\r\n  }\r\n\r\n  read(stream, options) {\r\n    options = options || {};\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const worksheet = this.workbook.addWorksheet(options.sheetName);\r\n\r\n      const dateFormats = options.dateFormats || [\r\n        'YYYY-MM-DD[T]HH:mm:ssZ',\r\n        'YYYY-MM-DD[T]HH:mm:ss',\r\n        'MM-DD-YYYY',\r\n        'YYYY-MM-DD',\r\n      ];\r\n      const map =\r\n        options.map ||\r\n        function(datum) {\r\n          if (datum === '') {\r\n            return null;\r\n          }\r\n          const datumNumber = Number(datum);\r\n          if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {\r\n            return datumNumber;\r\n          }\r\n          const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {\r\n            if (matchingDate) {\r\n              return matchingDate;\r\n            }\r\n            const dayjsObj = dayjs(datum, currentDateFormat, true);\r\n            if (dayjsObj.isValid()) {\r\n              return dayjsObj;\r\n            }\r\n            return null;\r\n          }, null);\r\n          if (dt) {\r\n            return new Date(dt.valueOf());\r\n          }\r\n          const special = SpecialValues[datum];\r\n          if (special !== undefined) {\r\n            return special;\r\n          }\r\n          return datum;\r\n        };\r\n\r\n      const csvStream = fastCsv\r\n        .parse(options.parserOptions)\r\n        .on('data', data => {\r\n          worksheet.addRow(data.map(map));\r\n        })\r\n        .on('end', () => {\r\n          csvStream.emit('worksheet', worksheet);\r\n        });\r\n\r\n      csvStream.on('worksheet', resolve).on('error', reject);\r\n\r\n      stream.pipe(csvStream);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md\r\n   */\r\n  createInputStream() {\r\n    throw new Error(\r\n      '`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'\r\n    );\r\n  }\r\n\r\n  write(stream, options) {\r\n    return new Promise((resolve, reject) => {\r\n      options = options || {};\r\n      // const encoding = options.encoding || 'utf8';\r\n      // const separator = options.separator || ',';\r\n      // const quoteChar = options.quoteChar || '\\'';\r\n\r\n      const worksheet = this.workbook.getWorksheet(options.sheetName || options.sheetId);\r\n\r\n      const csvStream = fastCsv.format(options.formatterOptions);\r\n      stream.on('finish', () => {\r\n        resolve();\r\n      });\r\n      csvStream.on('error', reject);\r\n      csvStream.pipe(stream);\r\n\r\n      const {dateFormat, dateUTC} = options;\r\n      const map =\r\n        options.map ||\r\n        (value => {\r\n          if (value) {\r\n            if (value.text || value.hyperlink) {\r\n              return value.hyperlink || value.text || '';\r\n            }\r\n            if (value.formula || value.result) {\r\n              return value.result || '';\r\n            }\r\n            if (value instanceof Date) {\r\n              if (dateFormat) {\r\n                return dateUTC\r\n                  ? dayjs.utc(value).format(dateFormat)\r\n                  : dayjs(value).format(dateFormat);\r\n              }\r\n              return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();\r\n            }\r\n            if (value.error) {\r\n              return value.error;\r\n            }\r\n            if (typeof value === 'object') {\r\n              return JSON.stringify(value);\r\n            }\r\n          }\r\n          return value;\r\n        });\r\n\r\n      const includeEmptyRows = options.includeEmptyRows === undefined || options.includeEmptyRows;\r\n      let lastRow = 1;\r\n      if (worksheet) {\r\n        worksheet.eachRow((row, rowNumber) => {\r\n          if (includeEmptyRows) {\r\n            while (lastRow++ < rowNumber - 1) {\r\n              csvStream.write([]);\r\n            }\r\n          }\r\n          const {values} = row;\r\n          values.shift();\r\n          csvStream.write(values.map(map));\r\n          lastRow = rowNumber;\r\n        });\r\n      }\r\n      csvStream.end();\r\n    });\r\n  }\r\n\r\n  writeFile(filename, options) {\r\n    options = options || {};\r\n\r\n    const streamOptions = {\r\n      encoding: options.encoding || 'utf8',\r\n    };\r\n    const stream = fs.createWriteStream(filename, streamOptions);\r\n\r\n    return this.write(stream, options);\r\n  }\r\n\r\n  async writeBuffer(options) {\r\n    const stream = new StreamBuf();\r\n    await this.write(stream, options);\r\n    return stream.read();\r\n  }\r\n}\r\n\r\nmodule.exports = CSV;\r\n","\r\n\r\nconst XLSX = require('../xlsx/xlsx');\r\n\r\nclass ModelContainer {\r\n  constructor(model) {\r\n    this.model = model;\r\n  }\r\n\r\n  get xlsx() {\r\n    if (!this._xlsx) {\r\n      this._xlsx = new XLSX(this);\r\n    }\r\n    return this._xlsx;\r\n  }\r\n}\r\n\r\nmodule.exports = ModelContainer;\r\n","const fs = require('fs');\r\nconst Archiver = require('archiver');\r\n\r\nconst StreamBuf = require('../../utils/stream-buf');\r\n\r\nconst RelType = require('../../xlsx/rel-type');\r\nconst StylesXform = require('../../xlsx/xform/style/styles-xform');\r\nconst SharedStrings = require('../../utils/shared-strings');\r\nconst DefinedNames = require('../../doc/defined-names');\r\n\r\nconst CoreXform = require('../../xlsx/xform/core/core-xform');\r\nconst RelationshipsXform = require('../../xlsx/xform/core/relationships-xform');\r\nconst ContentTypesXform = require('../../xlsx/xform/core/content-types-xform');\r\nconst AppXform = require('../../xlsx/xform/core/app-xform');\r\nconst WorkbookXform = require('../../xlsx/xform/book/workbook-xform');\r\nconst SharedStringsXform = require('../../xlsx/xform/strings/shared-strings-xform');\r\n\r\nconst WorksheetWriter = require('./worksheet-writer');\r\n\r\nconst theme1Xml = require('../../xlsx/xml/theme1.js');\r\n\r\nclass WorkbookWriter {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    this.created = options.created || new Date();\r\n    this.modified = options.modified || this.created;\r\n    this.creator = options.creator || 'ExcelJS';\r\n    this.lastModifiedBy = options.lastModifiedBy || 'ExcelJS';\r\n    this.lastPrinted = options.lastPrinted;\r\n\r\n    // using shared strings creates a smaller xlsx file but may use more memory\r\n    this.useSharedStrings = options.useSharedStrings || false;\r\n    this.sharedStrings = new SharedStrings();\r\n\r\n    // style manager\r\n    this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);\r\n\r\n    // defined names\r\n    this._definedNames = new DefinedNames();\r\n\r\n    this._worksheets = [];\r\n    this.views = [];\r\n\r\n    this.zipOptions = options.zip;\r\n\r\n    this.media = [];\r\n    this.commentRefs = [];\r\n\r\n    this.zip = Archiver('zip', this.zipOptions);\r\n    if (options.stream) {\r\n      this.stream = options.stream;\r\n    } else if (options.filename) {\r\n      this.stream = fs.createWriteStream(options.filename);\r\n    } else {\r\n      this.stream = new StreamBuf();\r\n    }\r\n    this.zip.pipe(this.stream);\r\n\r\n    // these bits can be added right now\r\n    this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);\r\n  }\r\n\r\n  get definedNames() {\r\n    return this._definedNames;\r\n  }\r\n\r\n  _openStream(path) {\r\n    const stream = new StreamBuf({bufSize: 65536, batch: true});\r\n    this.zip.append(stream, {name: path});\r\n    stream.on('finish', () => {\r\n      stream.emit('zipped');\r\n    });\r\n    return stream;\r\n  }\r\n\r\n  _commitWorksheets() {\r\n    const commitWorksheet = function(worksheet) {\r\n      if (!worksheet.committed) {\r\n        return new Promise(resolve => {\r\n          worksheet.stream.on('zipped', () => {\r\n            resolve();\r\n          });\r\n          worksheet.commit();\r\n        });\r\n      }\r\n      return Promise.resolve();\r\n    };\r\n    // if there are any uncommitted worksheets, commit them now and wait\r\n    const promises = this._worksheets.map(commitWorksheet);\r\n    if (promises.length) {\r\n      return Promise.all(promises);\r\n    }\r\n    return Promise.resolve();\r\n  }\r\n\r\n  async commit() {\r\n    // commit all worksheets, then add suplimentary files\r\n    await this.promise;\r\n    await this.addMedia();\r\n    await this._commitWorksheets();\r\n    await Promise.all([\r\n      this.addContentTypes(),\r\n      this.addApp(),\r\n      this.addCore(),\r\n      this.addSharedStrings(),\r\n      this.addStyles(),\r\n      this.addWorkbookRels(),\r\n    ]);\r\n    await this.addWorkbook();\r\n    return this._finalize();\r\n  }\r\n\r\n  get nextId() {\r\n    // find the next unique spot to add worksheet\r\n    let i;\r\n    for (i = 1; i < this._worksheets.length; i++) {\r\n      if (!this._worksheets[i]) {\r\n        return i;\r\n      }\r\n    }\r\n    return this._worksheets.length || 1;\r\n  }\r\n\r\n  addImage(image) {\r\n    const id = this.media.length;\r\n    const medium = Object.assign({}, image, {type: 'image', name: `image${id}.${image.extension}`});\r\n    this.media.push(medium);\r\n    return id;\r\n  }\r\n\r\n  getImage(id) {\r\n    return this.media[id];\r\n  }\r\n\r\n  addWorksheet(name, options) {\r\n    // it's possible to add a worksheet with different than default\r\n    // shared string handling\r\n    // in fact, it's even possible to switch it mid-sheet\r\n    options = options || {};\r\n    const useSharedStrings =\r\n      options.useSharedStrings !== undefined ? options.useSharedStrings : this.useSharedStrings;\r\n\r\n    if (options.tabColor) {\r\n      // eslint-disable-next-line no-console\r\n      console.trace('tabColor option has moved to { properties: tabColor: {...} }');\r\n      options.properties = Object.assign(\r\n        {\r\n          tabColor: options.tabColor,\r\n        },\r\n        options.properties\r\n      );\r\n    }\r\n\r\n    const id = this.nextId;\r\n    name = name || `sheet${id}`;\r\n\r\n    const worksheet = new WorksheetWriter({\r\n      id,\r\n      name,\r\n      workbook: this,\r\n      useSharedStrings,\r\n      properties: options.properties,\r\n      state: options.state,\r\n      pageSetup: options.pageSetup,\r\n      views: options.views,\r\n      autoFilter: options.autoFilter,\r\n      headerFooter: options.headerFooter,\r\n    });\r\n\r\n    this._worksheets[id] = worksheet;\r\n    return worksheet;\r\n  }\r\n\r\n  getWorksheet(id) {\r\n    if (id === undefined) {\r\n      return this._worksheets.find(() => true);\r\n    }\r\n    if (typeof id === 'number') {\r\n      return this._worksheets[id];\r\n    }\r\n    if (typeof id === 'string') {\r\n      return this._worksheets.find(worksheet => worksheet && worksheet.name === id);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  addStyles() {\r\n    return new Promise(resolve => {\r\n      this.zip.append(this.styles.xml, {name: 'xl/styles.xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addThemes() {\r\n    return new Promise(resolve => {\r\n      this.zip.append(theme1Xml, {name: 'xl/theme/theme1.xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addOfficeRels() {\r\n    return new Promise(resolve => {\r\n      const xform = new RelationshipsXform();\r\n      const xml = xform.toXml([\r\n        {Id: 'rId1', Type: RelType.OfficeDocument, Target: 'xl/workbook.xml'},\r\n        {Id: 'rId2', Type: RelType.CoreProperties, Target: 'docProps/core.xml'},\r\n        {Id: 'rId3', Type: RelType.ExtenderProperties, Target: 'docProps/app.xml'},\r\n      ]);\r\n      this.zip.append(xml, {name: '/_rels/.rels'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addContentTypes() {\r\n    return new Promise(resolve => {\r\n      const model = {\r\n        worksheets: this._worksheets.filter(Boolean),\r\n        sharedStrings: this.sharedStrings,\r\n        commentRefs: this.commentRefs,\r\n        media: this.media,\r\n      };\r\n      const xform = new ContentTypesXform();\r\n      const xml = xform.toXml(model);\r\n      this.zip.append(xml, {name: '[Content_Types].xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addMedia() {\r\n    return Promise.all(\r\n      this.media.map(medium => {\r\n        if (medium.type === 'image') {\r\n          const filename = `xl/media/${medium.name}`;\r\n          if (medium.filename) {\r\n            return this.zip.file(medium.filename, {name: filename});\r\n          }\r\n          if (medium.buffer) {\r\n            return this.zip.append(medium.buffer, {name: filename});\r\n          }\r\n          if (medium.base64) {\r\n            const dataimg64 = medium.base64;\r\n            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);\r\n            return this.zip.append(content, {name: filename, base64: true});\r\n          }\r\n        }\r\n        throw new Error('Unsupported media');\r\n      })\r\n    );\r\n  }\r\n\r\n  addApp() {\r\n    return new Promise(resolve => {\r\n      const model = {\r\n        worksheets: this._worksheets.filter(Boolean),\r\n      };\r\n      const xform = new AppXform();\r\n      const xml = xform.toXml(model);\r\n      this.zip.append(xml, {name: 'docProps/app.xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addCore() {\r\n    return new Promise(resolve => {\r\n      const coreXform = new CoreXform();\r\n      const xml = coreXform.toXml(this);\r\n      this.zip.append(xml, {name: 'docProps/core.xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addSharedStrings() {\r\n    if (this.sharedStrings.count) {\r\n      return new Promise(resolve => {\r\n        const sharedStringsXform = new SharedStringsXform();\r\n        const xml = sharedStringsXform.toXml(this.sharedStrings);\r\n        this.zip.append(xml, {name: '/xl/sharedStrings.xml'});\r\n        resolve();\r\n      });\r\n    }\r\n    return Promise.resolve();\r\n  }\r\n\r\n  addWorkbookRels() {\r\n    let count = 1;\r\n    const relationships = [\r\n      {Id: `rId${count++}`, Type: RelType.Styles, Target: 'styles.xml'},\r\n      {Id: `rId${count++}`, Type: RelType.Theme, Target: 'theme/theme1.xml'},\r\n    ];\r\n    if (this.sharedStrings.count) {\r\n      relationships.push({\r\n        Id: `rId${count++}`,\r\n        Type: RelType.SharedStrings,\r\n        Target: 'sharedStrings.xml',\r\n      });\r\n    }\r\n    this._worksheets.forEach(worksheet => {\r\n      if (worksheet) {\r\n        worksheet.rId = `rId${count++}`;\r\n        relationships.push({\r\n          Id: worksheet.rId,\r\n          Type: RelType.Worksheet,\r\n          Target: `worksheets/sheet${worksheet.id}.xml`,\r\n        });\r\n      }\r\n    });\r\n    return new Promise(resolve => {\r\n      const xform = new RelationshipsXform();\r\n      const xml = xform.toXml(relationships);\r\n      this.zip.append(xml, {name: '/xl/_rels/workbook.xml.rels'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  addWorkbook() {\r\n    const {zip} = this;\r\n    const model = {\r\n      worksheets: this._worksheets.filter(Boolean),\r\n      definedNames: this._definedNames.model,\r\n      views: this.views,\r\n      properties: {},\r\n      calcProperties: {},\r\n    };\r\n\r\n    return new Promise(resolve => {\r\n      const xform = new WorkbookXform();\r\n      xform.prepare(model);\r\n      zip.append(xform.toXml(model), {name: '/xl/workbook.xml'});\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  _finalize() {\r\n    return new Promise((resolve, reject) => {\r\n      this.stream.on('error', reject);\r\n      this.stream.on('finish', () => {\r\n        resolve(this);\r\n      });\r\n      this.zip.on('error', reject);\r\n\r\n      this.zip.finalize();\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = WorkbookWriter;\r\n","class SharedStrings {\r\n  constructor() {\r\n    this._values = [];\r\n    this._totalRefs = 0;\r\n    this._hash = Object.create(null);\r\n  }\r\n\r\n  get count() {\r\n    return this._values.length;\r\n  }\r\n\r\n  get values() {\r\n    return this._values;\r\n  }\r\n\r\n  get totalRefs() {\r\n    return this._totalRefs;\r\n  }\r\n\r\n  getString(index) {\r\n    return this._values[index];\r\n  }\r\n\r\n  add(value) {\r\n    let index = this._hash[value];\r\n    if (index === undefined) {\r\n      index = this._hash[value] = this._values.length;\r\n      this._values.push(value);\r\n    }\r\n    this._totalRefs++;\r\n    return index;\r\n  }\r\n}\r\n\r\nmodule.exports = SharedStrings;\r\n","const _ = require('../../utils/under-dash');\r\n\r\nconst RelType = require('../../xlsx/rel-type');\r\n\r\nconst colCache = require('../../utils/col-cache');\r\nconst Encryptor = require('../../utils/encryptor');\r\nconst Dimensions = require('../../doc/range');\r\nconst StringBuf = require('../../utils/string-buf');\r\n\r\nconst Row = require('../../doc/row');\r\nconst Column = require('../../doc/column');\r\n\r\nconst SheetRelsWriter = require('./sheet-rels-writer');\r\nconst SheetCommentsWriter = require('./sheet-comments-writer');\r\nconst DataValidations = require('../../doc/data-validations');\r\n\r\nconst xmlBuffer = new StringBuf();\r\n\r\n// ============================================================================================\r\n// Xforms\r\nconst ListXform = require('../../xlsx/xform/list-xform');\r\nconst DataValidationsXform = require('../../xlsx/xform/sheet/data-validations-xform');\r\nconst SheetPropertiesXform = require('../../xlsx/xform/sheet/sheet-properties-xform');\r\nconst SheetFormatPropertiesXform = require('../../xlsx/xform/sheet/sheet-format-properties-xform');\r\nconst ColXform = require('../../xlsx/xform/sheet/col-xform');\r\nconst RowXform = require('../../xlsx/xform/sheet/row-xform');\r\nconst HyperlinkXform = require('../../xlsx/xform/sheet/hyperlink-xform');\r\nconst SheetViewXform = require('../../xlsx/xform/sheet/sheet-view-xform');\r\nconst SheetProtectionXform = require('../../xlsx/xform/sheet/sheet-protection-xform');\r\nconst PageMarginsXform = require('../../xlsx/xform/sheet/page-margins-xform');\r\nconst PageSetupXform = require('../../xlsx/xform/sheet/page-setup-xform');\r\nconst AutoFilterXform = require('../../xlsx/xform/sheet/auto-filter-xform');\r\nconst PictureXform = require('../../xlsx/xform/sheet/picture-xform');\r\nconst ConditionalFormattingsXform = require('../../xlsx/xform/sheet/cf/conditional-formattings-xform');\r\nconst HeaderFooterXform = require('../../xlsx/xform/sheet/header-footer-xform');\r\nconst RowBreaksXform = require('../../xlsx/xform/sheet/row-breaks-xform');\r\n\r\n// since prepare and render are functional, we can use singletons\r\nconst xform = {\r\n  dataValidations: new DataValidationsXform(),\r\n  sheetProperties: new SheetPropertiesXform(),\r\n  sheetFormatProperties: new SheetFormatPropertiesXform(),\r\n  columns: new ListXform({tag: 'cols', length: false, childXform: new ColXform()}),\r\n  row: new RowXform(),\r\n  hyperlinks: new ListXform({tag: 'hyperlinks', length: false, childXform: new HyperlinkXform()}),\r\n  sheetViews: new ListXform({tag: 'sheetViews', length: false, childXform: new SheetViewXform()}),\r\n  sheetProtection: new SheetProtectionXform(),\r\n  pageMargins: new PageMarginsXform(),\r\n  pageSeteup: new PageSetupXform(),\r\n  autoFilter: new AutoFilterXform(),\r\n  picture: new PictureXform(),\r\n  conditionalFormattings: new ConditionalFormattingsXform(),\r\n  headerFooter: new HeaderFooterXform(),\r\n  rowBreaks: new RowBreaksXform(),\r\n};\r\n\r\n// ============================================================================================\r\n\r\nclass WorksheetWriter {\r\n  constructor(options) {\r\n    // in a workbook, each sheet will have a number\r\n    this.id = options.id;\r\n\r\n    // and a name\r\n    this.name = options.name || `Sheet${this.id}`;\r\n\r\n    // add a state\r\n    this.state = options.state || 'visible';\r\n\r\n    // rows are stored here while they need to be worked on.\r\n    // when they are committed, they will be deleted.\r\n    this._rows = [];\r\n\r\n    // column definitions\r\n    this._columns = null;\r\n\r\n    // column keys (addRow convenience): key ==> this._columns index\r\n    this._keys = {};\r\n\r\n    // keep a record of all row and column pageBreaks\r\n    this._merges = [];\r\n    this._merges.add = function() {}; // ignore cell instruction\r\n\r\n    // keep record of all hyperlinks\r\n    this._sheetRelsWriter = new SheetRelsWriter(options);\r\n\r\n    this._sheetCommentsWriter = new SheetCommentsWriter(this, this._sheetRelsWriter, options);\r\n\r\n    // keep a record of dimensions\r\n    this._dimensions = new Dimensions();\r\n\r\n    // first uncommitted row\r\n    this._rowZero = 1;\r\n\r\n    // committed flag\r\n    this.committed = false;\r\n\r\n    // for data validations\r\n    this.dataValidations = new DataValidations();\r\n\r\n    // for sharing formulae\r\n    this._formulae = {};\r\n    this._siFormulae = 0;\r\n\r\n    // keep a record of conditionalFormattings\r\n    this.conditionalFormatting = [];\r\n\r\n    // keep a record of all row and column pageBreaks\r\n    this.rowBreaks = [];\r\n\r\n    // for default row height, outline levels, etc\r\n    this.properties = Object.assign(\r\n      {},\r\n      {\r\n        defaultRowHeight: 15,\r\n        dyDescent: 55,\r\n        outlineLevelCol: 0,\r\n        outlineLevelRow: 0,\r\n      },\r\n      options.properties\r\n    );\r\n\r\n    this.headerFooter = Object.assign(\r\n      {},\r\n      {\r\n        differentFirst: false,\r\n        differentOddEven: false,\r\n        oddHeader: null,\r\n        oddFooter: null,\r\n        evenHeader: null,\r\n        evenFooter: null,\r\n        firstHeader: null,\r\n        firstFooter: null,\r\n      },\r\n      options.headerFooter\r\n    );\r\n\r\n    // for all things printing\r\n    this.pageSetup = Object.assign(\r\n      {},\r\n      {\r\n        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},\r\n        orientation: 'portrait',\r\n        horizontalDpi: 4294967295,\r\n        verticalDpi: 4294967295,\r\n        fitToPage: !!(\r\n          options.pageSetup &&\r\n          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&\r\n          !options.pageSetup.scale\r\n        ),\r\n        pageOrder: 'downThenOver',\r\n        blackAndWhite: false,\r\n        draft: false,\r\n        cellComments: 'None',\r\n        errors: 'displayed',\r\n        scale: 100,\r\n        fitToWidth: 1,\r\n        fitToHeight: 1,\r\n        paperSize: undefined,\r\n        showRowColHeaders: false,\r\n        showGridLines: false,\r\n        horizontalCentered: false,\r\n        verticalCentered: false,\r\n        rowBreaks: null,\r\n        colBreaks: null,\r\n      },\r\n      options.pageSetup\r\n    );\r\n\r\n    // using shared strings creates a smaller xlsx file but may use more memory\r\n    this.useSharedStrings = options.useSharedStrings || false;\r\n\r\n    this._workbook = options.workbook;\r\n\r\n    this.hasComments = false;\r\n\r\n    // views\r\n    this._views = options.views || [];\r\n\r\n    // auto filter\r\n    this.autoFilter = options.autoFilter || null;\r\n\r\n    this._media = [];\r\n\r\n    // worksheet protection\r\n    this.sheetProtection = null;\r\n\r\n    // start writing to stream now\r\n    this._writeOpenWorksheet();\r\n\r\n    this.startedData = false;\r\n  }\r\n\r\n  get workbook() {\r\n    return this._workbook;\r\n  }\r\n\r\n  get stream() {\r\n    if (!this._stream) {\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);\r\n\r\n      // pause stream to prevent 'data' events\r\n      this._stream.pause();\r\n    }\r\n    return this._stream;\r\n  }\r\n\r\n  // destroy - not a valid operation for a streaming writer\r\n  // even though some streamers might be able to, it's a bad idea.\r\n  destroy() {\r\n    throw new Error('Invalid Operation: destroy');\r\n  }\r\n\r\n  commit() {\r\n    if (this.committed) {\r\n      return;\r\n    }\r\n    // commit all rows\r\n    this._rows.forEach(cRow => {\r\n      if (cRow) {\r\n        // write the row to the stream\r\n        this._writeRow(cRow);\r\n      }\r\n    });\r\n\r\n    // we _cannot_ accept new rows from now on\r\n    this._rows = null;\r\n\r\n    if (!this.startedData) {\r\n      this._writeOpenSheetData();\r\n    }\r\n    this._writeCloseSheetData();\r\n    this._writeAutoFilter();\r\n    this._writeMergeCells();\r\n\r\n    // for some reason, Excel can't handle dimensions at the bottom of the file\r\n    // this._writeDimensions();\r\n\r\n    this._writeHyperlinks();\r\n    this._writeConditionalFormatting();\r\n    this._writeDataValidations();\r\n    this._writeSheetProtection();\r\n    this._writePageMargins();\r\n    this._writePageSetup();\r\n    this._writeBackground();\r\n    this._writeHeaderFooter();\r\n    this._writeRowBreaks();\r\n\r\n    // Legacy Data tag for comments\r\n    this._writeLegacyData();\r\n\r\n    this._writeCloseWorksheet();\r\n    // signal end of stream to workbook\r\n    this.stream.end();\r\n\r\n    this._sheetCommentsWriter.commit();\r\n    // also commit the hyperlinks if any\r\n    this._sheetRelsWriter.commit();\r\n\r\n    this.committed = true;\r\n  }\r\n\r\n  // return the current dimensions of the writer\r\n  get dimensions() {\r\n    return this._dimensions;\r\n  }\r\n\r\n  get views() {\r\n    return this._views;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Columns\r\n\r\n  // get the current columns array.\r\n  get columns() {\r\n    return this._columns;\r\n  }\r\n\r\n  // set the columns from an array of column definitions.\r\n  // Note: any headers defined will overwrite existing values.\r\n  set columns(value) {\r\n    // calculate max header row count\r\n    this._headerRowCount = value.reduce((pv, cv) => {\r\n      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;\r\n      return Math.max(pv, headerCount);\r\n    }, 0);\r\n\r\n    // construct Column objects\r\n    let count = 1;\r\n    const columns = (this._columns = []);\r\n    value.forEach(defn => {\r\n      const column = new Column(this, count++, false);\r\n      columns.push(column);\r\n      column.defn = defn;\r\n    });\r\n  }\r\n\r\n  getColumnKey(key) {\r\n    return this._keys[key];\r\n  }\r\n\r\n  setColumnKey(key, value) {\r\n    this._keys[key] = value;\r\n  }\r\n\r\n  deleteColumnKey(key) {\r\n    delete this._keys[key];\r\n  }\r\n\r\n  eachColumnKey(f) {\r\n    _.each(this._keys, f);\r\n  }\r\n\r\n  // get a single column by col number. If it doesn't exist, it and any gaps before it\r\n  // are created.\r\n  getColumn(c) {\r\n    if (typeof c === 'string') {\r\n      // if it matches a key'd column, return that\r\n      const col = this._keys[c];\r\n      if (col) return col;\r\n\r\n      // otherwise, assume letter\r\n      c = colCache.l2n(c);\r\n    }\r\n    if (!this._columns) {\r\n      this._columns = [];\r\n    }\r\n    if (c > this._columns.length) {\r\n      let n = this._columns.length + 1;\r\n      while (n <= c) {\r\n        this._columns.push(new Column(this, n++));\r\n      }\r\n    }\r\n    return this._columns[c - 1];\r\n  }\r\n\r\n  // =========================================================================\r\n  // Rows\r\n  get _nextRow() {\r\n    return this._rowZero + this._rows.length;\r\n  }\r\n\r\n  // iterate over every uncommitted row in the worksheet, including maybe empty rows\r\n  eachRow(options, iteratee) {\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = undefined;\r\n    }\r\n    if (options && options.includeEmpty) {\r\n      const n = this._nextRow;\r\n      for (let i = this._rowZero; i < n; i++) {\r\n        iteratee(this.getRow(i), i);\r\n      }\r\n    } else {\r\n      this._rows.forEach(row => {\r\n        if (row.hasValues) {\r\n          iteratee(row, row.number);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _commitRow(cRow) {\r\n    // since rows must be written in order, we commit all rows up till and including cRow\r\n    let found = false;\r\n    while (this._rows.length && !found) {\r\n      const row = this._rows.shift();\r\n      this._rowZero++;\r\n      if (row) {\r\n        this._writeRow(row);\r\n        found = row.number === cRow.number;\r\n        this._rowZero = row.number + 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  get lastRow() {\r\n    // returns last uncommitted row\r\n    if (this._rows.length) {\r\n      return this._rows[this._rows.length - 1];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // find a row (if exists) by row number\r\n  findRow(rowNumber) {\r\n    const index = rowNumber - this._rowZero;\r\n    return this._rows[index];\r\n  }\r\n\r\n  getRow(rowNumber) {\r\n    const index = rowNumber - this._rowZero;\r\n\r\n    // may fail if rows have been comitted\r\n    if (index < 0) {\r\n      throw new Error('Out of bounds: this row has been committed');\r\n    }\r\n    let row = this._rows[index];\r\n    if (!row) {\r\n      this._rows[index] = row = new Row(this, rowNumber);\r\n    }\r\n    return row;\r\n  }\r\n\r\n  addRow(value) {\r\n    const row = new Row(this, this._nextRow);\r\n    this._rows[row.number - this._rowZero] = row;\r\n    row.values = value;\r\n    return row;\r\n  }\r\n\r\n  // ================================================================================\r\n  // Cells\r\n\r\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\r\n  findCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this.findRow(address.row);\r\n    return row ? row.findCell(address.column) : undefined;\r\n  }\r\n\r\n  // return the cell at [r,c] or address given by r. If not found, create a new one.\r\n  getCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this.getRow(address.row);\r\n    return row.getCellEx(address);\r\n  }\r\n\r\n  mergeCells(...cells) {\r\n    // may fail if rows have been comitted\r\n    const dimensions = new Dimensions(cells);\r\n\r\n    // check cells aren't already merged\r\n    this._merges.forEach(merge => {\r\n      if (merge.intersects(dimensions)) {\r\n        throw new Error('Cannot merge already merged cells');\r\n      }\r\n    });\r\n\r\n    // apply merge\r\n    const master = this.getCell(dimensions.top, dimensions.left);\r\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n        if (i > dimensions.top || j > dimensions.left) {\r\n          this.getCell(i, j).merge(master);\r\n        }\r\n      }\r\n    }\r\n\r\n    // index merge\r\n    this._merges.push(dimensions);\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Conditional Formatting\r\n  addConditionalFormatting(cf) {\r\n    this.conditionalFormatting.push(cf);\r\n  }\r\n\r\n  removeConditionalFormatting(filter) {\r\n    if (typeof filter === 'number') {\r\n      this.conditionalFormatting.splice(filter, 1);\r\n    } else if (filter instanceof Function) {\r\n      this.conditionalFormatting = this.conditionalFormatting.filter(filter);\r\n    } else {\r\n      this.conditionalFormatting = [];\r\n    }\r\n  }\r\n\r\n  // =========================================================================\r\n\r\n  addBackgroundImage(imageId) {\r\n    this._background = {\r\n      imageId,\r\n    };\r\n  }\r\n\r\n  getBackgroundImageId() {\r\n    return this._background && this._background.imageId;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Worksheet Protection\r\n  protect(password, options) {\r\n    // TODO: make this function truly async\r\n    // perhaps marshal to worker thread or something\r\n    return new Promise(resolve => {\r\n      this.sheetProtection = {\r\n        sheet: true,\r\n      };\r\n      if (options && 'spinCount' in options) {\r\n        // force spinCount to be integer >= 0\r\n        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;\r\n      }\r\n      if (password) {\r\n        this.sheetProtection.algorithmName = 'SHA-512';\r\n        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\r\n        this.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\r\n        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(\r\n          password,\r\n          'SHA512',\r\n          this.sheetProtection.saltValue,\r\n          this.sheetProtection.spinCount\r\n        );\r\n      }\r\n      if (options) {\r\n        this.sheetProtection = Object.assign(this.sheetProtection, options);\r\n        if (!password && 'spinCount' in options) {\r\n          delete this.sheetProtection.spinCount;\r\n        }\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  unprotect() {\r\n    this.sheetProtection = null;\r\n  }\r\n\r\n  // ================================================================================\r\n\r\n  _write(text) {\r\n    xmlBuffer.reset();\r\n    xmlBuffer.addText(text);\r\n    this.stream.write(xmlBuffer);\r\n  }\r\n\r\n  _writeSheetProperties(xmlBuf, properties, pageSetup) {\r\n    const sheetPropertiesModel = {\r\n      outlineProperties: properties && properties.outlineProperties,\r\n      tabColor: properties && properties.tabColor,\r\n      pageSetup:\r\n        pageSetup && pageSetup.fitToPage\r\n          ? {\r\n              fitToPage: pageSetup.fitToPage,\r\n            }\r\n          : undefined,\r\n    };\r\n\r\n    xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));\r\n  }\r\n\r\n  _writeSheetFormatProperties(xmlBuf, properties) {\r\n    const sheetFormatPropertiesModel = properties\r\n      ? {\r\n          defaultRowHeight: properties.defaultRowHeight,\r\n          dyDescent: properties.dyDescent,\r\n          outlineLevelCol: properties.outlineLevelCol,\r\n          outlineLevelRow: properties.outlineLevelRow,\r\n        }\r\n      : undefined;\r\n    if (properties.defaultColWidth) {\r\n      sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;\r\n    }\r\n\r\n    xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));\r\n  }\r\n\r\n  _writeOpenWorksheet() {\r\n    xmlBuffer.reset();\r\n\r\n    xmlBuffer.addText('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>');\r\n    xmlBuffer.addText(\r\n      '<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"' +\r\n        ' xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"' +\r\n        ' xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"' +\r\n        ' mc:Ignorable=\"x14ac\"' +\r\n        ' xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">'\r\n    );\r\n\r\n    this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);\r\n\r\n    xmlBuffer.addText(xform.sheetViews.toXml(this.views));\r\n\r\n    this._writeSheetFormatProperties(xmlBuffer, this.properties);\r\n\r\n    this.stream.write(xmlBuffer);\r\n  }\r\n\r\n  _writeColumns() {\r\n    const cols = Column.toModel(this.columns);\r\n    if (cols) {\r\n      xform.columns.prepare(cols, {styles: this._workbook.styles});\r\n      this.stream.write(xform.columns.toXml(cols));\r\n    }\r\n  }\r\n\r\n  _writeOpenSheetData() {\r\n    this._write('<sheetData>');\r\n  }\r\n\r\n  _writeRow(row) {\r\n    if (!this.startedData) {\r\n      this._writeColumns();\r\n      this._writeOpenSheetData();\r\n      this.startedData = true;\r\n    }\r\n\r\n    if (row.hasValues || row.height) {\r\n      const {model} = row;\r\n      const options = {\r\n        styles: this._workbook.styles,\r\n        sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : undefined,\r\n        hyperlinks: this._sheetRelsWriter.hyperlinksProxy,\r\n        merges: this._merges,\r\n        formulae: this._formulae,\r\n        siFormulae: this._siFormulae,\r\n        comments: [],\r\n      };\r\n      xform.row.prepare(model, options);\r\n      this.stream.write(xform.row.toXml(model));\r\n\r\n      if (options.comments.length) {\r\n        this.hasComments = true;\r\n        this._sheetCommentsWriter.addComments(options.comments);\r\n      }\r\n    }\r\n  }\r\n\r\n  _writeCloseSheetData() {\r\n    this._write('</sheetData>');\r\n  }\r\n\r\n  _writeMergeCells() {\r\n    if (this._merges.length) {\r\n      xmlBuffer.reset();\r\n      xmlBuffer.addText(`<mergeCells count=\"${this._merges.length}\">`);\r\n      this._merges.forEach(merge => {\r\n        xmlBuffer.addText(`<mergeCell ref=\"${merge}\"/>`);\r\n      });\r\n      xmlBuffer.addText('</mergeCells>');\r\n\r\n      this.stream.write(xmlBuffer);\r\n    }\r\n  }\r\n\r\n  _writeHyperlinks() {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));\r\n  }\r\n\r\n  _writeConditionalFormatting() {\r\n    const options = {\r\n      styles: this._workbook.styles,\r\n    };\r\n    xform.conditionalFormattings.prepare(this.conditionalFormatting, options);\r\n    this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));\r\n  }\r\n\r\n  _writeRowBreaks() {\r\n    this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));\r\n  }\r\n\r\n  _writeDataValidations() {\r\n    this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));\r\n  }\r\n\r\n  _writeSheetProtection() {\r\n    this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));\r\n  }\r\n\r\n  _writePageMargins() {\r\n    this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));\r\n  }\r\n\r\n  _writePageSetup() {\r\n    this.stream.write(xform.pageSeteup.toXml(this.pageSetup));\r\n  }\r\n\r\n  _writeHeaderFooter() {\r\n    this.stream.write(xform.headerFooter.toXml(this.headerFooter));\r\n  }\r\n\r\n  _writeAutoFilter() {\r\n    this.stream.write(xform.autoFilter.toXml(this.autoFilter));\r\n  }\r\n\r\n  _writeBackground() {\r\n    if (this._background) {\r\n      if (this._background.imageId !== undefined) {\r\n        const image = this._workbook.getImage(this._background.imageId);\r\n        const pictureId = this._sheetRelsWriter.addMedia({\r\n          Target: `../media/${image.name}`,\r\n          Type: RelType.Image,\r\n        });\r\n\r\n        this._background = {\r\n          ...this._background,\r\n          rId: pictureId,\r\n        };\r\n      }\r\n      this.stream.write(xform.picture.toXml({rId: this._background.rId}));\r\n    }\r\n  }\r\n\r\n  _writeLegacyData() {\r\n    if (this.hasComments) {\r\n      xmlBuffer.reset();\r\n      xmlBuffer.addText(`<legacyDrawing r:id=\"${this._sheetCommentsWriter.vmlRelId}\"/>`);\r\n      this.stream.write(xmlBuffer);\r\n    }\r\n  }\r\n\r\n  _writeDimensions() {\r\n    // for some reason, Excel can't handle dimensions at the bottom of the file\r\n    // and we don't know the dimensions until the commit, so don't write them.\r\n    // this._write('<dimension ref=\"' + this._dimensions + '\"/>');\r\n  }\r\n\r\n  _writeCloseWorksheet() {\r\n    this._write('</worksheet>');\r\n  }\r\n}\r\n\r\nmodule.exports = WorksheetWriter;\r\n","/* eslint-disable max-classes-per-file */\r\nconst utils = require('../../utils/utils');\r\nconst RelType = require('../../xlsx/rel-type');\r\n\r\nclass HyperlinksProxy {\r\n  constructor(sheetRelsWriter) {\r\n    this.writer = sheetRelsWriter;\r\n  }\r\n\r\n  push(hyperlink) {\r\n    this.writer.addHyperlink(hyperlink);\r\n  }\r\n}\r\n\r\nclass SheetRelsWriter {\r\n  constructor(options) {\r\n    // in a workbook, each sheet will have a number\r\n    this.id = options.id;\r\n\r\n    // count of all relationships\r\n    this.count = 0;\r\n\r\n    // keep record of all hyperlinks\r\n    this._hyperlinks = [];\r\n\r\n    this._workbook = options.workbook;\r\n  }\r\n\r\n  get stream() {\r\n    if (!this._stream) {\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);\r\n    }\r\n    return this._stream;\r\n  }\r\n\r\n  get length() {\r\n    return this._hyperlinks.length;\r\n  }\r\n\r\n  each(fn) {\r\n    return this._hyperlinks.forEach(fn);\r\n  }\r\n\r\n  get hyperlinksProxy() {\r\n    return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));\r\n  }\r\n\r\n  addHyperlink(hyperlink) {\r\n    // Write to stream\r\n    const relationship = {\r\n      Target: hyperlink.target,\r\n      Type: RelType.Hyperlink,\r\n      TargetMode: 'External',\r\n    };\r\n    const rId = this._writeRelationship(relationship);\r\n\r\n    // store sheet stuff for later\r\n    this._hyperlinks.push({\r\n      rId,\r\n      address: hyperlink.address,\r\n    });\r\n  }\r\n\r\n  addMedia(media) {\r\n    return this._writeRelationship(media);\r\n  }\r\n\r\n  addRelationship(rel) {\r\n    return this._writeRelationship(rel);\r\n  }\r\n\r\n  commit() {\r\n    if (this.count) {\r\n      // write xml utro\r\n      this._writeClose();\r\n      // and close stream\r\n      this.stream.end();\r\n    }\r\n  }\r\n\r\n  // ================================================================================\r\n  _writeOpen() {\r\n    this.stream.write(\r\n      `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n       <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">`\r\n    );\r\n  }\r\n\r\n  _writeRelationship(relationship) {\r\n    if (!this.count) {\r\n      this._writeOpen();\r\n    }\r\n\r\n    const rId = `rId${++this.count}`;\r\n\r\n    if (relationship.TargetMode) {\r\n      this.stream.write(\r\n        `<Relationship Id=\"${rId}\"` +\r\n          ` Type=\"${relationship.Type}\"` +\r\n          ` Target=\"${utils.xmlEncode(relationship.Target)}\"` +\r\n          ` TargetMode=\"${relationship.TargetMode}\"` +\r\n          '/>'\r\n      );\r\n    } else {\r\n      this.stream.write(\r\n        `<Relationship Id=\"${rId}\" Type=\"${relationship.Type}\" Target=\"${relationship.Target}\"/>`\r\n      );\r\n    }\r\n\r\n    return rId;\r\n  }\r\n\r\n  _writeClose() {\r\n    this.stream.write('</Relationships>');\r\n  }\r\n}\r\n\r\nmodule.exports = SheetRelsWriter;\r\n","const XmlStream = require('../../utils/xml-stream');\r\nconst RelType = require('../../xlsx/rel-type');\r\nconst colCache = require('../../utils/col-cache');\r\nconst CommentXform = require('../../xlsx/xform/comment/comment-xform');\r\nconst VmlShapeXform = require('../../xlsx/xform/comment/vml-shape-xform');\r\n\r\nclass SheetCommentsWriter {\r\n  constructor(worksheet, sheetRelsWriter, options) {\r\n    // in a workbook, each sheet will have a number\r\n    this.id = options.id;\r\n    this.count = 0;\r\n    this._worksheet = worksheet;\r\n    this._workbook = options.workbook;\r\n    this._sheetRelsWriter = sheetRelsWriter;\r\n  }\r\n\r\n  get commentsStream() {\r\n    if (!this._commentsStream) {\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);\r\n    }\r\n    return this._commentsStream;\r\n  }\r\n\r\n  get vmlStream() {\r\n    if (!this._vmlStream) {\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);\r\n    }\r\n    return this._vmlStream;\r\n  }\r\n\r\n  _addRelationships() {\r\n    const commentRel = {\r\n      Type: RelType.Comments,\r\n      Target: `../comments${this.id}.xml`,\r\n    };\r\n    this._sheetRelsWriter.addRelationship(commentRel);\r\n\r\n    const vmlDrawingRel = {\r\n      Type: RelType.VmlDrawing,\r\n      Target: `../drawings/vmlDrawing${this.id}.vml`,\r\n    };\r\n    this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);\r\n  }\r\n\r\n  _addCommentRefs() {\r\n    this._workbook.commentRefs.push({\r\n      commentName: `comments${this.id}`,\r\n      vmlDrawing: `vmlDrawing${this.id}`,\r\n    });\r\n  }\r\n\r\n  _writeOpen() {\r\n    this.commentsStream.write(\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\r\n        '<comments xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">' +\r\n        '<authors><author>Author</author></authors>' +\r\n        '<commentList>'\r\n    );\r\n    this.vmlStream.write(\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\r\n        '<xml xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\">' +\r\n        '<o:shapelayout v:ext=\"edit\">' +\r\n        '<o:idmap v:ext=\"edit\" data=\"1\" />' +\r\n        '</o:shapelayout>' +\r\n        '<v:shapetype id=\"_x0000_t202\" coordsize=\"21600,21600\" o:spt=\"202\" path=\"m,l,21600r21600,l21600,xe\">' +\r\n        '<v:stroke joinstyle=\"miter\" />' +\r\n        '<v:path gradientshapeok=\"t\" o:connecttype=\"rect\" />' +\r\n        '</v:shapetype>'\r\n    );\r\n  }\r\n\r\n  _writeComment(comment, index) {\r\n    const commentXform = new CommentXform();\r\n    const commentsXmlStream = new XmlStream();\r\n    commentXform.render(commentsXmlStream, comment);\r\n    this.commentsStream.write(commentsXmlStream.xml);\r\n\r\n    const vmlShapeXform = new VmlShapeXform();\r\n    const vmlXmlStream = new XmlStream();\r\n    vmlShapeXform.render(vmlXmlStream, comment, index);\r\n    this.vmlStream.write(vmlXmlStream.xml);\r\n  }\r\n\r\n  _writeClose() {\r\n    this.commentsStream.write('</commentList></comments>');\r\n    this.vmlStream.write('</xml>');\r\n  }\r\n\r\n  addComments(comments) {\r\n    if (comments && comments.length) {\r\n      if (!this.startedData) {\r\n        this._worksheet.comments = [];\r\n        this._writeOpen();\r\n        this._addRelationships();\r\n        this._addCommentRefs();\r\n        this.startedData = true;\r\n      }\r\n\r\n      comments.forEach(item => {\r\n        item.refAddress = colCache.decodeAddress(item.ref);\r\n      });\r\n\r\n      comments.forEach(comment => {\r\n        this._writeComment(comment, this.count);\r\n        this.count += 1;\r\n      });\r\n    }\r\n  }\r\n\r\n  commit() {\r\n    if (this.count) {\r\n      this._writeClose();\r\n      this.commentsStream.end();\r\n      this.vmlStream.end();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = SheetCommentsWriter;\r\n","const fs = require('fs');\r\nconst {EventEmitter} = require('events');\r\nconst {PassThrough, Readable} = require('readable-stream');\r\nconst nodeStream = require('stream');\r\nconst unzip = require('unzipper');\r\nconst tmp = require('tmp');\r\nconst iterateStream = require('../../utils/iterate-stream');\r\nconst parseSax = require('../../utils/parse-sax');\r\n\r\nconst StyleManager = require('../../xlsx/xform/style/styles-xform');\r\nconst WorkbookXform = require('../../xlsx/xform/book/workbook-xform');\r\nconst RelationshipsXform = require('../../xlsx/xform/core/relationships-xform');\r\n\r\nconst WorksheetReader = require('./worksheet-reader');\r\nconst HyperlinkReader = require('./hyperlink-reader');\r\n\r\ntmp.setGracefulCleanup();\r\n\r\nclass WorkbookReader extends EventEmitter {\r\n  constructor(input, options = {}) {\r\n    super();\r\n\r\n    this.input = input;\r\n\r\n    this.options = {\r\n      worksheets: 'emit',\r\n      sharedStrings: 'cache',\r\n      hyperlinks: 'ignore',\r\n      styles: 'ignore',\r\n      entries: 'ignore',\r\n      ...options,\r\n    };\r\n\r\n    this.styles = new StyleManager();\r\n    this.styles.init();\r\n  }\r\n\r\n  _getStream(input) {\r\n    if (input instanceof nodeStream.Readable || input instanceof Readable) {\r\n      return input;\r\n    }\r\n    if (typeof input === 'string') {\r\n      return fs.createReadStream(input);\r\n    }\r\n    throw new Error(`Could not recognise input: ${input}`);\r\n  }\r\n\r\n  async read(input, options) {\r\n    try {\r\n      for await (const {eventType, value} of this.parse(input, options)) {\r\n        switch (eventType) {\r\n          case 'shared-strings':\r\n            this.emit(eventType, value);\r\n            break;\r\n          case 'worksheet':\r\n            this.emit(eventType, value);\r\n            await value.read();\r\n            break;\r\n          case 'hyperlinks':\r\n            this.emit(eventType, value);\r\n            break;\r\n        }\r\n      }\r\n      this.emit('end');\r\n      this.emit('finished');\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n    }\r\n  }\r\n\r\n  async *[Symbol.asyncIterator]() {\r\n    for await (const {eventType, value} of this.parse()) {\r\n      if (eventType === 'worksheet') {\r\n        yield value;\r\n      }\r\n    }\r\n  }\r\n\r\n  async *parse(input, options) {\r\n    if (options) this.options = options;\r\n    const stream = (this.stream = this._getStream(input || this.input));\r\n    const zip = unzip.Parse({forceStream: true});\r\n    stream.pipe(zip);\r\n\r\n    // worksheets, deferred for parsing after shared strings reading\r\n    const waitingWorkSheets = [];\r\n\r\n    for await (const entry of iterateStream(zip)) {\r\n      let match;\r\n      let sheetNo;\r\n      switch (entry.path) {\r\n        case '_rels/.rels':\r\n          break;\r\n        case 'xl/_rels/workbook.xml.rels':\r\n          await this._parseRels(entry);\r\n          break;\r\n        case 'xl/workbook.xml':\r\n          await this._parseWorkbook(entry);\r\n          break;\r\n        case 'xl/sharedStrings.xml':\r\n          yield* this._parseSharedStrings(entry);\r\n          break;\r\n        case 'xl/styles.xml':\r\n          await this._parseStyles(entry);\r\n          break;\r\n        default:\r\n          if (entry.path.match(/xl\\/worksheets\\/sheet\\d+[.]xml/)) {\r\n            match = entry.path.match(/xl\\/worksheets\\/sheet(\\d+)[.]xml/);\r\n            sheetNo = match[1];\r\n            if (this.sharedStrings && this.workbookRels) {\r\n              yield* this._parseWorksheet(iterateStream(entry), sheetNo);\r\n            } else {\r\n              // create temp file for each worksheet\r\n              await new Promise((resolve, reject) => {\r\n                tmp.file((err, path, fd, tempFileCleanupCallback) => {\r\n                  if (err) {\r\n                    return reject(err);\r\n                  }\r\n                  waitingWorkSheets.push({sheetNo, path, tempFileCleanupCallback});\r\n\r\n                  const tempStream = fs.createWriteStream(path);\r\n                  entry.pipe(tempStream);\r\n                  return tempStream.on('finish', () => {\r\n                    return resolve();\r\n                  });\r\n                });\r\n              });\r\n            }\r\n          } else if (entry.path.match(/xl\\/worksheets\\/_rels\\/sheet\\d+[.]xml.rels/)) {\r\n            match = entry.path.match(/xl\\/worksheets\\/_rels\\/sheet(\\d+)[.]xml.rels/);\r\n            sheetNo = match[1];\r\n            yield* this._parseHyperlinks(iterateStream(entry), sheetNo);\r\n          }\r\n          break;\r\n      }\r\n      entry.autodrain();\r\n    }\r\n\r\n    for (const {sheetNo, path, tempFileCleanupCallback} of waitingWorkSheets) {\r\n      let fileStream = fs.createReadStream(path);\r\n      // TODO: Remove once node v8 is deprecated\r\n      // Detect and upgrade old fileStreams\r\n      if (!fileStream[Symbol.asyncIterator]) {\r\n        fileStream = fileStream.pipe(new PassThrough());\r\n      }\r\n      yield* this._parseWorksheet(fileStream, sheetNo);\r\n      tempFileCleanupCallback();\r\n    }\r\n  }\r\n\r\n  _emitEntry(payload) {\r\n    if (this.options.entries === 'emit') {\r\n      this.emit('entry', payload);\r\n    }\r\n  }\r\n\r\n  async _parseRels(entry) {\r\n    const xform = new RelationshipsXform();\r\n    this.workbookRels = await xform.parseStream(iterateStream(entry));\r\n  }\r\n\r\n  async _parseWorkbook(entry) {\r\n    this._emitEntry({type: 'workbook'});\r\n\r\n    const workbook = new WorkbookXform();\r\n    await workbook.parseStream(iterateStream(entry));\r\n\r\n    this.properties = workbook.map.workbookPr;\r\n    this.model = workbook.model;\r\n  }\r\n\r\n  async *_parseSharedStrings(entry) {\r\n    this._emitEntry({type: 'shared-strings'});\r\n    switch (this.options.sharedStrings) {\r\n      case 'cache':\r\n        this.sharedStrings = [];\r\n        break;\r\n      case 'emit':\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    let text = null;\r\n    let richText = [];\r\n    let index = 0;\r\n    let font = null;\r\n    for await (const events of parseSax(iterateStream(entry))) {\r\n      for (const {eventType, value} of events) {\r\n        if (eventType === 'opentag') {\r\n          const node = value;\r\n          switch (node.name) {\r\n            case 'b':\r\n              font = font || {};\r\n              font.bold = true;\r\n              break;\r\n            case 'charset':\r\n              font = font || {};\r\n              font.charset = parseInt(node.attributes.charset, 10);\r\n              break;\r\n            case 'color':\r\n              font = font || {};\r\n              font.color = {};\r\n              if (node.attributes.rgb) {\r\n                font.color.argb = node.attributes.argb;\r\n              }\r\n              if (node.attributes.val) {\r\n                font.color.argb = node.attributes.val;\r\n              }\r\n              if (node.attributes.theme) {\r\n                font.color.theme = node.attributes.theme;\r\n              }\r\n              break;\r\n            case 'family':\r\n              font = font || {};\r\n              font.family = parseInt(node.attributes.val, 10);\r\n              break;\r\n            case 'i':\r\n              font = font || {};\r\n              font.italic = true;\r\n              break;\r\n            case 'outline':\r\n              font = font || {};\r\n              font.outline = true;\r\n              break;\r\n            case 'rFont':\r\n              font = font || {};\r\n              font.name = node.value;\r\n              break;\r\n            case 'si':\r\n              font = null;\r\n              richText = [];\r\n              text = null;\r\n              break;\r\n            case 'sz':\r\n              font = font || {};\r\n              font.size = parseInt(node.attributes.val, 10);\r\n              break;\r\n            case 'strike':\r\n              break;\r\n            case 't':\r\n              text = null;\r\n              break;\r\n            case 'u':\r\n              font = font || {};\r\n              font.underline = true;\r\n              break;\r\n            case 'vertAlign':\r\n              font = font || {};\r\n              font.vertAlign = node.attributes.val;\r\n              break;\r\n          }\r\n        } else if (eventType === 'text') {\r\n          text = text ? text + value : value;\r\n        } else if (eventType === 'closetag') {\r\n          const node = value;\r\n          switch (node.name) {\r\n            case 'r':\r\n              richText.push({\r\n                font,\r\n                text,\r\n              });\r\n\r\n              font = null;\r\n              text = null;\r\n              break;\r\n            case 'si':\r\n              if (this.options.sharedStrings === 'cache') {\r\n                this.sharedStrings.push(richText.length ? {richText} : text);\r\n              } else if (this.options.sharedStrings === 'emit') {\r\n                yield {index: index++, text: richText.length ? {richText} : text};\r\n              }\r\n\r\n              richText = [];\r\n              font = null;\r\n              text = null;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async _parseStyles(entry) {\r\n    this._emitEntry({type: 'styles'});\r\n    if (this.options.styles === 'cache') {\r\n      this.styles = new StyleManager();\r\n      await this.styles.parseStream(iterateStream(entry));\r\n    }\r\n  }\r\n\r\n  *_parseWorksheet(iterator, sheetNo) {\r\n    this._emitEntry({type: 'worksheet', id: sheetNo});\r\n    const worksheetReader = new WorksheetReader({\r\n      workbook: this,\r\n      id: sheetNo,\r\n      iterator,\r\n      options: this.options,\r\n    });\r\n\r\n    const matchingRel = (this.workbookRels || []).find(\r\n      rel => rel.Target === `worksheets/sheet${sheetNo}.xml`\r\n    );\r\n    const matchingSheet =\r\n      matchingRel && (this.model.sheets || []).find(sheet => sheet.rId === matchingRel.Id);\r\n    if (matchingSheet) {\r\n      worksheetReader.id = matchingSheet.id;\r\n      worksheetReader.name = matchingSheet.name;\r\n      worksheetReader.state = matchingSheet.state;\r\n    }\r\n    if (this.options.worksheets === 'emit') {\r\n      yield {eventType: 'worksheet', value: worksheetReader};\r\n    }\r\n  }\r\n\r\n  *_parseHyperlinks(iterator, sheetNo) {\r\n    this._emitEntry({type: 'hyperlinks', id: sheetNo});\r\n    const hyperlinksReader = new HyperlinkReader({\r\n      workbook: this,\r\n      id: sheetNo,\r\n      iterator,\r\n      options: this.options,\r\n    });\r\n    if (this.options.hyperlinks === 'emit') {\r\n      yield {eventType: 'hyperlinks', value: hyperlinksReader};\r\n    }\r\n  }\r\n}\r\n\r\n// for reference - these are the valid values for options\r\nWorkbookReader.Options = {\r\n  worksheets: ['emit', 'ignore'],\r\n  sharedStrings: ['cache', 'emit', 'ignore'],\r\n  hyperlinks: ['cache', 'emit', 'ignore'],\r\n  styles: ['cache', 'ignore'],\r\n  entries: ['emit', 'ignore'],\r\n};\r\n\r\nmodule.exports = WorkbookReader;\r\n","module.exports = async function* iterateStream(stream) {\r\n  const contents = [];\r\n  stream.on('data', data => contents.push(data));\r\n\r\n  let resolveStreamEndedPromise;\r\n  const streamEndedPromise = new Promise(resolve => (resolveStreamEndedPromise = resolve));\r\n\r\n  let ended = false;\r\n  stream.on('end', () => {\r\n    ended = true;\r\n    resolveStreamEndedPromise();\r\n  });\r\n\r\n  let error = false;\r\n  stream.on('error', err => {\r\n    error = err;\r\n    resolveStreamEndedPromise();\r\n  });\r\n\r\n  while (!ended || contents.length > 0) {\r\n    if (contents.length === 0) {\r\n      stream.resume();\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await Promise.race([once(stream, 'data'), streamEndedPromise]);\r\n    } else {\r\n      stream.pause();\r\n      const data = contents.shift();\r\n      yield data;\r\n    }\r\n    if (error) throw error;\r\n  }\r\n  resolveStreamEndedPromise();\r\n};\r\n\r\nfunction once(eventEmitter, type) {\r\n  // TODO: Use require('events').once when node v10 is dropped\r\n  return new Promise(resolve => {\r\n    let fired = false;\r\n    const handler = () => {\r\n      if (!fired) {\r\n        fired = true;\r\n        eventEmitter.removeListener(type, handler);\r\n        resolve();\r\n      }\r\n    };\r\n    eventEmitter.addListener(type, handler);\r\n  });\r\n}\r\n","const {EventEmitter} = require('events');\r\nconst parseSax = require('../../utils/parse-sax');\r\n\r\nconst _ = require('../../utils/under-dash');\r\nconst utils = require('../../utils/utils');\r\nconst colCache = require('../../utils/col-cache');\r\nconst Dimensions = require('../../doc/range');\r\n\r\nconst Row = require('../../doc/row');\r\nconst Column = require('../../doc/column');\r\n\r\nclass WorksheetReader extends EventEmitter {\r\n  constructor({workbook, id, iterator, options}) {\r\n    super();\r\n\r\n    this.workbook = workbook;\r\n    this.id = id;\r\n    this.iterator = iterator;\r\n    this.options = options || {};\r\n\r\n    // and a name\r\n    this.name = `Sheet${this.id}`;\r\n\r\n    // column definitions\r\n    this._columns = null;\r\n    this._keys = {};\r\n\r\n    // keep a record of dimensions\r\n    this._dimensions = new Dimensions();\r\n  }\r\n\r\n  // destroy - not a valid operation for a streaming writer\r\n  // even though some streamers might be able to, it's a bad idea.\r\n  destroy() {\r\n    throw new Error('Invalid Operation: destroy');\r\n  }\r\n\r\n  // return the current dimensions of the writer\r\n  get dimensions() {\r\n    return this._dimensions;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Columns\r\n\r\n  // get the current columns array.\r\n  get columns() {\r\n    return this._columns;\r\n  }\r\n\r\n  // get a single column by col number. If it doesn't exist, it and any gaps before it\r\n  // are created.\r\n  getColumn(c) {\r\n    if (typeof c === 'string') {\r\n      // if it matches a key'd column, return that\r\n      const col = this._keys[c];\r\n      if (col) {\r\n        return col;\r\n      }\r\n\r\n      // otherise, assume letter\r\n      c = colCache.l2n(c);\r\n    }\r\n    if (!this._columns) {\r\n      this._columns = [];\r\n    }\r\n    if (c > this._columns.length) {\r\n      let n = this._columns.length + 1;\r\n      while (n <= c) {\r\n        this._columns.push(new Column(this, n++));\r\n      }\r\n    }\r\n    return this._columns[c - 1];\r\n  }\r\n\r\n  getColumnKey(key) {\r\n    return this._keys[key];\r\n  }\r\n\r\n  setColumnKey(key, value) {\r\n    this._keys[key] = value;\r\n  }\r\n\r\n  deleteColumnKey(key) {\r\n    delete this._keys[key];\r\n  }\r\n\r\n  eachColumnKey(f) {\r\n    _.each(this._keys, f);\r\n  }\r\n\r\n  async read() {\r\n    try {\r\n      for await (const events of this.parse()) {\r\n        for (const {eventType, value} of events) {\r\n          this.emit(eventType, value);\r\n        }\r\n      }\r\n      this.emit('finished');\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n    }\r\n  }\r\n\r\n  async *[Symbol.asyncIterator]() {\r\n    for await (const events of this.parse()) {\r\n      for (const {eventType, value} of events) {\r\n        if (eventType === 'row') {\r\n          yield value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async *parse() {\r\n    const {iterator, options} = this;\r\n    let emitSheet = false;\r\n    let emitHyperlinks = false;\r\n    let hyperlinks = null;\r\n    switch (options.worksheets) {\r\n      case 'emit':\r\n        emitSheet = true;\r\n        break;\r\n      case 'prep':\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    switch (options.hyperlinks) {\r\n      case 'emit':\r\n        emitHyperlinks = true;\r\n        break;\r\n      case 'cache':\r\n        this.hyperlinks = hyperlinks = {};\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    if (!emitSheet && !emitHyperlinks && !hyperlinks) {\r\n      return;\r\n    }\r\n\r\n    // references\r\n    const {sharedStrings, styles, properties} = this.workbook;\r\n\r\n    // xml position\r\n    let inCols = false;\r\n    let inRows = false;\r\n    let inHyperlinks = false;\r\n\r\n    // parse state\r\n    let cols = null;\r\n    let row = null;\r\n    let c = null;\r\n    let current = null;\r\n    for await (const events of parseSax(iterator)) {\r\n      const worksheetEvents = [];\r\n      for (const {eventType, value} of events) {\r\n        if (eventType === 'opentag') {\r\n          const node = value;\r\n          if (emitSheet) {\r\n            switch (node.name) {\r\n              case 'cols':\r\n                inCols = true;\r\n                cols = [];\r\n                break;\r\n              case 'sheetData':\r\n                inRows = true;\r\n                break;\r\n\r\n              case 'col':\r\n                if (inCols) {\r\n                  cols.push({\r\n                    min: parseInt(node.attributes.min, 10),\r\n                    max: parseInt(node.attributes.max, 10),\r\n                    width: parseFloat(node.attributes.width),\r\n                    styleId: parseInt(node.attributes.style || '0', 10),\r\n                  });\r\n                }\r\n                break;\r\n\r\n              case 'row':\r\n                if (inRows) {\r\n                  const r = parseInt(node.attributes.r, 10);\r\n                  row = new Row(this, r);\r\n                  if (node.attributes.ht) {\r\n                    row.height = parseFloat(node.attributes.ht);\r\n                  }\r\n                  if (node.attributes.s) {\r\n                    const styleId = parseInt(node.attributes.s, 10);\r\n                    const style = styles.getStyleModel(styleId);\r\n                    if (style) {\r\n                      row.style = style;\r\n                    }\r\n                  }\r\n                }\r\n                break;\r\n              case 'c':\r\n                if (row) {\r\n                  c = {\r\n                    ref: node.attributes.r,\r\n                    s: parseInt(node.attributes.s, 10),\r\n                    t: node.attributes.t,\r\n                  };\r\n                }\r\n                break;\r\n              case 'f':\r\n                if (c) {\r\n                  current = c.f = {text: ''};\r\n                }\r\n                break;\r\n              case 'v':\r\n                if (c) {\r\n                  current = c.v = {text: ''};\r\n                }\r\n                break;\r\n              case 'mergeCell':\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          // =================================================================\r\n          //\r\n          if (emitHyperlinks || hyperlinks) {\r\n            switch (node.name) {\r\n              case 'hyperlinks':\r\n                inHyperlinks = true;\r\n                break;\r\n              case 'hyperlink':\r\n                if (inHyperlinks) {\r\n                  const hyperlink = {\r\n                    ref: node.attributes.ref,\r\n                    rId: node.attributes['r:id'],\r\n                  };\r\n                  if (emitHyperlinks) {\r\n                    worksheetEvents.push({eventType: 'hyperlink', value: hyperlink});\r\n                  } else {\r\n                    hyperlinks[hyperlink.ref] = hyperlink;\r\n                  }\r\n                }\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n        } else if (eventType === 'text') {\r\n          // only text data is for sheet values\r\n          if (emitSheet) {\r\n            if (current) {\r\n              current.text += value;\r\n            }\r\n          }\r\n        } else if (eventType === 'closetag') {\r\n          const node = value;\r\n          if (emitSheet) {\r\n            switch (node.name) {\r\n              case 'cols':\r\n                inCols = false;\r\n                this._columns = Column.fromModel(cols);\r\n                break;\r\n              case 'sheetData':\r\n                inRows = false;\r\n                break;\r\n\r\n              case 'row':\r\n                this._dimensions.expandRow(row);\r\n                worksheetEvents.push({eventType: 'row', value: row});\r\n                row = null;\r\n                break;\r\n\r\n              case 'c':\r\n                if (row && c) {\r\n                  const address = colCache.decodeAddress(c.ref);\r\n                  const cell = row.getCell(address.col);\r\n                  if (c.s) {\r\n                    const style = styles.getStyleModel(c.s);\r\n                    if (style) {\r\n                      cell.style = style;\r\n                    }\r\n                  }\r\n\r\n                  if (c.f) {\r\n                    const cellValue = {\r\n                      formula: c.f.text,\r\n                    };\r\n                    if (c.v) {\r\n                      if (c.t === 'str') {\r\n                        cellValue.result = utils.xmlDecode(c.v.text);\r\n                      } else {\r\n                        cellValue.result = parseFloat(c.v.text);\r\n                      }\r\n                    }\r\n                    cell.value = cellValue;\r\n                  } else if (c.v) {\r\n                    switch (c.t) {\r\n                      case 's': {\r\n                        const index = parseInt(c.v.text, 10);\r\n                        if (sharedStrings) {\r\n                          cell.value = sharedStrings[index];\r\n                        } else {\r\n                          cell.value = {\r\n                            sharedString: index,\r\n                          };\r\n                        }\r\n                        break;\r\n                      }\r\n\r\n                      case 'str':\r\n                        cell.value = utils.xmlDecode(c.v.text);\r\n                        break;\r\n\r\n                      case 'e':\r\n                        cell.value = {error: c.v.text};\r\n                        break;\r\n\r\n                      case 'b':\r\n                        cell.value = parseInt(c.v.text, 10) !== 0;\r\n                        break;\r\n\r\n                      default:\r\n                        if (utils.isDateFmt(cell.numFmt)) {\r\n                          cell.value = utils.excelToDate(\r\n                            parseFloat(c.v.text),\r\n                            properties.model && properties.model.date1904\r\n                          );\r\n                        } else {\r\n                          cell.value = parseFloat(c.v.text);\r\n                        }\r\n                        break;\r\n                    }\r\n                  }\r\n                  if (hyperlinks) {\r\n                    const hyperlink = hyperlinks[c.ref];\r\n                    if (hyperlink) {\r\n                      cell.text = cell.value;\r\n                      cell.value = undefined;\r\n                      cell.hyperlink = hyperlink;\r\n                    }\r\n                  }\r\n                  c = null;\r\n                }\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n          if (emitHyperlinks || hyperlinks) {\r\n            switch (node.name) {\r\n              case 'hyperlinks':\r\n                inHyperlinks = false;\r\n                break;\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (worksheetEvents.length > 0) {\r\n        yield worksheetEvents;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = WorksheetReader;\r\n","const {EventEmitter} = require('events');\r\nconst parseSax = require('../../utils/parse-sax');\r\n\r\nconst Enums = require('../../doc/enums');\r\nconst RelType = require('../../xlsx/rel-type');\r\n\r\nclass HyperlinkReader extends EventEmitter {\r\n  constructor({workbook, id, iterator, options}) {\r\n    super();\r\n\r\n    this.workbook = workbook;\r\n    this.id = id;\r\n    this.iterator = iterator;\r\n    this.options = options;\r\n  }\r\n\r\n  get count() {\r\n    return (this.hyperlinks && this.hyperlinks.length) || 0;\r\n  }\r\n\r\n  each(fn) {\r\n    return this.hyperlinks.forEach(fn);\r\n  }\r\n\r\n  async read() {\r\n    const {iterator, options} = this;\r\n    let emitHyperlinks = false;\r\n    let hyperlinks = null;\r\n    switch (options.hyperlinks) {\r\n      case 'emit':\r\n        emitHyperlinks = true;\r\n        break;\r\n      case 'cache':\r\n        this.hyperlinks = hyperlinks = {};\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (!emitHyperlinks && !hyperlinks) {\r\n      this.emit('finished');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      for await (const events of parseSax(iterator)) {\r\n        for (const {eventType, value} of events) {\r\n          if (eventType === 'opentag') {\r\n            const node = value;\r\n            if (node.name === 'Relationship') {\r\n              const rId = node.attributes.Id;\r\n              switch (node.attributes.Type) {\r\n                case RelType.Hyperlink:\r\n                  {\r\n                    const relationship = {\r\n                      type: Enums.RelationshipType.Styles,\r\n                      rId,\r\n                      target: node.attributes.Target,\r\n                      targetMode: node.attributes.TargetMode,\r\n                    };\r\n                    if (emitHyperlinks) {\r\n                      this.emit('hyperlink', relationship);\r\n                    } else {\r\n                      hyperlinks[relationship.rId] = relationship;\r\n                    }\r\n                  }\r\n                  break;\r\n\r\n                default:\r\n                  break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.emit('finished');\r\n    } catch (error) {\r\n      this.emit('error', error);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = HyperlinkReader;\r\n"]}