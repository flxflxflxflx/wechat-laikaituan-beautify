{"version":3,"sources":["index.js","ParserOptions.js","CsvParserStream.js","transforms/index.js","transforms/RowTransformerValidator.js","types.js","transforms/HeaderTransformer.js","parser/index.js","parser/Parser.js","parser/Scanner.js","parser/Token.js","parser/RowParser.js","parser/column/index.js","parser/column/ColumnParser.js","parser/column/NonQuotedColumnParser.js","parser/column/ColumnFormatter.js","parser/column/QuotedColumnParser.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AIZA,ADGA;ADIA,ADGA,ADGA,AIZA,ADGA;ADIA,ADGA,ADGA,AIZA,ADGA;ADIA,ADGA,ADGA,AIZA,ADGA,AENA;AHUA,ADGA,ADGA,AIZA,ADGA,AENA;AHUA,ADGA,ADGA,AIZA,ACHA;AHUA,ADGA,ADGA,AMlBA,AFMA,ACHA;AHUA,ADGA,ADGA,AMlBA,AFMA,ACHA;AHUA,ADGA,ADGA,AMlBA,AFMA,ACHA;AHUA,ADGA,ADGA,AOrBA,ADGA,AFMA;AFOA,ADGA,ADGA,AOrBA,ADGA,AFMA;AFOA,ADGA,ADGA,AOrBA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ADGA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ADGA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ADGA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,AFMA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,AFMA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,AFMA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,ACHA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AHSA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AENA,ALeA,ADGA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AENA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AENA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AGTA,ADGA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AGTA,ADGA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AGTA,ADGA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AGTA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,ADGA,AQxBA,AGTA,AFMA,ACHA,AGTA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AGTA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AFMA,ANkBA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,ADGA,AOrBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,ACHA,AKfA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AMlBA,AFMA,ACHA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AMlBA,ADGA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AMlBA,ADGA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AMlBA,ADGA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AMlBA,ADGA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AKfA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AKfA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AKfA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AKfA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AKfA,AENA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AMlBA,AGTA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA,AFMA;AFOA,AS3BA,AFMA,AOrBA,AV8BA;AJaA,AS3BA,AFMA,AOrBA,AV8BA;AJaA,AS3BA,AFMA,AOrBA,AV8BA;AJaA,AS3BA,AFMA,AOrBA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA,AV8BA;AJaA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst stream_1 = require(\"stream\");\nconst ParserOptions_1 = require(\"./ParserOptions\");\nconst CsvParserStream_1 = require(\"./CsvParserStream\");\n__exportStar(require(\"./types\"), exports);\nvar CsvParserStream_2 = require(\"./CsvParserStream\");\nObject.defineProperty(exports, \"CsvParserStream\", { enumerable: true, get: function () { return CsvParserStream_2.CsvParserStream; } });\nvar ParserOptions_2 = require(\"./ParserOptions\");\nObject.defineProperty(exports, \"ParserOptions\", { enumerable: true, get: function () { return ParserOptions_2.ParserOptions; } });\nexports.parse = (args) => new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));\nexports.parseStream = (stream, options) => stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\nexports.parseFile = (location, options = {}) => fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\nexports.parseString = (string, options) => {\n    const rs = new stream_1.Readable();\n    rs.push(string);\n    rs.push(null);\n    return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\n};\n//# sourceMappingURL=index.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserOptions = void 0;\nconst lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\nconst lodash_isnil_1 = __importDefault(require(\"lodash.isnil\"));\nclass ParserOptions {\n    constructor(opts) {\n        var _a;\n        this.objectMode = true;\n        this.delimiter = ',';\n        this.ignoreEmpty = false;\n        this.quote = '\"';\n        this.escape = null;\n        this.escapeChar = this.quote;\n        this.comment = null;\n        this.supportsComments = false;\n        this.ltrim = false;\n        this.rtrim = false;\n        this.trim = false;\n        this.headers = null;\n        this.renameHeaders = false;\n        this.strictColumnHandling = false;\n        this.discardUnmappedColumns = false;\n        this.carriageReturn = '\\r';\n        this.encoding = 'utf8';\n        this.limitRows = false;\n        this.maxRows = 0;\n        this.skipLines = 0;\n        this.skipRows = 0;\n        Object.assign(this, opts || {});\n        if (this.delimiter.length > 1) {\n            throw new Error('delimiter option must be one character long');\n        }\n        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);\n        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;\n        this.supportsComments = !lodash_isnil_1.default(this.comment);\n        this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\\\s]|\\\\r\\\\n|\\\\n|\\\\r|${this.escapedDelimiter})`);\n        if (this.maxRows > 0) {\n            this.limitRows = true;\n        }\n    }\n}\nexports.ParserOptions = ParserOptions;\n//# sourceMappingURL=ParserOptions.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CsvParserStream = void 0;\nconst string_decoder_1 = require(\"string_decoder\");\nconst stream_1 = require(\"stream\");\nconst transforms_1 = require(\"./transforms\");\nconst parser_1 = require(\"./parser\");\nclass CsvParserStream extends stream_1.Transform {\n    constructor(parserOptions) {\n        super({ objectMode: parserOptions.objectMode });\n        this.lines = '';\n        this.rowCount = 0;\n        this.parsedRowCount = 0;\n        this.parsedLineCount = 0;\n        this.endEmitted = false;\n        this.headersEmitted = false;\n        this.parserOptions = parserOptions;\n        this.parser = new parser_1.Parser(parserOptions);\n        this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);\n        this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);\n        this.rowTransformerValidator = new transforms_1.RowTransformerValidator();\n    }\n    get hasHitRowLimit() {\n        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;\n    }\n    get shouldEmitRows() {\n        return this.parsedRowCount > this.parserOptions.skipRows;\n    }\n    get shouldSkipLine() {\n        return this.parsedLineCount <= this.parserOptions.skipLines;\n    }\n    transform(transformFunction) {\n        this.rowTransformerValidator.rowTransform = transformFunction;\n        return this;\n    }\n    validate(validateFunction) {\n        this.rowTransformerValidator.rowValidator = validateFunction;\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    emit(event, ...rest) {\n        if (event === 'end') {\n            if (!this.endEmitted) {\n                this.endEmitted = true;\n                super.emit('end', this.rowCount);\n            }\n            return false;\n        }\n        return super.emit(event, ...rest);\n    }\n    _transform(data, encoding, done) {\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return done();\n        }\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        try {\n            const { lines } = this;\n            const newLine = lines + this.decoder.write(data);\n            const rows = this.parse(newLine, true);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    _flush(done) {\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return wrappedCallback();\n        }\n        try {\n            const newLine = this.lines + this.decoder.end();\n            const rows = this.parse(newLine, false);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    parse(data, hasMoreData) {\n        if (!data) {\n            return [];\n        }\n        const { line, rows } = this.parser.parse(data, hasMoreData);\n        this.lines = line;\n        return rows;\n    }\n    processRows(rows, cb) {\n        const rowsLength = rows.length;\n        const iterate = (i) => {\n            const callNext = (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (i % 100 === 0) {\n                    // incase the transform are sync insert a next tick to prevent stack overflow\n                    setImmediate(() => iterate(i + 1));\n                    return undefined;\n                }\n                return iterate(i + 1);\n            };\n            this.checkAndEmitHeaders();\n            // if we have emitted all rows or we have hit the maxRows limit option\n            // then end\n            if (i >= rowsLength || this.hasHitRowLimit) {\n                return cb();\n            }\n            this.parsedLineCount += 1;\n            if (this.shouldSkipLine) {\n                return callNext();\n            }\n            const row = rows[i];\n            this.rowCount += 1;\n            this.parsedRowCount += 1;\n            const nextRowCount = this.rowCount;\n            return this.transformRow(row, (err, transformResult) => {\n                if (err) {\n                    this.rowCount -= 1;\n                    return callNext(err);\n                }\n                if (!transformResult) {\n                    return callNext(new Error('expected transform result'));\n                }\n                if (!transformResult.isValid) {\n                    this.emit('data-invalid', transformResult.row, nextRowCount, transformResult.reason);\n                }\n                else if (transformResult.row) {\n                    return this.pushRow(transformResult.row, callNext);\n                }\n                return callNext();\n            });\n        };\n        iterate(0);\n    }\n    transformRow(parsedRow, cb) {\n        try {\n            this.headerTransformer.transform(parsedRow, (err, withHeaders) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!withHeaders) {\n                    return cb(new Error('Expected result from header transform'));\n                }\n                if (!withHeaders.isValid) {\n                    if (this.shouldEmitRows) {\n                        return cb(null, { isValid: false, row: parsedRow });\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                if (withHeaders.row) {\n                    if (this.shouldEmitRows) {\n                        return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                // this is a header row dont include in the rowCount or parsedRowCount\n                this.rowCount -= 1;\n                this.parsedRowCount -= 1;\n                return cb(null, { row: null, isValid: true });\n            });\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    checkAndEmitHeaders() {\n        if (!this.headersEmitted && this.headerTransformer.headers) {\n            this.headersEmitted = true;\n            this.emit('headers', this.headerTransformer.headers);\n        }\n    }\n    skipRow(cb) {\n        // skipped because of skipRows option remove from total row count\n        this.rowCount -= 1;\n        return cb(null, { row: null, isValid: true });\n    }\n    pushRow(row, cb) {\n        try {\n            if (!this.parserOptions.objectMode) {\n                this.push(JSON.stringify(row));\n            }\n            else {\n                this.push(row);\n            }\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    static wrapDoneCallback(done) {\n        let errorCalled = false;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (err, ...args) => {\n            if (err) {\n                if (errorCalled) {\n                    throw err;\n                }\n                errorCalled = true;\n                done(err);\n                return;\n            }\n            done(...args);\n        };\n    }\n}\nexports.CsvParserStream = CsvParserStream;\n//# sourceMappingURL=CsvParserStream.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeaderTransformer = exports.RowTransformerValidator = void 0;\nvar RowTransformerValidator_1 = require(\"./RowTransformerValidator\");\nObject.defineProperty(exports, \"RowTransformerValidator\", { enumerable: true, get: function () { return RowTransformerValidator_1.RowTransformerValidator; } });\nvar HeaderTransformer_1 = require(\"./HeaderTransformer\");\nObject.defineProperty(exports, \"HeaderTransformer\", { enumerable: true, get: function () { return HeaderTransformer_1.HeaderTransformer; } });\n//# sourceMappingURL=index.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RowTransformerValidator = void 0;\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\nconst types_1 = require(\"../types\");\nclass RowTransformerValidator {\n    constructor() {\n        this._rowTransform = null;\n        this._rowValidator = null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static createTransform(transformFunction) {\n        if (types_1.isSyncTransform(transformFunction)) {\n            return (row, cb) => {\n                let transformed = null;\n                try {\n                    transformed = transformFunction(row);\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                return cb(null, transformed);\n            };\n        }\n        return transformFunction;\n    }\n    static createValidator(validateFunction) {\n        if (types_1.isSyncValidate(validateFunction)) {\n            return (row, cb) => {\n                cb(null, { row, isValid: validateFunction(row) });\n            };\n        }\n        return (row, cb) => {\n            validateFunction(row, (err, isValid, reason) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (isValid) {\n                    return cb(null, { row, isValid, reason });\n                }\n                return cb(null, { row, isValid: false, reason });\n            });\n        };\n    }\n    set rowTransform(transformFunction) {\n        if (!lodash_isfunction_1.default(transformFunction)) {\n            throw new TypeError('The transform should be a function');\n        }\n        this._rowTransform = RowTransformerValidator.createTransform(transformFunction);\n    }\n    set rowValidator(validateFunction) {\n        if (!lodash_isfunction_1.default(validateFunction)) {\n            throw new TypeError('The validate should be a function');\n        }\n        this._rowValidator = RowTransformerValidator.createValidator(validateFunction);\n    }\n    transformAndValidate(row, cb) {\n        return this.callTransformer(row, (transformErr, transformedRow) => {\n            if (transformErr) {\n                return cb(transformErr);\n            }\n            if (!transformedRow) {\n                return cb(null, { row: null, isValid: true });\n            }\n            return this.callValidator(transformedRow, (validateErr, validationResult) => {\n                if (validateErr) {\n                    return cb(validateErr);\n                }\n                if (validationResult && !validationResult.isValid) {\n                    return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });\n                }\n                return cb(null, { row: transformedRow, isValid: true });\n            });\n        });\n    }\n    callTransformer(row, cb) {\n        if (!this._rowTransform) {\n            return cb(null, row);\n        }\n        return this._rowTransform(row, cb);\n    }\n    callValidator(row, cb) {\n        if (!this._rowValidator) {\n            return cb(null, { row, isValid: true });\n        }\n        return this._rowValidator(row, cb);\n    }\n}\nexports.RowTransformerValidator = RowTransformerValidator;\n//# sourceMappingURL=RowTransformerValidator.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSyncValidate = exports.isSyncTransform = void 0;\nexports.isSyncTransform = (transform) => transform.length === 1;\nexports.isSyncValidate = (validate) => validate.length === 1;\n//# sourceMappingURL=types.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeaderTransformer = void 0;\nconst lodash_isundefined_1 = __importDefault(require(\"lodash.isundefined\"));\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\nconst lodash_uniq_1 = __importDefault(require(\"lodash.uniq\"));\nconst lodash_groupby_1 = __importDefault(require(\"lodash.groupby\"));\nclass HeaderTransformer {\n    constructor(parserOptions) {\n        this.headers = null;\n        this.receivedHeaders = false;\n        this.shouldUseFirstRow = false;\n        this.processedFirstRow = false;\n        this.headersLength = 0;\n        this.parserOptions = parserOptions;\n        if (parserOptions.headers === true) {\n            this.shouldUseFirstRow = true;\n        }\n        else if (Array.isArray(parserOptions.headers)) {\n            this.setHeaders(parserOptions.headers);\n        }\n        else if (lodash_isfunction_1.default(parserOptions.headers)) {\n            this.headersTransform = parserOptions.headers;\n        }\n    }\n    transform(row, cb) {\n        if (!this.shouldMapRow(row)) {\n            return cb(null, { row: null, isValid: true });\n        }\n        return cb(null, this.processRow(row));\n    }\n    shouldMapRow(row) {\n        const { parserOptions } = this;\n        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {\n            if (!this.receivedHeaders) {\n                throw new Error('Error renaming headers: new headers must be provided in an array');\n            }\n            this.processedFirstRow = true;\n            return false;\n        }\n        if (!this.receivedHeaders && Array.isArray(row)) {\n            if (this.headersTransform) {\n                this.setHeaders(this.headersTransform(row));\n            }\n            else if (this.shouldUseFirstRow) {\n                this.setHeaders(row);\n            }\n            else {\n                // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    processRow(row) {\n        if (!this.headers) {\n            return { row: row, isValid: true };\n        }\n        const { parserOptions } = this;\n        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {\n            if (!parserOptions.strictColumnHandling) {\n                throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);\n            }\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        return { row: this.mapHeaders(row), isValid: true };\n    }\n    mapHeaders(row) {\n        const rowMap = {};\n        const { headers, headersLength } = this;\n        for (let i = 0; i < headersLength; i += 1) {\n            const header = headers[i];\n            if (!lodash_isundefined_1.default(header)) {\n                const val = row[i];\n                // eslint-disable-next-line no-param-reassign\n                if (lodash_isundefined_1.default(val)) {\n                    rowMap[header] = '';\n                }\n                else {\n                    rowMap[header] = val;\n                }\n            }\n        }\n        return rowMap;\n    }\n    setHeaders(headers) {\n        var _a;\n        const filteredHeaders = headers.filter((h) => !!h);\n        if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {\n            const grouped = lodash_groupby_1.default(filteredHeaders);\n            const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);\n            throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);\n        }\n        this.headers = headers;\n        this.receivedHeaders = true;\n        this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;\n    }\n}\nexports.HeaderTransformer = HeaderTransformer;\n//# sourceMappingURL=HeaderTransformer.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;\nvar Parser_1 = require(\"./Parser\");\nObject.defineProperty(exports, \"Parser\", { enumerable: true, get: function () { return Parser_1.Parser; } });\nvar RowParser_1 = require(\"./RowParser\");\nObject.defineProperty(exports, \"RowParser\", { enumerable: true, get: function () { return RowParser_1.RowParser; } });\nvar Scanner_1 = require(\"./Scanner\");\nObject.defineProperty(exports, \"Scanner\", { enumerable: true, get: function () { return Scanner_1.Scanner; } });\nvar Token_1 = require(\"./Token\");\nObject.defineProperty(exports, \"Token\", { enumerable: true, get: function () { return Token_1.Token; } });\nvar column_1 = require(\"./column\");\nObject.defineProperty(exports, \"ColumnParser\", { enumerable: true, get: function () { return column_1.ColumnParser; } });\nObject.defineProperty(exports, \"NonQuotedColumnParser\", { enumerable: true, get: function () { return column_1.NonQuotedColumnParser; } });\nObject.defineProperty(exports, \"QuotedColumnParser\", { enumerable: true, get: function () { return column_1.QuotedColumnParser; } });\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst Scanner_1 = require(\"./Scanner\");\nconst RowParser_1 = require(\"./RowParser\");\nconst Token_1 = require(\"./Token\");\nclass Parser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.rowParser = new RowParser_1.RowParser(this.parserOptions);\n    }\n    static removeBOM(line) {\n        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n        // conversion translates it to FEFF (UTF-16 BOM)\n        if (line && line.charCodeAt(0) === 0xfeff) {\n            return line.slice(1);\n        }\n        return line;\n    }\n    parse(line, hasMoreData) {\n        const scanner = new Scanner_1.Scanner({\n            line: Parser.removeBOM(line),\n            parserOptions: this.parserOptions,\n            hasMoreData,\n        });\n        if (this.parserOptions.supportsComments) {\n            return this.parseWithComments(scanner);\n        }\n        return this.parseWithoutComments(scanner);\n    }\n    parseWithoutComments(scanner) {\n        const rows = [];\n        let shouldContinue = true;\n        while (shouldContinue) {\n            shouldContinue = this.parseRow(scanner, rows);\n        }\n        return { line: scanner.line, rows };\n    }\n    parseWithComments(scanner) {\n        const { parserOptions } = this;\n        const rows = [];\n        for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {\n                const cursor = scanner.advancePastLine();\n                if (cursor === null) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                if (!scanner.hasMoreCharacters) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                scanner.truncateToCursor();\n            }\n            else if (!this.parseRow(scanner, rows)) {\n                break;\n            }\n        }\n        return { line: scanner.line, rows };\n    }\n    parseRow(scanner, rows) {\n        const nextToken = scanner.nextNonSpaceToken;\n        if (!nextToken) {\n            return false;\n        }\n        const row = this.rowParser.parse(scanner);\n        if (row === null) {\n            return false;\n        }\n        if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {\n            return true;\n        }\n        rows.push(row);\n        return true;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Scanner = void 0;\nconst Token_1 = require(\"./Token\");\nconst ROW_DELIMITER = /((?:\\r\\n)|\\n|\\r)/;\nclass Scanner {\n    constructor(args) {\n        this.cursor = 0;\n        this.line = args.line;\n        this.lineLength = this.line.length;\n        this.parserOptions = args.parserOptions;\n        this.hasMoreData = args.hasMoreData;\n        this.cursor = args.cursor || 0;\n    }\n    get hasMoreCharacters() {\n        return this.lineLength > this.cursor;\n    }\n    get nextNonSpaceToken() {\n        const { lineFromCursor } = this;\n        const regex = this.parserOptions.NEXT_TOKEN_REGEXP;\n        if (lineFromCursor.search(regex) === -1) {\n            return null;\n        }\n        const match = regex.exec(lineFromCursor);\n        if (match == null) {\n            return null;\n        }\n        const token = match[1];\n        const startCursor = this.cursor + (match.index || 0);\n        return new Token_1.Token({\n            token,\n            startCursor,\n            endCursor: startCursor + token.length - 1,\n        });\n    }\n    get nextCharacterToken() {\n        const { cursor, lineLength } = this;\n        if (lineLength <= cursor) {\n            return null;\n        }\n        return new Token_1.Token({\n            token: this.line[cursor],\n            startCursor: cursor,\n            endCursor: cursor,\n        });\n    }\n    get lineFromCursor() {\n        return this.line.substr(this.cursor);\n    }\n    advancePastLine() {\n        const match = ROW_DELIMITER.exec(this.lineFromCursor);\n        if (!match) {\n            if (this.hasMoreData) {\n                return null;\n            }\n            this.cursor = this.lineLength;\n            return this;\n        }\n        this.cursor += (match.index || 0) + match[0].length;\n        return this;\n    }\n    advanceTo(cursor) {\n        this.cursor = cursor;\n        return this;\n    }\n    advanceToToken(token) {\n        this.cursor = token.startCursor;\n        return this;\n    }\n    advancePastToken(token) {\n        this.cursor = token.endCursor + 1;\n        return this;\n    }\n    truncateToCursor() {\n        this.line = this.lineFromCursor;\n        this.lineLength = this.line.length;\n        this.cursor = 0;\n        return this;\n    }\n}\nexports.Scanner = Scanner;\n//# sourceMappingURL=Scanner.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Token = void 0;\nclass Token {\n    constructor(tokenArgs) {\n        this.token = tokenArgs.token;\n        this.startCursor = tokenArgs.startCursor;\n        this.endCursor = tokenArgs.endCursor;\n    }\n    static isTokenRowDelimiter(token) {\n        const content = token.token;\n        return content === '\\r' || content === '\\n' || content === '\\r\\n';\n    }\n    static isTokenCarriageReturn(token, parserOptions) {\n        return token.token === parserOptions.carriageReturn;\n    }\n    static isTokenComment(token, parserOptions) {\n        return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;\n    }\n    static isTokenEscapeCharacter(token, parserOptions) {\n        return token.token === parserOptions.escapeChar;\n    }\n    static isTokenQuote(token, parserOptions) {\n        return token.token === parserOptions.quote;\n    }\n    static isTokenDelimiter(token, parserOptions) {\n        return token.token === parserOptions.delimiter;\n    }\n}\nexports.Token = Token;\n//# sourceMappingURL=Token.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RowParser = void 0;\nconst column_1 = require(\"./column\");\nconst Token_1 = require(\"./Token\");\nconst EMPTY_STRING = '';\nclass RowParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnParser = new column_1.ColumnParser(parserOptions);\n    }\n    static isEmptyRow(row) {\n        return row.join(EMPTY_STRING).replace(/\\s+/g, EMPTY_STRING) === EMPTY_STRING;\n    }\n    parse(scanner) {\n        const { parserOptions } = this;\n        const { hasMoreData } = scanner;\n        const currentScanner = scanner;\n        const columns = [];\n        let currentToken = this.getStartToken(currentScanner, columns);\n        while (currentToken) {\n            if (Token_1.Token.isTokenRowDelimiter(currentToken)) {\n                currentScanner.advancePastToken(currentToken);\n                // if ends with CR and there is more data, keep unparsed due to possible\n                // coming LF in CRLF\n                if (!currentScanner.hasMoreCharacters &&\n                    Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) &&\n                    hasMoreData) {\n                    return null;\n                }\n                currentScanner.truncateToCursor();\n                return columns;\n            }\n            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {\n                const item = this.columnParser.parse(currentScanner);\n                if (item === null) {\n                    return null;\n                }\n                columns.push(item);\n            }\n            currentToken = currentScanner.nextNonSpaceToken;\n        }\n        if (!hasMoreData) {\n            currentScanner.truncateToCursor();\n            return columns;\n        }\n        return null;\n    }\n    getStartToken(scanner, columns) {\n        const currentToken = scanner.nextNonSpaceToken;\n        if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {\n            columns.push('');\n            return scanner.nextNonSpaceToken;\n        }\n        return currentToken;\n    }\n    shouldSkipColumnParse(scanner, currentToken, columns) {\n        const { parserOptions } = this;\n        if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {\n            scanner.advancePastToken(currentToken);\n            // if the delimiter is at the end of a line\n            const nextToken = scanner.nextCharacterToken;\n            if (!scanner.hasMoreCharacters || (nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken))) {\n                columns.push('');\n                return true;\n            }\n            if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {\n                columns.push('');\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.RowParser = RowParser;\n//# sourceMappingURL=RowParser.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;\nvar ColumnParser_1 = require(\"./ColumnParser\");\nObject.defineProperty(exports, \"ColumnParser\", { enumerable: true, get: function () { return ColumnParser_1.ColumnParser; } });\nvar NonQuotedColumnParser_1 = require(\"./NonQuotedColumnParser\");\nObject.defineProperty(exports, \"NonQuotedColumnParser\", { enumerable: true, get: function () { return NonQuotedColumnParser_1.NonQuotedColumnParser; } });\nvar QuotedColumnParser_1 = require(\"./QuotedColumnParser\");\nObject.defineProperty(exports, \"QuotedColumnParser\", { enumerable: true, get: function () { return QuotedColumnParser_1.QuotedColumnParser; } });\nvar ColumnFormatter_1 = require(\"./ColumnFormatter\");\nObject.defineProperty(exports, \"ColumnFormatter\", { enumerable: true, get: function () { return ColumnFormatter_1.ColumnFormatter; } });\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColumnParser = void 0;\nconst NonQuotedColumnParser_1 = require(\"./NonQuotedColumnParser\");\nconst QuotedColumnParser_1 = require(\"./QuotedColumnParser\");\nconst Token_1 = require(\"../Token\");\nclass ColumnParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);\n        this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);\n    }\n    parse(scanner) {\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {\n            scanner.advanceToToken(nextNonSpaceToken);\n            return this.quotedColumnParser.parse(scanner);\n        }\n        return this.nonQuotedColumnParser.parse(scanner);\n    }\n}\nexports.ColumnParser = ColumnParser;\n//# sourceMappingURL=ColumnParser.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NonQuotedColumnParser = void 0;\nconst ColumnFormatter_1 = require(\"./ColumnFormatter\");\nconst Token_1 = require(\"../Token\");\nclass NonQuotedColumnParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const { parserOptions } = this;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; nextToken; nextToken = scanner.nextCharacterToken) {\n            if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {\n                break;\n            }\n            characters.push(nextToken.token);\n            scanner.advancePastToken(nextToken);\n        }\n        return this.columnFormatter.format(characters.join(''));\n    }\n}\nexports.NonQuotedColumnParser = NonQuotedColumnParser;\n//# sourceMappingURL=NonQuotedColumnParser.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColumnFormatter = void 0;\nclass ColumnFormatter {\n    constructor(parserOptions) {\n        if (parserOptions.trim) {\n            this.format = (col) => col.trim();\n        }\n        else if (parserOptions.ltrim) {\n            this.format = (col) => col.trimLeft();\n        }\n        else if (parserOptions.rtrim) {\n            this.format = (col) => col.trimRight();\n        }\n        else {\n            this.format = (col) => col;\n        }\n    }\n}\nexports.ColumnFormatter = ColumnFormatter;\n//# sourceMappingURL=ColumnFormatter.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuotedColumnParser = void 0;\nconst ColumnFormatter_1 = require(\"./ColumnFormatter\");\nconst Token_1 = require(\"../Token\");\nclass QuotedColumnParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const originalCursor = scanner.cursor;\n        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);\n        if (!foundClosingQuote) {\n            // reset the cursor to the original\n            scanner.advanceTo(originalCursor);\n            // if we didnt find a closing quote but we potentially have more data then skip the parsing\n            // and return the original scanner.\n            if (!scanner.hasMoreData) {\n                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\\r\\n]/g, \"\\\\n'\")}'`);\n            }\n            return null;\n        }\n        this.checkForMalformedColumn(scanner);\n        return col;\n    }\n    gatherDataBetweenQuotes(scanner) {\n        const { parserOptions } = this;\n        let foundStartingQuote = false;\n        let foundClosingQuote = false;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);\n            // ignore first quote\n            if (!foundStartingQuote && isQuote) {\n                foundStartingQuote = true;\n            }\n            else if (foundStartingQuote) {\n                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {\n                    // advance past the escape character so we can get the next one in line\n                    scanner.advancePastToken(nextToken);\n                    const tokenFollowingEscape = scanner.nextCharacterToken;\n                    // if the character following the escape is a quote character then just add\n                    // the quote and advance to that character\n                    if (tokenFollowingEscape !== null &&\n                        (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) ||\n                            Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {\n                        characters.push(tokenFollowingEscape.token);\n                        nextToken = tokenFollowingEscape;\n                    }\n                    else if (isQuote) {\n                        // if the escape is also a quote then we found our closing quote and finish early\n                        foundClosingQuote = true;\n                    }\n                    else {\n                        // other wise add the escape token to the characters since it wast escaping anything\n                        characters.push(nextToken.token);\n                    }\n                }\n                else if (isQuote) {\n                    // we found our closing quote!\n                    foundClosingQuote = true;\n                }\n                else {\n                    // add the token to the characters\n                    characters.push(nextToken.token);\n                }\n            }\n            scanner.advancePastToken(nextToken);\n        }\n        return { col: this.columnFormatter.format(characters.join('')), foundClosingQuote };\n    }\n    checkForMalformedColumn(scanner) {\n        const { parserOptions } = this;\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken) {\n            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);\n            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);\n            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {\n                // if the final quote was NOT followed by a column (,) or row(\\n) delimiter then its a bad column\n                // tldr: only part of the column was quoted\n                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\\r\\n]/g, \"\\\\n'\");\n                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);\n            }\n            scanner.advanceToToken(nextNonSpaceToken);\n        }\n        else if (!scanner.hasMoreData) {\n            scanner.advancePastLine();\n        }\n    }\n}\nexports.QuotedColumnParser = QuotedColumnParser;\n//# sourceMappingURL=QuotedColumnParser.js.map"]}